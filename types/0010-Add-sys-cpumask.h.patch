From 9d9ee247c549dfa0426632e49236447d28cb8022 Mon Sep 17 00:00:00 2001
From: zrj <rimvydas.jasinskas@gmail.com>
Date: Mon, 4 Nov 2019 16:46:30 +0200
Subject: [PATCH 10/10] Add <sys/cpumask.h>.

 Collect and gather all scatter cpumask bits to correct headers. This
 cleans up the namespace and simplifies platform handling in asm macros.
 The cpumask_t together with its macros is already non MI feature that is
 used in userland utilities, libraries, kernel scheduler and syscalls.
 It deserves sys/ header.  Adjust syscalls.master and rerun sysent.

 While there, fix an issue in ports that set POSIX env, but has
 implementation of setting thread names through pthread_set_name_np().
---
 include/pthread_np.h                  | 13 +++++-
 lib/libthread_xu/thread/thr_private.h |  2 +-
 sbin/usched/usched.c                  |  2 +-
 sys/cpu/x86_64/include/cpumask.h      | 65 ++++++++++++++++++++++++---
 sys/cpu/x86_64/include/types.h        | 22 ---------
 sys/kern/init_sysent.c                |  1 -
 sys/kern/kern_usched.c                |  2 +-
 sys/kern/makesyscalls.sh              |  1 +
 sys/kern/syscalls.master              |  1 -
 sys/platform/pc64/apic/lapic.h        |  8 ++--
 sys/platform/pc64/include/pmap.h      |  3 ++
 sys/platform/vkernel64/include/pmap.h |  3 ++
 sys/platform/vkernel64/x86_64/mp.c    |  3 +-
 sys/sys/cpu_topology.h                |  2 +-
 sys/sys/cpumask.h                     | 60 +++++++++++++++++++++++++
 sys/sys/lwp.h                         |  2 +-
 sys/sys/proc.h                        |  1 +
 sys/sys/sched.h                       | 50 ++-------------------
 sys/sys/sysproto.h                    |  1 +
 sys/sys/thread.h                      |  3 ++
 sys/sys/thread2.h                     | 10 +++--
 sys/sys/usched.h                      |  7 +--
 usr.sbin/powerd/powerd.c              |  2 +-
 23 files changed, 169 insertions(+), 95 deletions(-)
 create mode 100644 sys/sys/cpumask.h

diff --git a/include/pthread_np.h b/include/pthread_np.h
index 28d0ebb117..53fac749d6 100644
--- a/include/pthread_np.h
+++ b/include/pthread_np.h
@@ -31,7 +31,18 @@
 #ifndef _PTHREAD_NP_H_
 #define _PTHREAD_NP_H_
 
-#include <sched.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <sys/cpumask.h>
+#include <sys/_timespec.h>
+#include <time.h>
+
+/* In case <sched.h> has limited visibility. */
+#ifndef __CPU_SET_T_DECLARED
+#define	__CPU_SET_T_DECLARED
+typedef	cpumask_t		cpu_set_t;
+typedef	cpumask_t		cpuset_t;	/* FreeBSD compat */
+#endif
 
 /*
  * Non-POSIX type definitions:
diff --git a/lib/libthread_xu/thread/thr_private.h b/lib/libthread_xu/thread/thr_private.h
index 72e5afa9dc..86edcd88d3 100644
--- a/lib/libthread_xu/thread/thr_private.h
+++ b/lib/libthread_xu/thread/thr_private.h
@@ -45,10 +45,10 @@
 #include <sys/rtprio.h>
 #include <sys/mman.h>
 #include <machine/atomic.h>
-#include <machine/cpumask.h>
 #include <errno.h>
 #include <limits.h>
 #include <signal.h>
+#include <sys/cpumask.h>
 #include <sys/sched.h>
 #include <stdarg.h>
 #include <unistd.h>
diff --git a/sbin/usched/usched.c b/sbin/usched/usched.c
index 213e92145b..df8ed00e1d 100644
--- a/sbin/usched/usched.c
+++ b/sbin/usched/usched.c
@@ -35,7 +35,7 @@
 
 #include <sys/types.h>
 #include <sys/usched.h>
-#include <machine/cpumask.h>
+#include <sys/cpumask.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
diff --git a/sys/cpu/x86_64/include/cpumask.h b/sys/cpu/x86_64/include/cpumask.h
index 5173efec02..2da5abad9d 100644
--- a/sys/cpu/x86_64/include/cpumask.h
+++ b/sys/cpu/x86_64/include/cpumask.h
@@ -35,16 +35,25 @@
 #ifndef _CPU_CPUMASK_H_
 #define	_CPU_CPUMASK_H_
 
-#include <cpu/types.h>
+#include <machine/stdint.h>
 #ifdef _KERNEL
 #include <cpu/atomic.h>
 #endif
 
-#if _CPUMASK_ELEMENTS != 4
-#error "CPUMASK macros incompatible with cpumask_t"
-#endif
+/*
+ * cpumask_t - a mask representing a set of cpus and supporting routines.
+ *
+ * WARNING! It is recommended that this mask NOT be made variably-sized
+ *	    because it affects a huge number of system structures.  However,
+ *	    kernel code (non-module) can be optimized to not operate on the
+ *	    whole mask.
+ */
 
-#define CPUMASK_ELEMENTS	_CPUMASK_ELEMENTS
+typedef struct {
+	__uint64_t	ary[4];
+} __cpumask_t;
+
+#define CPUMASK_ELEMENTS	4
 
 #define CPUMASK_INITIALIZER_ALLONES	{ .ary = { (__uint64_t)-1, \
 					  (__uint64_t)-1, \
@@ -212,6 +221,52 @@
 					(mask).ary[3] ^= -1L;		\
 					} while(0)
 
+#ifndef _KERNEL
+#define	__CPU_SETSIZE		((int)(sizeof(cpumask_t) * 8))
+
+#define	__CPU_COUNT(set)	(					\
+				__builtin_popcountl((set)->ary[0]) +	\
+				__builtin_popcountl((set)->ary[1]) +	\
+				__builtin_popcountl((set)->ary[2]) +	\
+				__builtin_popcountl((set)->ary[3]))
+
+#define	__CPU_CLR(cpu, set)	CPUMASK_NANDBIT(*set, cpu)
+#define	__CPU_EQUAL(set1, set2)	CPUMASK_CMPMASKEQ(*set1, *set2)
+#define	__CPU_ISSET(cpu, set)	CPUMASK_TESTBIT(*set, cpu)
+#define	__CPU_SET(cpu, set)	CPUMASK_ORBIT(*set, cpu)
+#define	__CPU_ZERO(set)		CPUMASK_ASSZERO(*set)
+
+#define	__CPU_AND(dst, set1, set2)					\
+			do {						\
+				if (dst == set1) {			\
+					CPUMASK_ANDMASK(*dst, *set2);	\
+				} else {				\
+					*dst = *set2;			\
+					CPUMASK_ANDMASK(*dst, *set1);	\
+				}					\
+			} while (0)
+
+#define	__CPU_OR(dst, set1, set2)					\
+			do {						\
+				if (dst == set1) {			\
+					CPUMASK_ORMASK(*dst, *set2);	\
+				} else {				\
+					*dst = *set2;			\
+					CPUMASK_ORMASK(*dst, *set1);	\
+				}					\
+			} while (0)
+
+#define	__CPU_XOR(dst, set1, set2)					\
+			do {						\
+				if (dst == set1) {			\
+					CPUMASK_XORMASK(*dst, *set2);	\
+				} else {				\
+					*dst = *set2;			\
+					CPUMASK_XORMASK(*dst, *set1);	\
+				}					\
+			} while (0)
+#endif
+
 #ifdef _KERNEL
 #define ATOMIC_CPUMASK_ORBIT(mask, i)					  \
 			atomic_set_cpumask(&(mask).ary[((i) >> 6) & 3],	  \
diff --git a/sys/cpu/x86_64/include/types.h b/sys/cpu/x86_64/include/types.h
index c29fb77219..c365d02b63 100644
--- a/sys/cpu/x86_64/include/types.h
+++ b/sys/cpu/x86_64/include/types.h
@@ -45,26 +45,4 @@ typedef	__int64_t	vm_ooffset_t;	/* VM object bounded offset */
 typedef __uint64_t	vm_poff_t;	/* physical offset */
 typedef __uint64_t	vm_paddr_t;	/* physical addr (same as vm_poff_t) */
 
-typedef __uint32_t      cpulock_t;      /* count and exclusive lock */
-
-/*
- * cpumask_t - a mask representing a set of cpus and supporting routines.
- *
- * WARNING! It is recommended that this mask NOT be made variably-sized
- *	    because it affects a huge number of system structures.  However,
- *	    kernel code (non-module) can be optimized to not operate on the
- *	    whole mask.
- */
-
-#define _CPUMASK_ELEMENTS	4	/* tested by assembly for #error */
-
-typedef struct {
-	__uint64_t      ary[4];
-} cpumask_t;
-
-#define CPULOCK_EXCLBIT	0		/* exclusive lock bit number */
-#define CPULOCK_EXCL	0x00000001	/* exclusive lock */
-#define CPULOCK_INCR	0x00000002	/* auxillary counter add/sub */
-#define CPULOCK_CNTMASK	0x7FFFFFFE
-
 #endif /* !_CPU_TYPES_H_ */
diff --git a/sys/kern/init_sysent.c b/sys/kern/init_sysent.c
index 97b02ecd7e..8a796061cd 100644
--- a/sys/kern/init_sysent.c
+++ b/sys/kern/init_sysent.c
@@ -9,7 +9,6 @@
 #include <sys/sysent.h>
 #include <sys/sysproto.h>
 #include <sys/statvfs.h>
-#include <machine/cpumask.h>
 
 #define AS(name) ((sizeof(struct name) - sizeof(struct sysmsg)) / sizeof(register_t))
 
diff --git a/sys/kern/kern_usched.c b/sys/kern/kern_usched.c
index 8399d8cf52..1c8dfe0681 100644
--- a/sys/kern/kern_usched.c
+++ b/sys/kern/kern_usched.c
@@ -33,6 +33,7 @@
  *
  */
 
+#include <sys/cpumask.h>
 #include <sys/errno.h>
 #include <sys/globaldata.h>		/* curthread */
 #include <sys/proc.h>
@@ -41,7 +42,6 @@
 #include <sys/systm.h>			/* strcmp() */
 #include <sys/usched.h>
 
-#include <machine/cpumask.h>
 #include <machine/smp.h>
 
 static TAILQ_HEAD(, usched) usched_list = TAILQ_HEAD_INITIALIZER(usched_list);
diff --git a/sys/kern/makesyscalls.sh b/sys/kern/makesyscalls.sh
index debe226ae8..1885dcf0d9 100644
--- a/sys/kern/makesyscalls.sh
+++ b/sys/kern/makesyscalls.sh
@@ -87,6 +87,7 @@ s/\$//g
 		printf "#include <sys/select.h>\n" > sysarg
 		printf "#include <sys/signal.h>\n" > sysarg
 		printf "#include <sys/acl.h>\n" > sysarg
+		printf "#include <sys/cpumask.h>\n" > sysarg
 		printf "#include <sys/mqueue.h>\n" > sysarg
 		printf "#include <sys/msgport.h>\n" > sysarg
 		printf "#include <sys/sysmsg.h>\n" > sysarg
diff --git a/sys/kern/syscalls.master b/sys/kern/syscalls.master
index 28a401c77b..80549b9f1b 100644
--- a/sys/kern/syscalls.master
+++ b/sys/kern/syscalls.master
@@ -32,7 +32,6 @@
 #include <sys/sysent.h>
 #include <sys/sysproto.h>
 #include <sys/statvfs.h>
-#include <machine/cpumask.h>
 
 ; Reserved/unimplemented system calls in the range 0-150 inclusive
 ; are reserved for use in future Berkeley releases.
diff --git a/sys/platform/pc64/apic/lapic.h b/sys/platform/pc64/apic/lapic.h
index d6a5afd5e4..e0d0f3e183 100644
--- a/sys/platform/pc64/apic/lapic.h
+++ b/sys/platform/pc64/apic/lapic.h
@@ -80,15 +80,15 @@ void	lapic_x2apic_enter(boolean_t);
 #include <machine/smp.h>
 #endif
 
+#ifndef _SYS_CPUMASK_H_
+#include <sys/cpumask.h>
+#endif
+
 void	selected_apic_ipi(cpumask_t, int, int);
 
 /*
  * Send an IPI INTerrupt containing 'vector' to all CPUs EXCEPT myself
  */
-#ifndef _CPU_CPUMASK_H_
-#include <machine/cpumask.h>
-#endif
-
 static __inline int
 all_but_self_ipi(int vector)
 {
diff --git a/sys/platform/pc64/include/pmap.h b/sys/platform/pc64/include/pmap.h
index 0a0459dace..99b5174add 100644
--- a/sys/platform/pc64/include/pmap.h
+++ b/sys/platform/pc64/include/pmap.h
@@ -153,6 +153,9 @@
 #ifndef _SYS_TYPES_H_
 #include <sys/types.h>
 #endif
+#ifndef _SYS_CPUMASK_H_
+#include <sys/cpumask.h>
+#endif
 #ifndef _SYS_QUEUE_H_
 #include <sys/queue.h>
 #endif
diff --git a/sys/platform/vkernel64/include/pmap.h b/sys/platform/vkernel64/include/pmap.h
index 9ebd2bb4f2..c42ddc4176 100644
--- a/sys/platform/vkernel64/include/pmap.h
+++ b/sys/platform/vkernel64/include/pmap.h
@@ -95,6 +95,9 @@
 #ifndef _SYS_TYPES_H_
 #include <sys/types.h>
 #endif
+#ifndef _SYS_CPUMASK_H_
+#include <sys/cpumask.h>
+#endif
 #ifndef _SYS_QUEUE_H_
 #include <sys/queue.h>
 #endif
diff --git a/sys/platform/vkernel64/x86_64/mp.c b/sys/platform/vkernel64/x86_64/mp.c
index 8377d7a577..4845131791 100644
--- a/sys/platform/vkernel64/x86_64/mp.c
+++ b/sys/platform/vkernel64/x86_64/mp.c
@@ -32,7 +32,7 @@
  * SUCH DAMAGE.
  */
 
-
+#include <sys/cpumask.h>
 #include <sys/interrupt.h>
 #include <sys/kernel.h>
 #include <sys/memrange.h>
@@ -50,7 +50,6 @@
 
 #include <machine/cpu.h>
 #include <machine/cpufunc.h>
-#include <machine/cpumask.h>
 #include <machine/globaldata.h>
 #include <machine/md_var.h>
 #include <machine/pmap.h>
diff --git a/sys/sys/cpu_topology.h b/sys/sys/cpu_topology.h
index 3db45c0af4..a0b441d5cf 100644
--- a/sys/sys/cpu_topology.h
+++ b/sys/sys/cpu_topology.h
@@ -3,7 +3,7 @@
 
 #if defined(_KERNEL) || defined(_KERNEL_STRUCTURES)
 
-#include <machine/cpumask.h>
+#include <sys/cpumask.h>
 
 /* CPU TOPOLOGY DATA AND FUNCTIONS */
 struct cpu_node {
diff --git a/sys/sys/cpumask.h b/sys/sys/cpumask.h
new file mode 100644
index 0000000000..4d11fd218b
--- /dev/null
+++ b/sys/sys/cpumask.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2019 The DragonFly Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _SYS_CPUMASK_H_
+#define _SYS_CPUMASK_H_
+
+#include <machine/cpumask.h>
+#include <machine/stdint.h>
+
+typedef	__cpumask_t	cpumask_t;
+
+#ifndef _KERNEL
+#define	CPU_SETSIZE		((int)(sizeof(cpumask_t) * 8))
+#define	CPU_ZERO(set)			__CPU_ZERO(set)
+#define	CPU_SET(cpu, set)		__CPU_SET(cpu, set)
+#define	CPU_CLR(cpu, set)		__CPU_CLR(cpu, set)
+#define	CPU_ISSET(cpu, set)		__CPU_ISSET(cpu, set)
+#define	CPU_COUNT(set)			__CPU_COUNT(set)
+#define	CPU_AND(dst, set1, set2)	__CPU_AND(dst, set1, set2)
+#define	CPU_OR(dst, set1, set2)		__CPU_OR(dst, set1, set2)
+#define	CPU_XOR(dst, set1, set2)	__CPU_XOR(dst, set1, set2)
+#define	CPU_EQUAL(set1, set2)		__CPU_EQUAL(set1, set2)
+#endif
+
+/*
+ * It is convenient to place this type here due to its proximity to the
+ * cpumask_t use cases in structs.  Keep public for easier access to
+ * struct proc for now.
+ */
+typedef	__uint32_t	cpulock_t;	/* count and exclusive lock */
+
+#define	CPULOCK_EXCLBIT	0		/* exclusive lock bit number */
+#define	CPULOCK_EXCL	0x00000001	/* exclusive lock */
+#define	CPULOCK_INCR	0x00000002	/* auxillary counter add/sub */
+#define	CPULOCK_CNTMASK	0x7FFFFFFE
+
+#endif /* !_SYS_CPUMASK_H_ */
diff --git a/sys/sys/lwp.h b/sys/sys/lwp.h
index 80b7ee7e2f..5694acdfda 100644
--- a/sys/sys/lwp.h
+++ b/sys/sys/lwp.h
@@ -16,7 +16,7 @@ struct lwp_params {
 
 #if !defined(_KERNEL) || defined(_KERNEL_VIRTUAL)
 
-#include <machine/cpumask.h>
+#include <sys/cpumask.h>
 
 __BEGIN_DECLS
 
diff --git a/sys/sys/proc.h b/sys/sys/proc.h
index 69e550df72..7de4905a7b 100644
--- a/sys/sys/proc.h
+++ b/sys/sys/proc.h
@@ -41,6 +41,7 @@
 #else
 
 #include <sys/callout.h>		/* For struct callout. */
+#include <sys/cpumask.h>
 #include <sys/filedesc.h>
 #include <sys/queue.h>
 #include <sys/tree.h>
diff --git a/sys/sys/sched.h b/sys/sys/sched.h
index 3f3e3b901f..54602901e2 100644
--- a/sys/sys/sched.h
+++ b/sys/sys/sched.h
@@ -56,55 +56,13 @@ struct sched_param
 #include <time.h>		/* Per P1003.4 */
 
 #if __BSD_VISIBLE
-#include <machine/cpumask.h>
+#include <sys/cpumask.h>
 
+#ifndef __CPU_SET_T_DECLARED
+#define	__CPU_SET_T_DECLARED
 typedef	cpumask_t		cpu_set_t;
 typedef	cpumask_t		cpuset_t;	/* FreeBSD compat */
-
-#define	CPU_SETSIZE		((int)(sizeof(cpumask_t) * 8))
-
-#define	CPU_ZERO(set)		CPUMASK_ASSZERO(*set)
-#define	CPU_SET(cpu, set)	CPUMASK_ORBIT(*set, cpu)
-#define	CPU_CLR(cpu, set)	CPUMASK_NANDBIT(*set, cpu)
-#define	CPU_ISSET(cpu, set)	CPUMASK_TESTBIT(*set, cpu)
-
-#define	CPU_COUNT(set)				\
-	(__builtin_popcountl((set)->ary[0]) +	\
-	 __builtin_popcountl((set)->ary[1]) +	\
-	 __builtin_popcountl((set)->ary[2]) +	\
-	 __builtin_popcountl((set)->ary[3]))
-
-#define	CPU_AND(dst, set1, set2)		\
-do {						\
-	if (dst == set1) {			\
-		CPUMASK_ANDMASK(*dst, *set2);	\
-	} else {				\
-		*dst = *set2;			\
-		CPUMASK_ANDMASK(*dst, *set1);	\
-	}					\
-} while (0)
-
-#define	CPU_OR(dst, set1, set2)			\
-do {						\
-	if (dst == set1) {			\
-		CPUMASK_ORMASK(*dst, *set2);	\
-	} else {				\
-		*dst = *set2;			\
-		CPUMASK_ORMASK(*dst, *set1);	\
-	}					\
-} while (0)
-
-#define	CPU_XOR(dst, set1, set2)		\
-do {						\
-	if (dst == set1) {			\
-		CPUMASK_XORMASK(*dst, *set2);	\
-	} else {				\
-		*dst = *set2;			\
-		CPUMASK_XORMASK(*dst, *set1);	\
-	}					\
-} while (0)
-
-#define	CPU_EQUAL(set1, set2)	CPUMASK_CMPMASKEQ(*set1, *set2)
+#endif
 #endif /* __BSD_VISIBLE */
 
 __BEGIN_DECLS
diff --git a/sys/sys/sysproto.h b/sys/sys/sysproto.h
index 01e8ff65cd..5d2ccac780 100644
--- a/sys/sys/sysproto.h
+++ b/sys/sys/sysproto.h
@@ -11,6 +11,7 @@
 #include <sys/select.h>
 #include <sys/signal.h>
 #include <sys/acl.h>
+#include <sys/cpumask.h>
 #include <sys/mqueue.h>
 #include <sys/msgport.h>
 #include <sys/sysmsg.h>
diff --git a/sys/sys/thread.h b/sys/sys/thread.h
index 3a99d0c64b..7e12aba66b 100644
--- a/sys/sys/thread.h
+++ b/sys/sys/thread.h
@@ -23,6 +23,9 @@
 #ifndef _SYS_TIME_H_
 #include <sys/time.h>   	/* struct timeval */
 #endif
+#ifndef _SYS_CPUMASK_H_
+#include <sys/cpumask.h>	/* cpumask_t */
+#endif
 #ifndef _SYS_LOCK_H
 #include <sys/lock.h>
 #endif
diff --git a/sys/sys/thread2.h b/sys/sys/thread2.h
index abef300fbc..7a7db68ff6 100644
--- a/sys/sys/thread2.h
+++ b/sys/sys/thread2.h
@@ -1,7 +1,7 @@
 /*
  * SYS/THREAD2.H
  *
- * Implements inline procedure support for the LWKT subsystem. 
+ * Implements inline procedure support for the LWKT subsystem.
  *
  * Generally speaking these routines only operate on threads associated
  * with the current cpu.  For example, a higher priority thread pending
@@ -25,8 +25,10 @@
 #ifndef _SYS_GLOBALDATA_H_
 #include <sys/globaldata.h>
 #endif
+#ifndef _SYS_CPUMASK_H_
+#include <sys/cpumask.h>
+#endif
 #include <machine/cpufunc.h>
-#include <machine/cpumask.h>
 
 /*
  * Don't let GCC reorder critical section count adjustments, because it
@@ -303,7 +305,7 @@ lwkt_cpusync_init(lwkt_cpusync_t cs, cpumask_t mask,
 /*
  * IPIQ messaging wrappers.  IPIQ remote functions are passed three arguments:
  * a void * pointer, an integer, and a pointer to the trap frame (or NULL if
- * the trap frame is not known).  However, we wish to provide opaque 
+ * the trap frame is not known).  However, we wish to provide opaque
  * interfaces for simpler callbacks... the basic IPI messaging function as
  * used by the kernel takes a single argument.
  */
@@ -338,7 +340,7 @@ lwkt_send_ipiq_passive(globaldata_t target, ipifunc1_t func, void *arg)
 }
 
 static __inline int
-lwkt_send_ipiq2_passive(globaldata_t target, ipifunc2_t func, 
+lwkt_send_ipiq2_passive(globaldata_t target, ipifunc2_t func,
 		       void *arg1, int arg2)
 {
     return(lwkt_send_ipiq3_passive(target, (ipifunc3_t)func, arg1, arg2));
diff --git a/sys/sys/usched.h b/sys/sys/usched.h
index 41d30ca8ae..296d01db46 100644
--- a/sys/sys/usched.h
+++ b/sys/sys/usched.h
@@ -2,8 +2,6 @@
  * SYS/USCHED.H
  *
  *	Userland scheduler API
- * 
- * $DragonFly: src/sys/sys/usched.h,v 1.15 2008/04/21 15:24:47 dillon Exp $
  */
 
 #ifndef _SYS_USCHED_H_
@@ -14,6 +12,9 @@
 #ifndef _SYS_TYPES_H_
 #include <sys/types.h>
 #endif
+#ifndef _SYS_CPUMASK_H_
+#include <sys/cpumask.h>
+#endif
 #ifndef _SYS_QUEUE_H_
 #include <sys/queue.h>
 #endif
@@ -49,7 +50,7 @@ struct usched {
 
 union usched_data {
     /*
-     * BSD4 scheduler. 
+     * BSD4 scheduler.
      */
     struct {
 	short	priority;	/* lower is better */
diff --git a/usr.sbin/powerd/powerd.c b/usr.sbin/powerd/powerd.c
index 0975d73972..fa64a8359f 100644
--- a/usr.sbin/powerd/powerd.c
+++ b/usr.sbin/powerd/powerd.c
@@ -49,8 +49,8 @@
 #include <sys/soundcard.h>
 #include <sys/sensors.h>
 #include <sys/time.h>
+#include <sys/cpumask.h>
 #include <machine/cpufunc.h>
-#include <machine/cpumask.h>
 #include <err.h>
 #include <signal.h>
 #include <stdio.h>
-- 
2.23.0

