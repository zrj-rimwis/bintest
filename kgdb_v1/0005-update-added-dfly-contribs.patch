From bbf67943c523ca6b50b00928637f77b871eada3e Mon Sep 17 00:00:00 2001
From: zrj <rimvydas.jasinskas@gmail.com>
Date: Wed, 31 Jul 2019 14:05:26 +0300
Subject: [PATCH 05/10] update added dfly contribs

---
 contrib/gdb-7/gdb/dfly-nat.c     | 166 +++++++++++++++++++++++
 contrib/gdb-7/gdb/dfly-nat.h     |  27 ++++
 contrib/gdb-7/gdb/i386dfly-nat.c | 223 -------------------------------
 3 files changed, 193 insertions(+), 223 deletions(-)
 create mode 100644 contrib/gdb-7/gdb/dfly-nat.c
 create mode 100644 contrib/gdb-7/gdb/dfly-nat.h
 delete mode 100644 contrib/gdb-7/gdb/i386dfly-nat.c

diff --git a/contrib/gdb-7/gdb/dfly-nat.c b/contrib/gdb-7/gdb/dfly-nat.c
new file mode 100644
index 0000000000..f64b6e29ce
--- /dev/null
+++ b/contrib/gdb-7/gdb/dfly-nat.c
@@ -0,0 +1,166 @@
+/* Native-dependent code for DragonFly.
+
+   Copyright (C) 2002-2016 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "gdbcore.h"
+#include "inferior.h"
+#include "regcache.h"
+#include "regset.h"
+#include "gdbcmd.h"
+#include "gdbthread.h"
+#include "gdb_wait.h"
+#include <sys/types.h>
+#include <sys/procfs.h>
+#include <sys/ptrace.h>
+#include <sys/sysctl.h>
+#ifdef HAVE_KINFO_GETVMMAP
+#include <sys/user.h>
+#include <libutil.h>
+#endif
+
+#include "elf-bfd.h"
+#include "dfly-nat.h"
+
+/* Return the name of a file that can be opened to get the symbols for
+   the child process identified by PID.  */
+
+static char *
+dfly_pid_to_exec_file (struct target_ops *self, int pid)
+{
+  ssize_t len;
+  static char buf[PATH_MAX];
+  char name[PATH_MAX];
+
+#ifdef KERN_PROC_PATHNAME
+  size_t buflen;
+  int mib[4];
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PROC;
+  mib[2] = KERN_PROC_PATHNAME;
+  mib[3] = pid;
+  buflen = sizeof buf;
+  if (sysctl (mib, 4, buf, &buflen, NULL, 0) == 0)
+    return buf;
+#endif
+
+  xsnprintf (name, PATH_MAX, "/proc/%d/exe", pid);
+  len = readlink (name, buf, PATH_MAX - 1);
+  if (len != -1)
+    {
+      buf[len] = '\0';
+      return buf;
+    }
+
+  return NULL;
+}
+
+static int
+dfly_read_mapping (FILE *mapfile, unsigned long *start, unsigned long *end,
+		   char *protection)
+{
+  /* FreeBSD 5.1-RELEASE uses a 256-byte buffer.  */
+  char buf[256];
+  int resident, privateresident;
+  unsigned long obj;
+  int ret = EOF;
+
+  /* As of FreeBSD 5.0-RELEASE, the layout is described in
+     /usr/src/sys/fs/procfs/procfs_map.c.  Somewhere in 5.1-CURRENT a
+     new column was added to the procfs map.  Therefore we can't use
+     fscanf since we need to support older releases too.  */
+  if (fgets (buf, sizeof buf, mapfile) != NULL)
+    ret = sscanf (buf, "%lx %lx %d %d %lx %s", start, end,
+		  &resident, &privateresident, &obj, protection);
+
+  return (ret != 0 && ret != EOF);
+}
+
+/* Iterate over all the memory regions in the current inferior,
+   calling FUNC for each memory region.  OBFD is passed as the last
+   argument to FUNC.  */
+
+static int
+dfly_find_memory_regions (struct target_ops *self,
+			  find_memory_region_ftype func, void *obfd)
+{
+  pid_t pid = ptid_get_pid (inferior_ptid);
+  char *mapfilename;
+  FILE *mapfile;
+  unsigned long start, end, size;
+  char protection[4];
+  int read, write, exec;
+  struct cleanup *cleanup;
+
+  mapfilename = xstrprintf ("/proc/%ld/map", (long) pid);
+  cleanup = make_cleanup (xfree, mapfilename);
+  mapfile = fopen (mapfilename, "r");
+  if (mapfile == NULL)
+    error (_("Couldn't open %s."), mapfilename);
+  make_cleanup_fclose (mapfile);
+
+  if (info_verbose)
+    fprintf_filtered (gdb_stdout, 
+		      "Reading memory regions from %s\n", mapfilename);
+
+  /* Now iterate until end-of-file.  */
+  while (dfly_read_mapping (mapfile, &start, &end, &protection[0]))
+    {
+      size = end - start;
+
+      read = (strchr (protection, 'r') != 0);
+      write = (strchr (protection, 'w') != 0);
+      exec = (strchr (protection, 'x') != 0);
+
+      if (info_verbose)
+	{
+	  fprintf_filtered (gdb_stdout, 
+			    "Save segment, %ld bytes at %s (%c%c%c)\n",
+			    size, paddress (target_gdbarch (), start),
+			    read ? 'r' : '-',
+			    write ? 'w' : '-',
+			    exec ? 'x' : '-');
+	}
+
+      /* Invoke the callback function to create the corefile segment.
+	 Pass MODIFIED as true, we do not know the real modification state.  */
+      func (start, size, read, write, exec, 1, obfd);
+    }
+
+  do_cleanups (cleanup);
+  return 0;
+}
+
+void
+dfly_nat_add_target (struct target_ops *t)
+{
+  t->to_pid_to_exec_file = dfly_pid_to_exec_file;
+  t->to_find_memory_regions = dfly_find_memory_regions;
+  /* XXX: thread vfork support */
+  add_target (t);
+}
+
+/* Provide a prototype to silence -Wmissing-prototypes.  */
+extern initialize_file_ftype _initialize_dfly_nat;
+
+void
+_initialize_dfly_nat (void)
+{
+/* XXX: todo add_setshow_boolean_cmd() */
+}
diff --git a/contrib/gdb-7/gdb/dfly-nat.h b/contrib/gdb-7/gdb/dfly-nat.h
new file mode 100644
index 0000000000..9212cea2b5
--- /dev/null
+++ b/contrib/gdb-7/gdb/dfly-nat.h
@@ -0,0 +1,27 @@
+/* Native-dependent code for DragonFly.
+
+   Copyright (C) 2004-2015 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef DFLY_NAT_H
+#define DFLY_NAT_H
+
+/* Register the customized DragonFly target.  This should be used
+   instead of calling add_target directly.  */
+extern void dfly_nat_add_target (struct target_ops *);
+
+#endif /* dfly-nat.h */
diff --git a/contrib/gdb-7/gdb/i386dfly-nat.c b/contrib/gdb-7/gdb/i386dfly-nat.c
deleted file mode 100644
index cd12d1d231..0000000000
--- a/contrib/gdb-7/gdb/i386dfly-nat.c
+++ /dev/null
@@ -1,223 +0,0 @@
-/* Native-dependent code for DragonFly/i386.
-
-   Copyright (C) 2001-2013 Free Software Foundation, Inc.
-
-   This file is part of GDB.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "defs.h"
-#include "inferior.h"
-#include "regcache.h"
-#include "target.h"
-#include "gregset.h"
-
-#include <sys/types.h>
-#include <sys/procfs.h>
-#include <sys/ptrace.h>
-#include <sys/sysctl.h>
-
-#include "fbsd-nat.h"
-#include "i386-tdep.h"
-#include "i386-nat.h"
-#include "i386bsd-nat.h"
-
-#ifdef DFLY_PCB_SUPPLY
-/* Resume execution of the inferior process.  If STEP is nonzero,
-   single-step it.  If SIGNAL is nonzero, give it that signal.  */
-
-static void
-i386dfly_resume (struct target_ops *ops,
-		 ptid_t ptid, int step, enum gdb_signal signal)
-{
-  pid_t pid = ptid_get_pid (ptid);
-  int request = PT_STEP;
-
-  if (pid == -1)
-    /* Resume all threads.  This only gets used in the non-threaded
-       case, where "resume all threads" and "resume inferior_ptid" are
-       the same.  */
-    pid = ptid_get_pid (inferior_ptid);
-
-  if (!step)
-    {
-      struct regcache *regcache = get_current_regcache ();
-      ULONGEST eflags;
-
-      /* Workaround for a bug in FreeBSD.  Make sure that the trace
- 	 flag is off when doing a continue.  There is a code path
- 	 through the kernel which leaves the flag set when it should
- 	 have been cleared.  If a process has a signal pending (such
- 	 as SIGALRM) and we do a PT_STEP, the process never really has
- 	 a chance to run because the kernel needs to notify the
- 	 debugger that a signal is being sent.  Therefore, the process
- 	 never goes through the kernel's trap() function which would
- 	 normally clear it.  */
-
-      regcache_cooked_read_unsigned (regcache, I386_EFLAGS_REGNUM,
-				     &eflags);
-      if (eflags & 0x0100)
-	regcache_cooked_write_unsigned (regcache, I386_EFLAGS_REGNUM,
-					eflags & ~0x0100);
-
-      request = PT_CONTINUE;
-    }
-
-  /* An addres of (caddr_t) 1 tells ptrace to continue from where it
-     was.  (If GDB wanted it to start some other way, we have already
-     written a new PC value to the child.)  */
-  if (ptrace (request, pid, (caddr_t) 1,
-	      gdb_signal_to_host (signal)) == -1)
-    perror_with_name (("ptrace"));
-}
-
-
-/* Transfering the registers between GDB, inferiors and core files.  */
-
-/* Fill GDB's register array with the general-purpose register values
-   in *GREGSETP.  */
-
-void
-supply_gregset (struct regcache *regcache, const gregset_t *gregsetp)
-{
-  i386bsd_supply_gregset (regcache, gregsetp);
-}
-
-/* Fill register REGNUM (if it is a general-purpose register) in
-   *GREGSETPS with the value in GDB's register array.  If REGNUM is -1,
-   do this for all registers.  */
-
-void
-fill_gregset (const struct regcache *regcache, gdb_gregset_t *gregsetp, int regnum)
-{
-  i386bsd_collect_gregset (regcache, gregsetp, regnum);
-}
-
-#include "i387-tdep.h"
-
-/* Fill GDB's register array with the floating-point register values
-   in *FPREGSETP.  */
-
-void
-supply_fpregset (struct regcache *regcache, const fpregset_t *fpregsetp)
-{
-  i387_supply_fsave (regcache, -1, fpregsetp);
-}
-
-/* Fill register REGNUM (if it is a floating-point register) in
-   *FPREGSETP with the value in GDB's register array.  If REGNUM is -1,
-   do this for all registers.  */
-
-void
-fill_fpregset (const struct regcache *regcache, gdb_fpregset_t *fpregsetp, int regnum)
-{
-  i387_collect_fsave (regcache, regnum, fpregsetp);
-}
-
-
-/* Support for debugging kernel virtual memory images.  */
-
-#include <sys/types.h>
-#include <machine/pcb.h>
-
-#include "bsd-kvm.h"
-
-static int
-i386dfly_supply_pcb (struct regcache *regcache, struct pcb *pcb)
-{
-  /* The following is true for FreeBSD 4.7:
-
-     The pcb contains %eip, %ebx, %esp, %ebp, %esi, %edi and %gs.
-     This accounts for all callee-saved registers specified by the
-     psABI and then some.  Here %esp contains the stack pointer at the
-     point just after the call to cpu_switch().  From this information
-     we reconstruct the register state as it would look when we just
-     returned from cpu_switch().  */
-
-  /* The stack pointer shouldn't be zero.  */
-  if (pcb->pcb_esp == 0)
-    return 0;
-
-  pcb->pcb_esp += 4;
-  regcache_raw_supply (regcache, I386_EDI_REGNUM, &pcb->pcb_edi);
-  regcache_raw_supply (regcache, I386_ESI_REGNUM, &pcb->pcb_esi);
-  regcache_raw_supply (regcache, I386_EBP_REGNUM, &pcb->pcb_ebp);
-  regcache_raw_supply (regcache, I386_ESP_REGNUM, &pcb->pcb_esp);
-  regcache_raw_supply (regcache, I386_EBX_REGNUM, &pcb->pcb_ebx);
-  regcache_raw_supply (regcache, I386_EIP_REGNUM, &pcb->pcb_eip);
-  regcache_raw_supply (regcache, I386_GS_REGNUM, &pcb->pcb_gs);
-
-  return 1;
-}
-#endif /* DFLY_PCB_SUPPLY */
-
-
-/* Prevent warning from -Wmissing-prototypes.  */
-void _initialize_i386dfly_nat (void);
-
-void
-_initialize_i386dfly_nat (void)
-{
-  struct target_ops *t;
-
-  /* Add some extra features to the common *BSD/i386 target.  */
-  t = i386bsd_target ();
-
-#ifdef HAVE_PT_GETDBREGS
-
-  i386_use_watchpoints (t);
-
-  i386_dr_low.set_control = i386bsd_dr_set_control;
-  i386_dr_low.set_addr = i386bsd_dr_set_addr;
-  i386_dr_low.get_addr = i386bsd_dr_get_addr;
-  i386_dr_low.get_status = i386bsd_dr_get_status;
-  i386_dr_low.get_control = i386bsd_dr_get_control;
-  i386_set_debug_register_length (4);
-
-#endif /* HAVE_PT_GETDBREGS */
-
-
-  t->to_pid_to_exec_file = fbsd_pid_to_exec_file;
-  t->to_find_memory_regions = fbsd_find_memory_regions;
-  t->to_make_corefile_notes = fbsd_make_corefile_notes;
-  add_target (t);
-
-#ifdef DFLY_PCB_SUPPLY
-  /* Support debugging kernel virtual memory images.  */
-  bsd_kvm_add_target (i386dfly_supply_pcb);
-#endif
-
-  /* DragonFly provides a kern.ps_strings sysctl that we can use to
-     locate the sigtramp.  That way we can still recognize a sigtramp
-     if its location is changed in a new kernel.  Of course this is
-     still based on the assumption that the sigtramp is placed
-     directly under the location where the program arguments and
-     environment can be found.  */
-#ifdef KERN_PS_STRINGS
-  {
-    int mib[2];
-    u_long ps_strings;
-    size_t len;
-
-    mib[0] = CTL_KERN;
-    mib[1] = KERN_PS_STRINGS;
-    len = sizeof (ps_strings);
-    if (sysctl (mib, 2, &ps_strings, &len, NULL, 0) == 0)
-      {
-	i386dfly_sigtramp_start_addr = ps_strings - 128;
-	i386dfly_sigtramp_end_addr = ps_strings;
-      }
-  }
-#endif
-}
-- 
2.22.0

