From bc11605840f2a578c3f04fc80a6f428f26939c42 Mon Sep 17 00:00:00 2001
From: zrj <rimvydas.jasinskas@gmail.com>
Date: Wed, 31 Jul 2019 14:15:35 +0300
Subject: [PATCH 10/10] add reference freebsd base gdb sources

there are few missing things in dfly implementation like signal trampolines etc
might be worth adding up
---
 contrib/gdb-7/gdb/fbsd_ref/amd64fbsd-nat.c  |  291 +++++
 contrib/gdb-7/gdb/fbsd_ref/amd64fbsd-tdep.c |  319 ++++++
 contrib/gdb-7/gdb/fbsd_ref/fbsd-nat.c       | 1126 +++++++++++++++++++
 contrib/gdb-7/gdb/fbsd_ref/fbsd-nat.h       |   27 +
 contrib/gdb-7/gdb/fbsd_ref/fbsd-tdep.c      |  350 ++++++
 contrib/gdb-7/gdb/fbsd_ref/fbsd-tdep.h      |   25 +
 contrib/gdb-7/gdb/fbsd_ref/i386fbsd-nat.c   |  196 ++++
 contrib/gdb-7/gdb/fbsd_ref/i386fbsd-tdep.c  |  498 ++++++++
 contrib/gdb-7/gdb/fbsd_ref/i386fbsd-tdep.h  |   31 +
 9 files changed, 2863 insertions(+)
 create mode 100644 contrib/gdb-7/gdb/fbsd_ref/amd64fbsd-nat.c
 create mode 100644 contrib/gdb-7/gdb/fbsd_ref/amd64fbsd-tdep.c
 create mode 100644 contrib/gdb-7/gdb/fbsd_ref/fbsd-nat.c
 create mode 100644 contrib/gdb-7/gdb/fbsd_ref/fbsd-nat.h
 create mode 100644 contrib/gdb-7/gdb/fbsd_ref/fbsd-tdep.c
 create mode 100644 contrib/gdb-7/gdb/fbsd_ref/fbsd-tdep.h
 create mode 100644 contrib/gdb-7/gdb/fbsd_ref/i386fbsd-nat.c
 create mode 100644 contrib/gdb-7/gdb/fbsd_ref/i386fbsd-tdep.c
 create mode 100644 contrib/gdb-7/gdb/fbsd_ref/i386fbsd-tdep.h

diff --git a/contrib/gdb-7/gdb/fbsd_ref/amd64fbsd-nat.c b/contrib/gdb-7/gdb/fbsd_ref/amd64fbsd-nat.c
new file mode 100644
index 0000000000..96788b6473
--- /dev/null
+++ b/contrib/gdb-7/gdb/fbsd_ref/amd64fbsd-nat.c
@@ -0,0 +1,291 @@
+/* Native-dependent code for FreeBSD/amd64.
+
+   Copyright (C) 2003-2017 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "inferior.h"
+#include "regcache.h"
+#include "target.h"
+
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/ptrace.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <machine/reg.h>
+
+#include "fbsd-nat.h"
+#include "amd64-tdep.h"
+#include "amd64-nat.h"
+#include "x86bsd-nat.h"
+#include "x86-nat.h"
+
+
+/* Offset in `struct reg' where MEMBER is stored.  */
+#define REG_OFFSET(member) offsetof (struct reg, member)
+
+/* At amd64fbsd64_r_reg_offset[REGNUM] you'll find the offset in
+   `struct reg' location where the GDB register REGNUM is stored.
+   Unsupported registers are marked with `-1'.  */
+static int amd64fbsd64_r_reg_offset[] =
+{
+  REG_OFFSET (r_rax),
+  REG_OFFSET (r_rbx),
+  REG_OFFSET (r_rcx),
+  REG_OFFSET (r_rdx),
+  REG_OFFSET (r_rsi),
+  REG_OFFSET (r_rdi),
+  REG_OFFSET (r_rbp),
+  REG_OFFSET (r_rsp),
+  REG_OFFSET (r_r8),
+  REG_OFFSET (r_r9),
+  REG_OFFSET (r_r10),
+  REG_OFFSET (r_r11),
+  REG_OFFSET (r_r12),
+  REG_OFFSET (r_r13),
+  REG_OFFSET (r_r14),
+  REG_OFFSET (r_r15),
+  REG_OFFSET (r_rip),
+  REG_OFFSET (r_rflags),
+  REG_OFFSET (r_cs),
+  REG_OFFSET (r_ss),
+  -1,
+  -1,
+  -1,
+  -1
+};
+
+
+/* Mapping between the general-purpose registers in FreeBSD/amd64
+   `struct reg' format and GDB's register cache layout for
+   FreeBSD/i386.
+
+   Note that most FreeBSD/amd64 registers are 64-bit, while the
+   FreeBSD/i386 registers are all 32-bit, but since we're
+   little-endian we get away with that.  */
+
+/* From <machine/reg.h>.  */
+static int amd64fbsd32_r_reg_offset[I386_NUM_GREGS] =
+{
+  14 * 8, 13 * 8,		/* %eax, %ecx */
+  12 * 8, 11 * 8,		/* %edx, %ebx */
+  20 * 8, 10 * 8,		/* %esp, %ebp */
+  9 * 8, 8 * 8,			/* %esi, %edi */
+  17 * 8, 19 * 8,		/* %eip, %eflags */
+  18 * 8, 21 * 8,		/* %cs, %ss */
+  -1, -1, -1, -1		/* %ds, %es, %fs, %gs */
+};
+
+
+/* Support for debugging kernel virtual memory images.  */
+
+#include <machine/pcb.h>
+#include <osreldate.h>
+
+#include "bsd-kvm.h"
+
+static int
+amd64fbsd_supply_pcb (struct regcache *regcache, struct pcb *pcb)
+{
+  /* The following is true for FreeBSD 5.2:
+
+     The pcb contains %rip, %rbx, %rsp, %rbp, %r12, %r13, %r14, %r15,
+     %ds, %es, %fs and %gs.  This accounts for all callee-saved
+     registers specified by the psABI and then some.  Here %esp
+     contains the stack pointer at the point just after the call to
+     cpu_switch().  From this information we reconstruct the register
+     state as it would like when we just returned from cpu_switch().  */
+
+  /* The stack pointer shouldn't be zero.  */
+  if (pcb->pcb_rsp == 0)
+    return 0;
+
+  pcb->pcb_rsp += 8;
+  regcache_raw_supply (regcache, AMD64_RIP_REGNUM, &pcb->pcb_rip);
+  regcache_raw_supply (regcache, AMD64_RBX_REGNUM, &pcb->pcb_rbx);
+  regcache_raw_supply (regcache, AMD64_RSP_REGNUM, &pcb->pcb_rsp);
+  regcache_raw_supply (regcache, AMD64_RBP_REGNUM, &pcb->pcb_rbp);
+  regcache_raw_supply (regcache, 12, &pcb->pcb_r12);
+  regcache_raw_supply (regcache, 13, &pcb->pcb_r13);
+  regcache_raw_supply (regcache, 14, &pcb->pcb_r14);
+  regcache_raw_supply (regcache, 15, &pcb->pcb_r15);
+#if (__FreeBSD_version < 800075) && (__FreeBSD_kernel_version < 800075)
+  /* struct pcb provides the pcb_ds/pcb_es/pcb_fs/pcb_gs fields only
+     up until __FreeBSD_version 800074: The removal of these fields
+     occurred on 2009-04-01 while the __FreeBSD_version number was
+     bumped to 800075 on 2009-04-06.  So 800075 is the closest version
+     number where we should not try to access these fields.  */
+  regcache_raw_supply (regcache, AMD64_DS_REGNUM, &pcb->pcb_ds);
+  regcache_raw_supply (regcache, AMD64_ES_REGNUM, &pcb->pcb_es);
+  regcache_raw_supply (regcache, AMD64_FS_REGNUM, &pcb->pcb_fs);
+  regcache_raw_supply (regcache, AMD64_GS_REGNUM, &pcb->pcb_gs);
+#endif
+
+  return 1;
+}
+
+
+/* Implement the to_read_description method.  */
+
+static const struct target_desc *
+amd64fbsd_read_description (struct target_ops *ops)
+{
+#ifdef PT_GETXSTATE_INFO
+  static int xsave_probed;
+  static uint64_t xcr0;
+#endif
+  struct reg regs;
+  int is64;
+
+  if (ptrace (PT_GETREGS, ptid_get_pid (inferior_ptid),
+	      (PTRACE_TYPE_ARG3) &regs, 0) == -1)
+    perror_with_name (_("Couldn't get registers"));
+  is64 = (regs.r_cs == GSEL (GUCODE_SEL, SEL_UPL));
+#ifdef PT_GETXSTATE_INFO
+  if (!xsave_probed)
+    {
+      struct ptrace_xstate_info info;
+
+      if (ptrace (PT_GETXSTATE_INFO, ptid_get_pid (inferior_ptid),
+		  (PTRACE_TYPE_ARG3) &info, sizeof (info)) == 0)
+	{
+	  x86bsd_xsave_len = info.xsave_len;
+	  xcr0 = info.xsave_mask;
+	}
+      xsave_probed = 1;
+    }
+
+  if (x86bsd_xsave_len != 0)
+    {
+      if (is64)
+	return amd64_target_description (xcr0);
+      else
+	return i386_target_description (xcr0);
+    }
+#endif
+  if (is64)
+    return tdesc_amd64;
+  else
+    return tdesc_i386;
+}
+
+/* Provide a prototype to silence -Wmissing-prototypes.  */
+void _initialize_amd64fbsd_nat (void);
+
+void
+_initialize_amd64fbsd_nat (void)
+{
+  struct target_ops *t;
+  int offset;
+
+  amd64_native_gregset32_reg_offset = amd64fbsd32_r_reg_offset;
+  amd64_native_gregset64_reg_offset = amd64fbsd64_r_reg_offset;
+
+  /* Add some extra features to the common *BSD/i386 target.  */
+  t = amd64bsd_target ();
+  t->to_read_description = amd64fbsd_read_description;
+
+  fbsd_nat_add_target (t);
+
+  /* Support debugging kernel virtual memory images.  */
+  bsd_kvm_add_target (amd64fbsd_supply_pcb);
+
+  /* To support the recognition of signal handlers, i386bsd-tdep.c
+     hardcodes some constants.  Inclusion of this file means that we
+     are compiling a native debugger, which means that we can use the
+     system header files and sysctl(3) to get at the relevant
+     information.  */
+
+#define SC_REG_OFFSET amd64fbsd_sc_reg_offset
+
+  /* We only check the program counter, stack pointer and frame
+     pointer since these members of `struct sigcontext' are essential
+     for providing backtraces.  */
+
+#define SC_RIP_OFFSET SC_REG_OFFSET[AMD64_RIP_REGNUM]
+#define SC_RSP_OFFSET SC_REG_OFFSET[AMD64_RSP_REGNUM]
+#define SC_RBP_OFFSET SC_REG_OFFSET[AMD64_RBP_REGNUM]
+
+  /* Override the default value for the offset of the program counter
+     in the sigcontext structure.  */
+  offset = offsetof (struct sigcontext, sc_rip);
+
+  if (SC_RIP_OFFSET != offset)
+    {
+      warning (_("\
+offsetof (struct sigcontext, sc_rip) yields %d instead of %d.\n\
+Please report this to <bug-gdb@gnu.org>."),
+	       offset, SC_RIP_OFFSET);
+    }
+
+  SC_RIP_OFFSET = offset;
+
+  /* Likewise for the stack pointer.  */
+  offset = offsetof (struct sigcontext, sc_rsp);
+
+  if (SC_RSP_OFFSET != offset)
+    {
+      warning (_("\
+offsetof (struct sigcontext, sc_rsp) yields %d instead of %d.\n\
+Please report this to <bug-gdb@gnu.org>."),
+	       offset, SC_RSP_OFFSET);
+    }
+
+  SC_RSP_OFFSET = offset;
+
+  /* And the frame pointer.  */
+  offset = offsetof (struct sigcontext, sc_rbp);
+
+  if (SC_RBP_OFFSET != offset)
+    {
+      warning (_("\
+offsetof (struct sigcontext, sc_rbp) yields %d instead of %d.\n\
+Please report this to <bug-gdb@gnu.org>."),
+	       offset, SC_RBP_OFFSET);
+    }
+
+  SC_RBP_OFFSET = offset;
+
+#ifdef KERN_PROC_SIGTRAMP
+  /* Normally signal frames are detected via amd64fbsd_sigtramp_p.
+     However, FreeBSD 9.2 through 10.1 do not include the page holding
+     the signal code in core dumps.  These releases do provide a
+     kern.proc.sigtramp.<pid> sysctl that returns the location of the
+     signal trampoline for a running process.  We fetch the location
+     of the current (gdb) process and use this to identify signal
+     frames in core dumps from these releases.  Note that this only
+     works for core dumps of 64-bit (FreeBSD/amd64) processes and does
+     not handle core dumps of 32-bit (FreeBSD/i386) processes.  */
+  {
+    int mib[4];
+    struct kinfo_sigtramp kst;
+    size_t len;
+
+    mib[0] = CTL_KERN;
+    mib[1] = KERN_PROC;
+    mib[2] = KERN_PROC_SIGTRAMP;
+    mib[3] = getpid ();
+    len = sizeof (kst);
+    if (sysctl (mib, 4, &kst, &len, NULL, 0) == 0)
+      {
+	amd64fbsd_sigtramp_start_addr = (uintptr_t) kst.ksigtramp_start;
+	amd64fbsd_sigtramp_end_addr = (uintptr_t) kst.ksigtramp_end;
+      }
+  }
+#endif
+}
diff --git a/contrib/gdb-7/gdb/fbsd_ref/amd64fbsd-tdep.c b/contrib/gdb-7/gdb/fbsd_ref/amd64fbsd-tdep.c
new file mode 100644
index 0000000000..ffb4516282
--- /dev/null
+++ b/contrib/gdb-7/gdb/fbsd_ref/amd64fbsd-tdep.c
@@ -0,0 +1,319 @@
+/* Target-dependent code for FreeBSD/amd64.
+
+   Copyright (C) 2003-2017 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "arch-utils.h"
+#include "frame.h"
+#include "gdbcore.h"
+#include "regcache.h"
+#include "osabi.h"
+#include "regset.h"
+#include "i386fbsd-tdep.h"
+#include "x86-xstate.h"
+
+#include "amd64-tdep.h"
+#include "bsd-uthread.h"
+#include "fbsd-tdep.h"
+#include "solib-svr4.h"
+
+/* Support for signal handlers.  */
+
+/* Return whether THIS_FRAME corresponds to a FreeBSD sigtramp
+   routine.  */
+
+static const gdb_byte amd64fbsd_sigtramp_code[] =
+{
+  0x48, 0x8d, 0x7c, 0x24, 0x10, /* lea     SIGF_UC(%rsp),%rdi */
+  0x6a, 0x00,			/* pushq   $0 */
+  0x48, 0xc7, 0xc0, 0xa1, 0x01, 0x00, 0x00,
+				/* movq    $SYS_sigreturn,%rax */
+  0x0f, 0x05                    /* syscall */
+};
+
+static int
+amd64fbsd_sigtramp_p (struct frame_info *this_frame)
+{
+  CORE_ADDR pc = get_frame_pc (this_frame);
+  gdb_byte buf[sizeof amd64fbsd_sigtramp_code];
+
+  if (!safe_frame_unwind_memory (this_frame, pc, buf, sizeof buf))
+    return 0;
+  if (memcmp (buf, amd64fbsd_sigtramp_code, sizeof amd64fbsd_sigtramp_code)
+      != 0)
+    return 0;
+
+  return 1;
+}
+
+/* Assuming THIS_FRAME is for a BSD sigtramp routine, return the
+   address of the associated sigcontext structure.  */
+
+static CORE_ADDR
+amd64fbsd_sigcontext_addr (struct frame_info *this_frame)
+{
+  struct gdbarch *gdbarch = get_frame_arch (this_frame);
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+  CORE_ADDR sp;
+  gdb_byte buf[8];
+
+  /* The `struct sigcontext' (which really is an `ucontext_t' on
+     FreeBSD/amd64) lives at a fixed offset in the signal frame.  See
+     <machine/sigframe.h>.  */
+  get_frame_register (this_frame, AMD64_RSP_REGNUM, buf);
+  sp = extract_unsigned_integer (buf, 8, byte_order);
+  return sp + 16;
+}
+
+/* FreeBSD 5.1-RELEASE or later.  */
+
+/* Mapping between the general-purpose registers in `struct reg'
+   format and GDB's register cache layout.
+
+   Note that some registers are 32-bit, but since we're little-endian
+   we get away with that.  */
+
+/* From <machine/reg.h>.  */
+static int amd64fbsd_r_reg_offset[] =
+{
+  14 * 8,			/* %rax */
+  11 * 8,			/* %rbx */
+  13 * 8,			/* %rcx */
+  12 * 8,			/* %rdx */
+  9 * 8,			/* %rsi */
+  8 * 8,			/* %rdi */
+  10 * 8,			/* %rbp */
+  20 * 8,			/* %rsp */
+  7 * 8,			/* %r8 ...  */
+  6 * 8,
+  5 * 8,
+  4 * 8,
+  3 * 8,
+  2 * 8,
+  1 * 8,
+  0 * 8,			/* ... %r15 */
+  17 * 8,			/* %rip */
+  19 * 8,			/* %eflags */
+  18 * 8,			/* %cs */
+  21 * 8,			/* %ss */
+  -1,				/* %ds */
+  -1,				/* %es */
+  -1,				/* %fs */
+  -1				/* %gs */
+};
+
+/* Location of the signal trampoline.  */
+CORE_ADDR amd64fbsd_sigtramp_start_addr;
+CORE_ADDR amd64fbsd_sigtramp_end_addr;
+
+/* From <machine/signal.h>.  */
+int amd64fbsd_sc_reg_offset[] =
+{
+  24 + 6 * 8,			/* %rax */
+  24 + 7 * 8,			/* %rbx */
+  24 + 3 * 8,			/* %rcx */
+  24 + 2 * 8,			/* %rdx */
+  24 + 1 * 8,			/* %rsi */
+  24 + 0 * 8,			/* %rdi */
+  24 + 8 * 8,			/* %rbp */
+  24 + 22 * 8,			/* %rsp */
+  24 + 4 * 8,			/* %r8 ...  */
+  24 + 5 * 8,
+  24 + 9 * 8,
+  24 + 10 * 8,
+  24 + 11 * 8,
+  24 + 12 * 8,
+  24 + 13 * 8,
+  24 + 14 * 8,			/* ... %r15 */
+  24 + 19 * 8,			/* %rip */
+  24 + 21 * 8,			/* %eflags */
+  24 + 20 * 8,			/* %cs */
+  24 + 23 * 8,			/* %ss */
+  -1,				/* %ds */
+  -1,				/* %es */
+  -1,				/* %fs */
+  -1				/* %gs */
+};
+
+/* From /usr/src/lib/libc/amd64/gen/_setjmp.S.  */
+static int amd64fbsd_jmp_buf_reg_offset[] =
+{
+  -1,				/* %rax */
+  1 * 8,			/* %rbx */
+  -1,				/* %rcx */
+  -1,				/* %rdx */
+  -1,				/* %rsi */
+  -1,				/* %rdi */
+  3 * 8,			/* %rbp */
+  2 * 8,			/* %rsp */
+  -1,				/* %r8 ...  */
+  -1,
+  -1,
+  -1,				/* ... %r11 */
+  4 * 8,			/* %r12 ...  */
+  5 * 8,
+  6 * 8,
+  7 * 8,			/* ... %r15 */
+  0 * 8				/* %rip */
+};
+
+/* Implement the core_read_description gdbarch method.  */
+
+static const struct target_desc *
+amd64fbsd_core_read_description (struct gdbarch *gdbarch,
+				 struct target_ops *target,
+				 bfd *abfd)
+{
+  return amd64_target_description (i386fbsd_core_read_xcr0 (abfd));
+}
+
+/* Similar to amd64_supply_fpregset, but use XSAVE extended state.  */
+
+static void
+amd64fbsd_supply_xstateregset (const struct regset *regset,
+			       struct regcache *regcache, int regnum,
+			       const void *xstateregs, size_t len)
+{
+  amd64_supply_xsave (regcache, regnum, xstateregs);
+}
+
+/* Similar to amd64_collect_fpregset, but use XSAVE extended state.  */
+
+static void
+amd64fbsd_collect_xstateregset (const struct regset *regset,
+				const struct regcache *regcache,
+				int regnum, void *xstateregs, size_t len)
+{
+  amd64_collect_xsave (regcache, regnum, xstateregs, 1);
+}
+
+static const struct regset amd64fbsd_xstateregset =
+  {
+    NULL,
+    amd64fbsd_supply_xstateregset,
+    amd64fbsd_collect_xstateregset
+  };
+
+/* Iterate over core file register note sections.  */
+
+static void
+amd64fbsd_iterate_over_regset_sections (struct gdbarch *gdbarch,
+					iterate_over_regset_sections_cb *cb,
+					void *cb_data,
+					const struct regcache *regcache)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  cb (".reg", tdep->sizeof_gregset, &i386_gregset, NULL, cb_data);
+  cb (".reg2", tdep->sizeof_fpregset, &amd64_fpregset, NULL, cb_data);
+  cb (".reg-xstate", X86_XSTATE_SIZE(tdep->xcr0),
+      &amd64fbsd_xstateregset, "XSAVE extended state", cb_data);
+}
+
+static void
+amd64fbsd_supply_uthread (struct regcache *regcache,
+			  int regnum, CORE_ADDR addr)
+{
+  gdb_byte buf[8];
+  int i;
+
+  gdb_assert (regnum >= -1);
+
+  for (i = 0; i < ARRAY_SIZE (amd64fbsd_jmp_buf_reg_offset); i++)
+    {
+      if (amd64fbsd_jmp_buf_reg_offset[i] != -1
+	  && (regnum == -1 || regnum == i))
+	{
+	  read_memory (addr + amd64fbsd_jmp_buf_reg_offset[i], buf, 8);
+	  regcache_raw_supply (regcache, i, buf);
+	}
+    }
+}
+
+static void
+amd64fbsd_collect_uthread (const struct regcache *regcache,
+			   int regnum, CORE_ADDR addr)
+{
+  gdb_byte buf[8];
+  int i;
+
+  gdb_assert (regnum >= -1);
+
+  for (i = 0; i < ARRAY_SIZE (amd64fbsd_jmp_buf_reg_offset); i++)
+    {
+      if (amd64fbsd_jmp_buf_reg_offset[i] != -1
+	  && (regnum == -1 || regnum == i))
+	{
+	  regcache_raw_collect (regcache, i, buf);
+	  write_memory (addr + amd64fbsd_jmp_buf_reg_offset[i], buf, 8);
+	}
+    }
+}
+
+static void
+amd64fbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  /* Generic FreeBSD support. */
+  fbsd_init_abi (info, gdbarch);
+
+  /* Obviously FreeBSD is BSD-based.  */
+  i386bsd_init_abi (info, gdbarch);
+
+  tdep->gregset_reg_offset = amd64fbsd_r_reg_offset;
+  tdep->gregset_num_regs = ARRAY_SIZE (amd64fbsd_r_reg_offset);
+  tdep->sizeof_gregset = 22 * 8;
+
+  amd64_init_abi (info, gdbarch);
+
+  tdep->sigtramp_p = amd64fbsd_sigtramp_p;
+  tdep->sigtramp_start = amd64fbsd_sigtramp_start_addr;
+  tdep->sigtramp_end = amd64fbsd_sigtramp_end_addr;
+  tdep->sigcontext_addr = amd64fbsd_sigcontext_addr;
+  tdep->sc_reg_offset = amd64fbsd_sc_reg_offset;
+  tdep->sc_num_regs = ARRAY_SIZE (amd64fbsd_sc_reg_offset);
+
+  tdep->xsave_xcr0_offset = I386_FBSD_XSAVE_XCR0_OFFSET;
+
+  /* Iterate over core file register note sections.  */
+  set_gdbarch_iterate_over_regset_sections
+    (gdbarch, amd64fbsd_iterate_over_regset_sections);
+
+  set_gdbarch_core_read_description (gdbarch,
+				     amd64fbsd_core_read_description);
+
+  /* FreeBSD provides a user-level threads implementation.  */
+  bsd_uthread_set_supply_uthread (gdbarch, amd64fbsd_supply_uthread);
+  bsd_uthread_set_collect_uthread (gdbarch, amd64fbsd_collect_uthread);
+
+  /* FreeBSD uses SVR4-style shared libraries.  */
+  set_solib_svr4_fetch_link_map_offsets
+    (gdbarch, svr4_lp64_fetch_link_map_offsets);
+}
+
+
+/* Provide a prototype to silence -Wmissing-prototypes.  */
+void _initialize_amd64fbsd_tdep (void);
+
+void
+_initialize_amd64fbsd_tdep (void)
+{
+  gdbarch_register_osabi (bfd_arch_i386, bfd_mach_x86_64,
+			  GDB_OSABI_FREEBSD_ELF, amd64fbsd_init_abi);
+}
diff --git a/contrib/gdb-7/gdb/fbsd_ref/fbsd-nat.c b/contrib/gdb-7/gdb/fbsd_ref/fbsd-nat.c
new file mode 100644
index 0000000000..e0b7f6e67e
--- /dev/null
+++ b/contrib/gdb-7/gdb/fbsd_ref/fbsd-nat.c
@@ -0,0 +1,1126 @@
+/* Native-dependent code for FreeBSD.
+
+   Copyright (C) 2002-2017 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "gdbcore.h"
+#include "inferior.h"
+#include "regcache.h"
+#include "regset.h"
+#include "gdbcmd.h"
+#include "gdbthread.h"
+#include "gdb_wait.h"
+#include <sys/types.h>
+#include <sys/procfs.h>
+#include <sys/ptrace.h>
+#include <sys/sysctl.h>
+#ifdef HAVE_KINFO_GETVMMAP
+#include <sys/user.h>
+#include <libutil.h>
+#endif
+
+#include "elf-bfd.h"
+#include "fbsd-nat.h"
+
+/* Return the name of a file that can be opened to get the symbols for
+   the child process identified by PID.  */
+
+static char *
+fbsd_pid_to_exec_file (struct target_ops *self, int pid)
+{
+  ssize_t len;
+  static char buf[PATH_MAX];
+  char name[PATH_MAX];
+
+#ifdef KERN_PROC_PATHNAME
+  size_t buflen;
+  int mib[4];
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PROC;
+  mib[2] = KERN_PROC_PATHNAME;
+  mib[3] = pid;
+  buflen = sizeof buf;
+  if (sysctl (mib, 4, buf, &buflen, NULL, 0) == 0)
+    return buf;
+#endif
+
+  xsnprintf (name, PATH_MAX, "/proc/%d/exe", pid);
+  len = readlink (name, buf, PATH_MAX - 1);
+  if (len != -1)
+    {
+      buf[len] = '\0';
+      return buf;
+    }
+
+  return NULL;
+}
+
+#ifdef HAVE_KINFO_GETVMMAP
+/* Iterate over all the memory regions in the current inferior,
+   calling FUNC for each memory region.  OBFD is passed as the last
+   argument to FUNC.  */
+
+static int
+fbsd_find_memory_regions (struct target_ops *self,
+			  find_memory_region_ftype func, void *obfd)
+{
+  pid_t pid = ptid_get_pid (inferior_ptid);
+  struct kinfo_vmentry *vmentl, *kve;
+  uint64_t size;
+  struct cleanup *cleanup;
+  int i, nitems;
+
+  vmentl = kinfo_getvmmap (pid, &nitems);
+  if (vmentl == NULL)
+    perror_with_name (_("Couldn't fetch VM map entries."));
+  cleanup = make_cleanup (free, vmentl);
+
+  for (i = 0; i < nitems; i++)
+    {
+      kve = &vmentl[i];
+
+      /* Skip unreadable segments and those where MAP_NOCORE has been set.  */
+      if (!(kve->kve_protection & KVME_PROT_READ)
+	  || kve->kve_flags & KVME_FLAG_NOCOREDUMP)
+	continue;
+
+      /* Skip segments with an invalid type.  */
+      if (kve->kve_type != KVME_TYPE_DEFAULT
+	  && kve->kve_type != KVME_TYPE_VNODE
+	  && kve->kve_type != KVME_TYPE_SWAP
+	  && kve->kve_type != KVME_TYPE_PHYS)
+	continue;
+
+      size = kve->kve_end - kve->kve_start;
+      if (info_verbose)
+	{
+	  fprintf_filtered (gdb_stdout, 
+			    "Save segment, %ld bytes at %s (%c%c%c)\n",
+			    (long) size,
+			    paddress (target_gdbarch (), kve->kve_start),
+			    kve->kve_protection & KVME_PROT_READ ? 'r' : '-',
+			    kve->kve_protection & KVME_PROT_WRITE ? 'w' : '-',
+			    kve->kve_protection & KVME_PROT_EXEC ? 'x' : '-');
+	}
+
+      /* Invoke the callback function to create the corefile segment.
+	 Pass MODIFIED as true, we do not know the real modification state.  */
+      func (kve->kve_start, size, kve->kve_protection & KVME_PROT_READ,
+	    kve->kve_protection & KVME_PROT_WRITE,
+	    kve->kve_protection & KVME_PROT_EXEC, 1, obfd);
+    }
+  do_cleanups (cleanup);
+  return 0;
+}
+#else
+static int
+fbsd_read_mapping (FILE *mapfile, unsigned long *start, unsigned long *end,
+		   char *protection)
+{
+  /* FreeBSD 5.1-RELEASE uses a 256-byte buffer.  */
+  char buf[256];
+  int resident, privateresident;
+  unsigned long obj;
+  int ret = EOF;
+
+  /* As of FreeBSD 5.0-RELEASE, the layout is described in
+     /usr/src/sys/fs/procfs/procfs_map.c.  Somewhere in 5.1-CURRENT a
+     new column was added to the procfs map.  Therefore we can't use
+     fscanf since we need to support older releases too.  */
+  if (fgets (buf, sizeof buf, mapfile) != NULL)
+    ret = sscanf (buf, "%lx %lx %d %d %lx %s", start, end,
+		  &resident, &privateresident, &obj, protection);
+
+  return (ret != 0 && ret != EOF);
+}
+
+/* Iterate over all the memory regions in the current inferior,
+   calling FUNC for each memory region.  OBFD is passed as the last
+   argument to FUNC.  */
+
+static int
+fbsd_find_memory_regions (struct target_ops *self,
+			  find_memory_region_ftype func, void *obfd)
+{
+  pid_t pid = ptid_get_pid (inferior_ptid);
+  char *mapfilename;
+  FILE *mapfile;
+  unsigned long start, end, size;
+  char protection[4];
+  int read, write, exec;
+  struct cleanup *cleanup;
+
+  mapfilename = xstrprintf ("/proc/%ld/map", (long) pid);
+  cleanup = make_cleanup (xfree, mapfilename);
+  mapfile = fopen (mapfilename, "r");
+  if (mapfile == NULL)
+    error (_("Couldn't open %s."), mapfilename);
+  make_cleanup_fclose (mapfile);
+
+  if (info_verbose)
+    fprintf_filtered (gdb_stdout, 
+		      "Reading memory regions from %s\n", mapfilename);
+
+  /* Now iterate until end-of-file.  */
+  while (fbsd_read_mapping (mapfile, &start, &end, &protection[0]))
+    {
+      size = end - start;
+
+      read = (strchr (protection, 'r') != 0);
+      write = (strchr (protection, 'w') != 0);
+      exec = (strchr (protection, 'x') != 0);
+
+      if (info_verbose)
+	{
+	  fprintf_filtered (gdb_stdout, 
+			    "Save segment, %ld bytes at %s (%c%c%c)\n",
+			    size, paddress (target_gdbarch (), start),
+			    read ? 'r' : '-',
+			    write ? 'w' : '-',
+			    exec ? 'x' : '-');
+	}
+
+      /* Invoke the callback function to create the corefile segment.
+	 Pass MODIFIED as true, we do not know the real modification state.  */
+      func (start, size, read, write, exec, 1, obfd);
+    }
+
+  do_cleanups (cleanup);
+  return 0;
+}
+#endif
+
+#ifdef KERN_PROC_AUXV
+static enum target_xfer_status (*super_xfer_partial) (struct target_ops *ops,
+						      enum target_object object,
+						      const char *annex,
+						      gdb_byte *readbuf,
+						      const gdb_byte *writebuf,
+						      ULONGEST offset,
+						      ULONGEST len,
+						      ULONGEST *xfered_len);
+
+/* Implement the "to_xfer_partial target_ops" method.  */
+
+static enum target_xfer_status
+fbsd_xfer_partial (struct target_ops *ops, enum target_object object,
+		   const char *annex, gdb_byte *readbuf,
+		   const gdb_byte *writebuf,
+		   ULONGEST offset, ULONGEST len, ULONGEST *xfered_len)
+{
+  pid_t pid = ptid_get_pid (inferior_ptid);
+
+  switch (object)
+    {
+    case TARGET_OBJECT_AUXV:
+      {
+	struct cleanup *cleanup = make_cleanup (null_cleanup, NULL);
+	unsigned char *buf;
+	size_t buflen;
+	int mib[4];
+
+	if (writebuf != NULL)
+	  return TARGET_XFER_E_IO;
+	mib[0] = CTL_KERN;
+	mib[1] = KERN_PROC;
+	mib[2] = KERN_PROC_AUXV;
+	mib[3] = pid;
+	if (offset == 0)
+	  {
+	    buf = readbuf;
+	    buflen = len;
+	  }
+	else
+	  {
+	    buflen = offset + len;
+	    buf = XCNEWVEC (unsigned char, buflen);
+	    cleanup = make_cleanup (xfree, buf);
+	  }
+	if (sysctl (mib, 4, buf, &buflen, NULL, 0) == 0)
+	  {
+	    if (offset != 0)
+	      {
+		if (buflen > offset)
+		  {
+		    buflen -= offset;
+		    memcpy (readbuf, buf + offset, buflen);
+		  }
+		else
+		  buflen = 0;
+	      }
+	    do_cleanups (cleanup);
+	    *xfered_len = buflen;
+	    return (buflen == 0) ? TARGET_XFER_EOF : TARGET_XFER_OK;
+	  }
+	do_cleanups (cleanup);
+	return TARGET_XFER_E_IO;
+      }
+    default:
+      return super_xfer_partial (ops, object, annex, readbuf, writebuf, offset,
+				 len, xfered_len);
+    }
+}
+#endif
+
+#ifdef PT_LWPINFO
+static int debug_fbsd_lwp;
+
+static void (*super_resume) (struct target_ops *,
+			     ptid_t,
+			     int,
+			     enum gdb_signal);
+static ptid_t (*super_wait) (struct target_ops *,
+			     ptid_t,
+			     struct target_waitstatus *,
+			     int);
+
+static void
+show_fbsd_lwp_debug (struct ui_file *file, int from_tty,
+		     struct cmd_list_element *c, const char *value)
+{
+  fprintf_filtered (file, _("Debugging of FreeBSD lwp module is %s.\n"), value);
+}
+
+#if defined(TDP_RFPPWAIT) || defined(HAVE_STRUCT_PTRACE_LWPINFO_PL_TDNAME)
+/* Fetch the external variant of the kernel's internal process
+   structure for the process PID into KP.  */
+
+static void
+fbsd_fetch_kinfo_proc (pid_t pid, struct kinfo_proc *kp)
+{
+  size_t len;
+  int mib[4];
+
+  len = sizeof *kp;
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PROC;
+  mib[2] = KERN_PROC_PID;
+  mib[3] = pid;
+  if (sysctl (mib, 4, kp, &len, NULL, 0) == -1)
+    perror_with_name (("sysctl"));
+}
+#endif
+
+/*
+  FreeBSD's first thread support was via a "reentrant" version of libc
+  (libc_r) that first shipped in 2.2.7.  This library multiplexed all
+  of the threads in a process onto a single kernel thread.  This
+  library is supported via the bsd-uthread target.
+
+  FreeBSD 5.1 introduced two new threading libraries that made use of
+  multiple kernel threads.  The first (libkse) scheduled M user
+  threads onto N (<= M) kernel threads (LWPs).  The second (libthr)
+  bound each user thread to a dedicated kernel thread.  libkse shipped
+  as the default threading library (libpthread).
+
+  FreeBSD 5.3 added a libthread_db to abstract the interface across
+  the various thread libraries (libc_r, libkse, and libthr).
+
+  FreeBSD 7.0 switched the default threading library from from libkse
+  to libpthread and removed libc_r.
+
+  FreeBSD 8.0 removed libkse and the in-kernel support for it.  The
+  only threading library supported by 8.0 and later is libthr which
+  ties each user thread directly to an LWP.  To simplify the
+  implementation, this target only supports LWP-backed threads using
+  ptrace directly rather than libthread_db.
+
+  FreeBSD 11.0 introduced LWP event reporting via PT_LWP_EVENTS.
+*/
+
+/* Return true if PTID is still active in the inferior.  */
+
+static int
+fbsd_thread_alive (struct target_ops *ops, ptid_t ptid)
+{
+  if (ptid_lwp_p (ptid))
+    {
+      struct ptrace_lwpinfo pl;
+
+      if (ptrace (PT_LWPINFO, ptid_get_lwp (ptid), (caddr_t) &pl, sizeof pl)
+	  == -1)
+	return 0;
+#ifdef PL_FLAG_EXITED
+      if (pl.pl_flags & PL_FLAG_EXITED)
+	return 0;
+#endif
+    }
+
+  return 1;
+}
+
+/* Convert PTID to a string.  Returns the string in a static
+   buffer.  */
+
+static char *
+fbsd_pid_to_str (struct target_ops *ops, ptid_t ptid)
+{
+  lwpid_t lwp;
+
+  lwp = ptid_get_lwp (ptid);
+  if (lwp != 0)
+    {
+      static char buf[64];
+      int pid = ptid_get_pid (ptid);
+
+      xsnprintf (buf, sizeof buf, "LWP %d of process %d", lwp, pid);
+      return buf;
+    }
+
+  return normal_pid_to_str (ptid);
+}
+
+#ifdef HAVE_STRUCT_PTRACE_LWPINFO_PL_TDNAME
+/* Return the name assigned to a thread by an application.  Returns
+   the string in a static buffer.  */
+
+static const char *
+fbsd_thread_name (struct target_ops *self, struct thread_info *thr)
+{
+  struct ptrace_lwpinfo pl;
+  struct kinfo_proc kp;
+  int pid = ptid_get_pid (thr->ptid);
+  long lwp = ptid_get_lwp (thr->ptid);
+  static char buf[sizeof pl.pl_tdname + 1];
+
+  /* Note that ptrace_lwpinfo returns the process command in pl_tdname
+     if a name has not been set explicitly.  Return a NULL name in
+     that case.  */
+  fbsd_fetch_kinfo_proc (pid, &kp);
+  if (ptrace (PT_LWPINFO, lwp, (caddr_t) &pl, sizeof pl) == -1)
+    perror_with_name (("ptrace"));
+  if (strcmp (kp.ki_comm, pl.pl_tdname) == 0)
+    return NULL;
+  xsnprintf (buf, sizeof buf, "%s", pl.pl_tdname);
+  return buf;
+}
+#endif
+
+/* Enable additional event reporting on new processes.
+
+   To catch fork events, PTRACE_FORK is set on every traced process
+   to enable stops on returns from fork or vfork.  Note that both the
+   parent and child will always stop, even if system call stops are
+   not enabled.
+
+   To catch LWP events, PTRACE_EVENTS is set on every traced process.
+   This enables stops on the birth for new LWPs (excluding the "main" LWP)
+   and the death of LWPs (excluding the last LWP in a process).  Note
+   that unlike fork events, the LWP that creates a new LWP does not
+   report an event.  */
+
+static void
+fbsd_enable_proc_events (pid_t pid)
+{
+#ifdef PT_GET_EVENT_MASK
+  int events;
+
+  if (ptrace (PT_GET_EVENT_MASK, pid, (PTRACE_TYPE_ARG3)&events,
+	      sizeof (events)) == -1)
+    perror_with_name (("ptrace"));
+  events |= PTRACE_FORK | PTRACE_LWP;
+#ifdef PTRACE_VFORK
+  events |= PTRACE_VFORK;
+#endif
+  if (ptrace (PT_SET_EVENT_MASK, pid, (PTRACE_TYPE_ARG3)&events,
+	      sizeof (events)) == -1)
+    perror_with_name (("ptrace"));
+#else
+#ifdef TDP_RFPPWAIT
+  if (ptrace (PT_FOLLOW_FORK, pid, (PTRACE_TYPE_ARG3)0, 1) == -1)
+    perror_with_name (("ptrace"));
+#endif
+#ifdef PT_LWP_EVENTS
+  if (ptrace (PT_LWP_EVENTS, pid, (PTRACE_TYPE_ARG3)0, 1) == -1)
+    perror_with_name (("ptrace"));
+#endif
+#endif
+}
+
+/* Add threads for any new LWPs in a process.
+
+   When LWP events are used, this function is only used to detect existing
+   threads when attaching to a process.  On older systems, this function is
+   called to discover new threads each time the thread list is updated.  */
+
+static void
+fbsd_add_threads (pid_t pid)
+{
+  struct cleanup *cleanup;
+  lwpid_t *lwps;
+  int i, nlwps;
+
+  gdb_assert (!in_thread_list (pid_to_ptid (pid)));
+  nlwps = ptrace (PT_GETNUMLWPS, pid, NULL, 0);
+  if (nlwps == -1)
+    perror_with_name (("ptrace"));
+
+  lwps = XCNEWVEC (lwpid_t, nlwps);
+  cleanup = make_cleanup (xfree, lwps);
+
+  nlwps = ptrace (PT_GETLWPLIST, pid, (caddr_t) lwps, nlwps);
+  if (nlwps == -1)
+    perror_with_name (("ptrace"));
+
+  for (i = 0; i < nlwps; i++)
+    {
+      ptid_t ptid = ptid_build (pid, lwps[i], 0);
+
+      if (!in_thread_list (ptid))
+	{
+#ifdef PT_LWP_EVENTS
+	  struct ptrace_lwpinfo pl;
+
+	  /* Don't add exited threads.  Note that this is only called
+	     when attaching to a multi-threaded process.  */
+	  if (ptrace (PT_LWPINFO, lwps[i], (caddr_t) &pl, sizeof pl) == -1)
+	    perror_with_name (("ptrace"));
+	  if (pl.pl_flags & PL_FLAG_EXITED)
+	    continue;
+#endif
+	  if (debug_fbsd_lwp)
+	    fprintf_unfiltered (gdb_stdlog,
+				"FLWP: adding thread for LWP %u\n",
+				lwps[i]);
+	  add_thread (ptid);
+	}
+    }
+  do_cleanups (cleanup);
+}
+
+/* Implement the "to_update_thread_list" target_ops method.  */
+
+static void
+fbsd_update_thread_list (struct target_ops *ops)
+{
+#ifdef PT_LWP_EVENTS
+  /* With support for thread events, threads are added/deleted from the
+     list as events are reported, so just try deleting exited threads.  */
+  delete_exited_threads ();
+#else
+  prune_threads ();
+
+  fbsd_add_threads (ptid_get_pid (inferior_ptid));
+#endif
+}
+
+#ifdef TDP_RFPPWAIT
+/*
+  To catch fork events, PT_FOLLOW_FORK is set on every traced process
+  to enable stops on returns from fork or vfork.  Note that both the
+  parent and child will always stop, even if system call stops are not
+  enabled.
+
+  After a fork, both the child and parent process will stop and report
+  an event.  However, there is no guarantee of order.  If the parent
+  reports its stop first, then fbsd_wait explicitly waits for the new
+  child before returning.  If the child reports its stop first, then
+  the event is saved on a list and ignored until the parent's stop is
+  reported.  fbsd_wait could have been changed to fetch the parent PID
+  of the new child and used that to wait for the parent explicitly.
+  However, if two threads in the parent fork at the same time, then
+  the wait on the parent might return the "wrong" fork event.
+
+  The initial version of PT_FOLLOW_FORK did not set PL_FLAG_CHILD for
+  the new child process.  This flag could be inferred by treating any
+  events for an unknown pid as a new child.
+
+  In addition, the initial version of PT_FOLLOW_FORK did not report a
+  stop event for the parent process of a vfork until after the child
+  process executed a new program or exited.  The kernel was changed to
+  defer the wait for exit or exec of the child until after posting the
+  stop event shortly after the change to introduce PL_FLAG_CHILD.
+  This could be worked around by reporting a vfork event when the
+  child event posted and ignoring the subsequent event from the
+  parent.
+
+  This implementation requires both of these fixes for simplicity's
+  sake.  FreeBSD versions newer than 9.1 contain both fixes.
+*/
+
+struct fbsd_fork_info
+{
+  struct fbsd_fork_info *next;
+  ptid_t ptid;
+};
+
+static struct fbsd_fork_info *fbsd_pending_children;
+
+/* Record a new child process event that is reported before the
+   corresponding fork event in the parent.  */
+
+static void
+fbsd_remember_child (ptid_t pid)
+{
+  struct fbsd_fork_info *info = XCNEW (struct fbsd_fork_info);
+
+  info->ptid = pid;
+  info->next = fbsd_pending_children;
+  fbsd_pending_children = info;
+}
+
+/* Check for a previously-recorded new child process event for PID.
+   If one is found, remove it from the list and return the PTID.  */
+
+static ptid_t
+fbsd_is_child_pending (pid_t pid)
+{
+  struct fbsd_fork_info *info, *prev;
+  ptid_t ptid;
+
+  prev = NULL;
+  for (info = fbsd_pending_children; info; prev = info, info = info->next)
+    {
+      if (ptid_get_pid (info->ptid) == pid)
+	{
+	  if (prev == NULL)
+	    fbsd_pending_children = info->next;
+	  else
+	    prev->next = info->next;
+	  ptid = info->ptid;
+	  xfree (info);
+	  return ptid;
+	}
+    }
+  return null_ptid;
+}
+
+#ifndef PTRACE_VFORK
+static struct fbsd_fork_info *fbsd_pending_vfork_done;
+
+/* Record a pending vfork done event.  */
+
+static void
+fbsd_add_vfork_done (ptid_t pid)
+{
+  struct fbsd_fork_info *info = XCNEW (struct fbsd_fork_info);
+
+  info->ptid = pid;
+  info->next = fbsd_pending_vfork_done;
+  fbsd_pending_vfork_done = info;
+}
+
+/* Check for a pending vfork done event for a specific PID.  */
+
+static int
+fbsd_is_vfork_done_pending (pid_t pid)
+{
+  struct fbsd_fork_info *info;
+
+  for (info = fbsd_pending_vfork_done; info != NULL; info = info->next)
+    {
+      if (ptid_get_pid (info->ptid) == pid)
+	return 1;
+    }
+  return 0;
+}
+
+/* Check for a pending vfork done event.  If one is found, remove it
+   from the list and return the PTID.  */
+
+static ptid_t
+fbsd_next_vfork_done (void)
+{
+  struct fbsd_fork_info *info;
+  ptid_t ptid;
+
+  if (fbsd_pending_vfork_done != NULL)
+    {
+      info = fbsd_pending_vfork_done;
+      fbsd_pending_vfork_done = info->next;
+      ptid = info->ptid;
+      xfree (info);
+      return ptid;
+    }
+  return null_ptid;
+}
+#endif
+#endif
+
+static int
+resume_one_thread_cb (struct thread_info *tp, void *data)
+{
+  ptid_t *ptid = (ptid_t *) data;
+  int request;
+
+  if (ptid_get_pid (tp->ptid) != ptid_get_pid (*ptid))
+    return 0;
+
+  if (ptid_get_lwp (tp->ptid) == ptid_get_lwp (*ptid))
+    request = PT_RESUME;
+  else
+    request = PT_SUSPEND;
+
+  if (ptrace (request, ptid_get_lwp (tp->ptid), NULL, 0) == -1)
+    perror_with_name (("ptrace"));
+  return 0;
+}
+
+static int
+resume_all_threads_cb (struct thread_info *tp, void *data)
+{
+  ptid_t *filter = (ptid_t *) data;
+
+  if (!ptid_match (tp->ptid, *filter))
+    return 0;
+
+  if (tp->state == THREAD_EXITED) {
+    return 0;
+  }
+  if (ptrace (PT_RESUME, ptid_get_lwp (tp->ptid), NULL, 0) == -1)
+    perror_with_name (("ptrace"));
+  return 0;
+}
+
+/* Implement the "to_resume" target_ops method.  */
+
+static void
+fbsd_resume (struct target_ops *ops,
+	     ptid_t ptid, int step, enum gdb_signal signo)
+{
+#if defined(TDP_RFPPWAIT) && !defined(PTRACE_VFORK)
+  pid_t pid;
+
+  /* Don't PT_CONTINUE a process which has a pending vfork done event.  */
+  if (ptid_equal (minus_one_ptid, ptid))
+    pid = ptid_get_pid (inferior_ptid);
+  else
+    pid = ptid_get_pid (ptid);
+  if (fbsd_is_vfork_done_pending (pid))
+    return;
+#endif
+
+  if (debug_fbsd_lwp)
+    fprintf_unfiltered (gdb_stdlog,
+			"FLWP: fbsd_resume for ptid (%d, %ld, %ld)\n",
+			ptid_get_pid (ptid), ptid_get_lwp (ptid),
+			ptid_get_tid (ptid));
+  if (ptid_lwp_p (ptid))
+    {
+#ifndef PT_LWP_EVENTS
+      /* When LWP events are not supported, a new thread might already be
+	 running that has not yet reported an event when GDB wishes to
+         only run a single thread.  Force an update of the thread list
+	 to ensure that any such threads are suspended before the process
+	 is resumed.  */
+      fbsd_add_threads (ptid_get_pid (ptid));
+#endif
+      /* If ptid is a specific LWP, suspend all other LWPs in the process.  */
+      iterate_over_threads (resume_one_thread_cb, &ptid);
+    }
+  else
+    {
+      /* If ptid is a wildcard, resume all matching threads (they won't run
+	 until the process is continued however).  */
+      iterate_over_threads (resume_all_threads_cb, &ptid);
+      ptid = inferior_ptid;
+    }
+  super_resume (ops, ptid, step, signo);
+}
+
+/* Wait for the child specified by PTID to do something.  Return the
+   process ID of the child, or MINUS_ONE_PTID in case of error; store
+   the status in *OURSTATUS.  */
+
+static ptid_t
+fbsd_wait (struct target_ops *ops,
+	   ptid_t ptid, struct target_waitstatus *ourstatus,
+	   int target_options)
+{
+  ptid_t wptid;
+
+  while (1)
+    {
+#ifndef PTRACE_VFORK
+      wptid = fbsd_next_vfork_done ();
+      if (!ptid_equal (wptid, null_ptid))
+	{
+	  ourstatus->kind = TARGET_WAITKIND_VFORK_DONE;
+	  return wptid;
+	}
+#endif
+      wptid = super_wait (ops, ptid, ourstatus, target_options);
+      if (ourstatus->kind == TARGET_WAITKIND_STOPPED)
+	{
+	  struct ptrace_lwpinfo pl;
+	  pid_t pid;
+	  int status;
+
+	  pid = ptid_get_pid (wptid);
+	  if (ptrace (PT_LWPINFO, pid, (caddr_t) &pl, sizeof pl) == -1)
+	    perror_with_name (("ptrace"));
+
+	  wptid = ptid_build (pid, pl.pl_lwpid, 0);
+
+#ifdef PT_LWP_EVENTS
+	  if (pl.pl_flags & PL_FLAG_EXITED)
+	    {
+	      /* If GDB attaches to a multi-threaded process, exiting
+		 threads might be skipped during fbsd_post_attach that
+		 have not yet reported their PL_FLAG_EXITED event.
+		 Ignore EXITED events for an unknown LWP.  */
+	      if (in_thread_list (wptid))
+		{
+		  if (debug_fbsd_lwp)
+		    fprintf_unfiltered (gdb_stdlog,
+					"FLWP: deleting thread for LWP %u\n",
+					pl.pl_lwpid);
+		  if (print_thread_events)
+		    printf_unfiltered (_("[%s exited]\n"), target_pid_to_str
+				       (wptid));
+		  delete_thread (wptid);
+		}
+	      if (ptrace (PT_CONTINUE, pid, (caddr_t) 1, 0) == -1)
+		perror_with_name (("ptrace"));
+	      continue;
+	    }
+#endif
+
+	  /* Switch to an LWP PTID on the first stop in a new process.
+	     This is done after handling PL_FLAG_EXITED to avoid
+	     switching to an exited LWP.  It is done before checking
+	     PL_FLAG_BORN in case the first stop reported after
+	     attaching to an existing process is a PL_FLAG_BORN
+	     event.  */
+	  if (in_thread_list (pid_to_ptid (pid)))
+	    {
+	      if (debug_fbsd_lwp)
+		fprintf_unfiltered (gdb_stdlog,
+				    "FLWP: using LWP %u for first thread\n",
+				    pl.pl_lwpid);
+	      thread_change_ptid (pid_to_ptid (pid), wptid);
+	    }
+
+#ifdef PT_LWP_EVENTS
+	  if (pl.pl_flags & PL_FLAG_BORN)
+	    {
+	      /* If GDB attaches to a multi-threaded process, newborn
+		 threads might be added by fbsd_add_threads that have
+		 not yet reported their PL_FLAG_BORN event.  Ignore
+		 BORN events for an already-known LWP.  */
+	      if (!in_thread_list (wptid))
+		{
+		  if (debug_fbsd_lwp)
+		    fprintf_unfiltered (gdb_stdlog,
+					"FLWP: adding thread for LWP %u\n",
+					pl.pl_lwpid);
+		  add_thread (wptid);
+		}
+	      ourstatus->kind = TARGET_WAITKIND_SPURIOUS;
+	      return wptid;
+	    }
+#endif
+
+#ifdef TDP_RFPPWAIT
+	  if (pl.pl_flags & PL_FLAG_FORKED)
+	    {
+#ifndef PTRACE_VFORK
+	      struct kinfo_proc kp;
+#endif
+	      ptid_t child_ptid;
+	      pid_t child;
+
+	      child = pl.pl_child_pid;
+	      ourstatus->kind = TARGET_WAITKIND_FORKED;
+#ifdef PTRACE_VFORK
+	      if (pl.pl_flags & PL_FLAG_VFORKED)
+		ourstatus->kind = TARGET_WAITKIND_VFORKED;
+#endif
+
+	      /* Make sure the other end of the fork is stopped too.  */
+	      child_ptid = fbsd_is_child_pending (child);
+	      if (ptid_equal (child_ptid, null_ptid))
+		{
+		  pid = waitpid (child, &status, 0);
+		  if (pid == -1)
+		    perror_with_name (("waitpid"));
+
+		  gdb_assert (pid == child);
+
+		  if (ptrace (PT_LWPINFO, child, (caddr_t)&pl, sizeof pl) == -1)
+		    perror_with_name (("ptrace"));
+
+		  gdb_assert (pl.pl_flags & PL_FLAG_CHILD);
+		  child_ptid = ptid_build (child, pl.pl_lwpid, 0);
+		}
+
+	      /* Enable additional events on the child process.  */
+	      fbsd_enable_proc_events (ptid_get_pid (child_ptid));
+
+#ifndef PTRACE_VFORK
+	      /* For vfork, the child process will have the P_PPWAIT
+		 flag set.  */
+	      fbsd_fetch_kinfo_proc (child, &kp);
+	      if (kp.ki_flag & P_PPWAIT)
+		ourstatus->kind = TARGET_WAITKIND_VFORKED;
+#endif
+	      ourstatus->value.related_pid = child_ptid;
+
+	      return wptid;
+	    }
+
+	  if (pl.pl_flags & PL_FLAG_CHILD)
+	    {
+	      /* Remember that this child forked, but do not report it
+		 until the parent reports its corresponding fork
+		 event.  */
+	      fbsd_remember_child (wptid);
+	      continue;
+	    }
+
+#ifdef PTRACE_VFORK
+	  if (pl.pl_flags & PL_FLAG_VFORK_DONE)
+	    {
+	      ourstatus->kind = TARGET_WAITKIND_VFORK_DONE;
+	      return wptid;
+	    }
+#endif
+#endif
+
+#ifdef PL_FLAG_EXEC
+	  if (pl.pl_flags & PL_FLAG_EXEC)
+	    {
+	      ourstatus->kind = TARGET_WAITKIND_EXECD;
+	      ourstatus->value.execd_pathname
+		= xstrdup (fbsd_pid_to_exec_file (NULL, pid));
+	      return wptid;
+	    }
+#endif
+
+	  /* Note that PL_FLAG_SCE is set for any event reported while
+	     a thread is executing a system call in the kernel.  In
+	     particular, signals that interrupt a sleep in a system
+	     call will report this flag as part of their event.  Stops
+	     explicitly for system call entry and exit always use
+	     SIGTRAP, so only treat SIGTRAP events as system call
+	     entry/exit events.  */
+	  if (pl.pl_flags & (PL_FLAG_SCE | PL_FLAG_SCX)
+	      && ourstatus->value.sig == SIGTRAP)
+	    {
+#ifdef HAVE_STRUCT_PTRACE_LWPINFO_PL_SYSCALL_CODE
+	      if (catch_syscall_enabled ())
+		{
+		  if (catching_syscall_number (pl.pl_syscall_code))
+		    {
+		      if (pl.pl_flags & PL_FLAG_SCE)
+			ourstatus->kind = TARGET_WAITKIND_SYSCALL_ENTRY;
+		      else
+			ourstatus->kind = TARGET_WAITKIND_SYSCALL_RETURN;
+		      ourstatus->value.syscall_number = pl.pl_syscall_code;
+		      return wptid;
+		    }
+		}
+#endif
+	      /* If the core isn't interested in this event, just
+		 continue the process explicitly and wait for another
+		 event.  Note that PT_SYSCALL is "sticky" on FreeBSD
+		 and once system call stops are enabled on a process
+		 it stops for all system call entries and exits.  */
+	      if (ptrace (PT_CONTINUE, pid, (caddr_t) 1, 0) == -1)
+		perror_with_name (("ptrace"));
+	      continue;
+	    }
+	}
+      return wptid;
+    }
+}
+
+#ifdef TDP_RFPPWAIT
+/* Target hook for follow_fork.  On entry and at return inferior_ptid is
+   the ptid of the followed inferior.  */
+
+static int
+fbsd_follow_fork (struct target_ops *ops, int follow_child,
+			int detach_fork)
+{
+  if (!follow_child && detach_fork)
+    {
+      struct thread_info *tp = inferior_thread ();
+      pid_t child_pid = ptid_get_pid (tp->pending_follow.value.related_pid);
+
+      /* Breakpoints have already been detached from the child by
+	 infrun.c.  */
+
+      if (ptrace (PT_DETACH, child_pid, (PTRACE_TYPE_ARG3)1, 0) == -1)
+	perror_with_name (("ptrace"));
+
+#ifndef PTRACE_VFORK
+      if (tp->pending_follow.kind == TARGET_WAITKIND_VFORKED)
+	{
+	  /* We can't insert breakpoints until the child process has
+	     finished with the shared memory region.  The parent
+	     process doesn't wait for the child process to exit or
+	     exec until after it has been resumed from the ptrace stop
+	     to report the fork.  Once it has been resumed it doesn't
+	     stop again before returning to userland, so there is no
+	     reliable way to wait on the parent.
+
+	     We can't stay attached to the child to wait for an exec
+	     or exit because it may invoke ptrace(PT_TRACE_ME)
+	     (e.g. if the parent process is a debugger forking a new
+	     child process).
+
+	     In the end, the best we can do is to make sure it runs
+	     for a little while.  Hopefully it will be out of range of
+	     any breakpoints we reinsert.  Usually this is only the
+	     single-step breakpoint at vfork's return point.  */
+
+	  usleep (10000);
+
+	  /* Schedule a fake VFORK_DONE event to report on the next
+	     wait.  */
+	  fbsd_add_vfork_done (inferior_ptid);
+	}
+#endif
+    }
+
+  return 0;
+}
+
+static int
+fbsd_insert_fork_catchpoint (struct target_ops *self, int pid)
+{
+  return 0;
+}
+
+static int
+fbsd_remove_fork_catchpoint (struct target_ops *self, int pid)
+{
+  return 0;
+}
+
+static int
+fbsd_insert_vfork_catchpoint (struct target_ops *self, int pid)
+{
+  return 0;
+}
+
+static int
+fbsd_remove_vfork_catchpoint (struct target_ops *self, int pid)
+{
+  return 0;
+}
+#endif
+
+/* Implement the "to_post_startup_inferior" target_ops method.  */
+
+static void
+fbsd_post_startup_inferior (struct target_ops *self, ptid_t pid)
+{
+  fbsd_enable_proc_events (ptid_get_pid (pid));
+}
+
+/* Implement the "to_post_attach" target_ops method.  */
+
+static void
+fbsd_post_attach (struct target_ops *self, int pid)
+{
+  fbsd_enable_proc_events (pid);
+  fbsd_add_threads (pid);
+}
+
+#ifdef PL_FLAG_EXEC
+/* If the FreeBSD kernel supports PL_FLAG_EXEC, then traced processes
+   will always stop after exec.  */
+
+static int
+fbsd_insert_exec_catchpoint (struct target_ops *self, int pid)
+{
+  return 0;
+}
+
+static int
+fbsd_remove_exec_catchpoint (struct target_ops *self, int pid)
+{
+  return 0;
+}
+#endif
+
+#ifdef HAVE_STRUCT_PTRACE_LWPINFO_PL_SYSCALL_CODE
+static int
+fbsd_set_syscall_catchpoint (struct target_ops *self, int pid, int needed,
+			     int any_count, int table_size, int *table)
+{
+
+  /* Ignore the arguments.  inf-ptrace.c will use PT_SYSCALL which
+     will catch all system call entries and exits.  The system calls
+     are filtered by GDB rather than the kernel.  */
+  return 0;
+}
+#endif
+#endif
+
+void
+fbsd_nat_add_target (struct target_ops *t)
+{
+  t->to_pid_to_exec_file = fbsd_pid_to_exec_file;
+  t->to_find_memory_regions = fbsd_find_memory_regions;
+#ifdef KERN_PROC_AUXV
+  super_xfer_partial = t->to_xfer_partial;
+  t->to_xfer_partial = fbsd_xfer_partial;
+#endif
+#ifdef PT_LWPINFO
+  t->to_thread_alive = fbsd_thread_alive;
+  t->to_pid_to_str = fbsd_pid_to_str;
+#ifdef HAVE_STRUCT_PTRACE_LWPINFO_PL_TDNAME
+  t->to_thread_name = fbsd_thread_name;
+#endif
+  t->to_update_thread_list = fbsd_update_thread_list;
+  t->to_has_thread_control = tc_schedlock;
+  super_resume = t->to_resume;
+  t->to_resume = fbsd_resume;
+  super_wait = t->to_wait;
+  t->to_wait = fbsd_wait;
+  t->to_post_startup_inferior = fbsd_post_startup_inferior;
+  t->to_post_attach = fbsd_post_attach;
+#ifdef TDP_RFPPWAIT
+  t->to_follow_fork = fbsd_follow_fork;
+  t->to_insert_fork_catchpoint = fbsd_insert_fork_catchpoint;
+  t->to_remove_fork_catchpoint = fbsd_remove_fork_catchpoint;
+  t->to_insert_vfork_catchpoint = fbsd_insert_vfork_catchpoint;
+  t->to_remove_vfork_catchpoint = fbsd_remove_vfork_catchpoint;
+#endif
+#ifdef PL_FLAG_EXEC
+  t->to_insert_exec_catchpoint = fbsd_insert_exec_catchpoint;
+  t->to_remove_exec_catchpoint = fbsd_remove_exec_catchpoint;
+#endif
+#ifdef HAVE_STRUCT_PTRACE_LWPINFO_PL_SYSCALL_CODE
+  t->to_set_syscall_catchpoint = fbsd_set_syscall_catchpoint;
+#endif
+#endif
+  add_target (t);
+}
+
+/* Provide a prototype to silence -Wmissing-prototypes.  */
+extern initialize_file_ftype _initialize_fbsd_nat;
+
+void
+_initialize_fbsd_nat (void)
+{
+#ifdef PT_LWPINFO
+  add_setshow_boolean_cmd ("fbsd-lwp", class_maintenance,
+			   &debug_fbsd_lwp, _("\
+Set debugging of FreeBSD lwp module."), _("\
+Show debugging of FreeBSD lwp module."), _("\
+Enables printf debugging output."),
+			   NULL,
+			   &show_fbsd_lwp_debug,
+			   &setdebuglist, &showdebuglist);
+#endif
+}
diff --git a/contrib/gdb-7/gdb/fbsd_ref/fbsd-nat.h b/contrib/gdb-7/gdb/fbsd_ref/fbsd-nat.h
new file mode 100644
index 0000000000..5eb000289a
--- /dev/null
+++ b/contrib/gdb-7/gdb/fbsd_ref/fbsd-nat.h
@@ -0,0 +1,27 @@
+/* Native-dependent code for FreeBSD.
+
+   Copyright (C) 2004-2017 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef FBSD_NAT_H
+#define FBSD_NAT_H
+
+/* Register the customized FreeBSD target.  This should be used
+   instead of calling add_target directly.  */
+extern void fbsd_nat_add_target (struct target_ops *);
+
+#endif /* fbsd-nat.h */
diff --git a/contrib/gdb-7/gdb/fbsd_ref/fbsd-tdep.c b/contrib/gdb-7/gdb/fbsd_ref/fbsd-tdep.c
new file mode 100644
index 0000000000..daa54e77dd
--- /dev/null
+++ b/contrib/gdb-7/gdb/fbsd_ref/fbsd-tdep.c
@@ -0,0 +1,350 @@
+/* Target-dependent code for FreeBSD, architecture-independent.
+
+   Copyright (C) 2002-2017 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "auxv.h"
+#include "gdbcore.h"
+#include "inferior.h"
+#include "regcache.h"
+#include "regset.h"
+#include "gdbthread.h"
+#include "xml-syscall.h"
+
+#include "elf-bfd.h"
+#include "fbsd-tdep.h"
+
+
+/* This is how we want PTIDs from core files to be printed.  */
+
+static char *
+fbsd_core_pid_to_str (struct gdbarch *gdbarch, ptid_t ptid)
+{
+  static char buf[80];
+
+  if (ptid_get_lwp (ptid) != 0)
+    {
+      xsnprintf (buf, sizeof buf, "LWP %ld", ptid_get_lwp (ptid));
+      return buf;
+    }
+
+  return normal_pid_to_str (ptid);
+}
+
+/* Extract the name assigned to a thread from a core.  Returns the
+   string in a static buffer.  */
+
+static const char *
+fbsd_core_thread_name (struct gdbarch *gdbarch, struct thread_info *thr)
+{
+  static char buf[80];
+  struct bfd_section *section;
+  bfd_size_type size;
+  char sectionstr[32];
+
+  if (ptid_get_lwp (thr->ptid) != 0)
+    {
+      /* FreeBSD includes a NT_FREEBSD_THRMISC note for each thread
+	 whose contents are defined by a "struct thrmisc" declared in
+	 <sys/procfs.h> on FreeBSD.  The per-thread name is stored as
+	 a null-terminated string as the first member of the
+	 structure.  Rather than define the full structure here, just
+	 extract the null-terminated name from the start of the
+	 note.  */
+      xsnprintf (sectionstr, sizeof sectionstr, ".thrmisc/%ld",
+		ptid_get_lwp (thr->ptid));
+      section = bfd_get_section_by_name (core_bfd, sectionstr);
+      if (section != NULL && bfd_section_size (core_bfd, section) > 0)
+	{
+	  /* Truncate the name if it is longer than "buf".  */
+	  size = bfd_section_size (core_bfd, section);
+	  if (size > sizeof buf - 1)
+	    size = sizeof buf - 1;
+	  if (bfd_get_section_contents (core_bfd, section, buf, (file_ptr) 0,
+					size)
+	      && buf[0] != '\0')
+	    {
+	      buf[size] = '\0';
+
+	      /* Note that each thread will report the process command
+		 as its thread name instead of an empty name if a name
+		 has not been set explicitly.  Return a NULL name in
+		 that case.  */
+	      if (strcmp (buf, elf_tdata (core_bfd)->core->program) != 0)
+		return buf;
+	    }
+	}
+    }
+
+  return NULL;
+}
+
+static int
+find_signalled_thread (struct thread_info *info, void *data)
+{
+  if (info->suspend.stop_signal != GDB_SIGNAL_0
+      && ptid_get_pid (info->ptid) == ptid_get_pid (inferior_ptid))
+    return 1;
+
+  return 0;
+}
+
+/* Structure for passing information from
+   fbsd_collect_thread_registers via an iterator to
+   fbsd_collect_regset_section_cb. */
+
+struct fbsd_collect_regset_section_cb_data
+{
+  const struct regcache *regcache;
+  bfd *obfd;
+  char *note_data;
+  int *note_size;
+  unsigned long lwp;
+  enum gdb_signal stop_signal;
+  int abort_iteration;
+};
+
+static void
+fbsd_collect_regset_section_cb (const char *sect_name, int size,
+				const struct regset *regset,
+				const char *human_name, void *cb_data)
+{
+  char *buf;
+  struct fbsd_collect_regset_section_cb_data *data
+    = (struct fbsd_collect_regset_section_cb_data *) cb_data;
+
+  if (data->abort_iteration)
+    return;
+
+  gdb_assert (regset->collect_regset);
+
+  buf = (char *) xmalloc (size);
+  regset->collect_regset (regset, data->regcache, -1, buf, size);
+
+  /* PRSTATUS still needs to be treated specially.  */
+  if (strcmp (sect_name, ".reg") == 0)
+    data->note_data = (char *) elfcore_write_prstatus
+      (data->obfd, data->note_data, data->note_size, data->lwp,
+       gdb_signal_to_host (data->stop_signal), buf);
+  else
+    data->note_data = (char *) elfcore_write_register_note
+      (data->obfd, data->note_data, data->note_size,
+       sect_name, buf, size);
+  xfree (buf);
+
+  if (data->note_data == NULL)
+    data->abort_iteration = 1;
+}
+
+/* Records the thread's register state for the corefile note
+   section.  */
+
+static char *
+fbsd_collect_thread_registers (const struct regcache *regcache,
+			       ptid_t ptid, bfd *obfd,
+			       char *note_data, int *note_size,
+			       enum gdb_signal stop_signal)
+{
+  struct gdbarch *gdbarch = get_regcache_arch (regcache);
+  struct fbsd_collect_regset_section_cb_data data;
+
+  data.regcache = regcache;
+  data.obfd = obfd;
+  data.note_data = note_data;
+  data.note_size = note_size;
+  data.stop_signal = stop_signal;
+  data.abort_iteration = 0;
+  data.lwp = ptid_get_lwp (ptid);
+
+  gdbarch_iterate_over_regset_sections (gdbarch,
+					fbsd_collect_regset_section_cb,
+					&data, regcache);
+  return data.note_data;
+}
+
+struct fbsd_corefile_thread_data
+{
+  struct gdbarch *gdbarch;
+  bfd *obfd;
+  char *note_data;
+  int *note_size;
+  enum gdb_signal stop_signal;
+};
+
+/* Records the thread's register state for the corefile note
+   section.  */
+
+static void
+fbsd_corefile_thread (struct thread_info *info,
+		      struct fbsd_corefile_thread_data *args)
+{
+  struct cleanup *old_chain;
+  struct regcache *regcache;
+
+  regcache = get_thread_arch_regcache (info->ptid, args->gdbarch);
+
+  old_chain = save_inferior_ptid ();
+  inferior_ptid = info->ptid;
+  target_fetch_registers (regcache, -1);
+  do_cleanups (old_chain);
+
+  args->note_data = fbsd_collect_thread_registers
+    (regcache, info->ptid, args->obfd, args->note_data,
+     args->note_size, args->stop_signal);
+}
+
+/* Create appropriate note sections for a corefile, returning them in
+   allocated memory.  */
+
+static char *
+fbsd_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd, int *note_size)
+{
+  struct fbsd_corefile_thread_data thread_args;
+  char *note_data = NULL;
+  Elf_Internal_Ehdr *i_ehdrp;
+  struct thread_info *curr_thr, *signalled_thr, *thr;
+
+  /* Put a "FreeBSD" label in the ELF header.  */
+  i_ehdrp = elf_elfheader (obfd);
+  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_FREEBSD;
+
+  gdb_assert (gdbarch_iterate_over_regset_sections_p (gdbarch));
+
+  if (get_exec_file (0))
+    {
+      const char *fname = lbasename (get_exec_file (0));
+      char *psargs = xstrdup (fname);
+
+      if (get_inferior_args ())
+	psargs = reconcat (psargs, psargs, " ", get_inferior_args (),
+			   (char *) NULL);
+
+      note_data = elfcore_write_prpsinfo (obfd, note_data, note_size,
+					  fname, psargs);
+    }
+
+  /* Thread register information.  */
+  TRY
+    {
+      update_thread_list ();
+    }
+  CATCH (e, RETURN_MASK_ERROR)
+    {
+      exception_print (gdb_stderr, e);
+    }
+  END_CATCH
+
+  /* Like the kernel, prefer dumping the signalled thread first.
+     "First thread" is what tools use to infer the signalled thread.
+     In case there's more than one signalled thread, prefer the
+     current thread, if it is signalled.  */
+  curr_thr = inferior_thread ();
+  if (curr_thr->suspend.stop_signal != GDB_SIGNAL_0)
+    signalled_thr = curr_thr;
+  else
+    {
+      signalled_thr = iterate_over_threads (find_signalled_thread, NULL);
+      if (signalled_thr == NULL)
+	signalled_thr = curr_thr;
+    }
+
+  thread_args.gdbarch = gdbarch;
+  thread_args.obfd = obfd;
+  thread_args.note_data = note_data;
+  thread_args.note_size = note_size;
+  thread_args.stop_signal = signalled_thr->suspend.stop_signal;
+
+  fbsd_corefile_thread (signalled_thr, &thread_args);
+  ALL_NON_EXITED_THREADS (thr)
+    {
+      if (thr == signalled_thr)
+	continue;
+      if (ptid_get_pid (thr->ptid) != ptid_get_pid (inferior_ptid))
+	continue;
+
+      fbsd_corefile_thread (thr, &thread_args);
+    }
+
+  note_data = thread_args.note_data;
+
+  return note_data;
+}
+
+/* Print descriptions of FreeBSD-specific AUXV entries to FILE.  */
+
+static void
+fbsd_print_auxv_entry (struct gdbarch *gdbarch, struct ui_file *file,
+		       CORE_ADDR type, CORE_ADDR val)
+{
+  const char *name;
+  const char *description;
+  enum auxv_format format;
+
+  switch (type)
+    {
+#define _TAGNAME(tag) #tag
+#define TAGNAME(tag) _TAGNAME(AT_##tag)
+#define TAG(tag, text, kind) \
+      case AT_FREEBSD_##tag: name = TAGNAME(tag); description = text; format = kind; break
+      TAG (EXECPATH, _("Executable path"), AUXV_FORMAT_STR);
+      TAG (CANARY, _("Canary for SSP"), AUXV_FORMAT_HEX);
+      TAG (CANARYLEN, ("Length of the SSP canary"), AUXV_FORMAT_DEC);
+      TAG (OSRELDATE, _("OSRELDATE"), AUXV_FORMAT_DEC);
+      TAG (NCPUS, _("Number of CPUs"), AUXV_FORMAT_DEC);
+      TAG (PAGESIZES, _("Pagesizes"), AUXV_FORMAT_HEX);
+      TAG (PAGESIZESLEN, _("Number of pagesizes"), AUXV_FORMAT_DEC);
+      TAG (TIMEKEEP, _("Pointer to timehands"), AUXV_FORMAT_HEX);
+      TAG (STACKPROT, _("Initial stack protection"), AUXV_FORMAT_HEX);
+    default:
+      default_print_auxv_entry (gdbarch, file, type, val);
+      return;
+    }
+
+  fprint_auxv_entry (file, name, description, format, type, val);
+}
+
+/* Implement the "get_syscall_number" gdbarch method.  */
+
+static LONGEST
+fbsd_get_syscall_number (struct gdbarch *gdbarch,
+			 ptid_t ptid)
+{
+
+  /* FreeBSD doesn't use gdbarch_get_syscall_number since FreeBSD
+     native targets fetch the system call number from the
+     'pl_syscall_code' member of struct ptrace_lwpinfo in fbsd_wait.
+     However, system call catching requires this function to be
+     set.  */
+
+  internal_error (__FILE__, __LINE__, _("fbsd_get_sycall_number called"));
+}
+
+/* To be called from GDB_OSABI_FREEBSD_ELF handlers. */
+
+void
+fbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
+{
+  set_gdbarch_core_pid_to_str (gdbarch, fbsd_core_pid_to_str);
+  set_gdbarch_core_thread_name (gdbarch, fbsd_core_thread_name);
+  set_gdbarch_make_corefile_notes (gdbarch, fbsd_make_corefile_notes);
+  set_gdbarch_print_auxv_entry (gdbarch, fbsd_print_auxv_entry);
+
+  /* `catch syscall' */
+  set_xml_syscall_file_name (gdbarch, "syscalls/freebsd.xml");
+  set_gdbarch_get_syscall_number (gdbarch, fbsd_get_syscall_number);
+}
diff --git a/contrib/gdb-7/gdb/fbsd_ref/fbsd-tdep.h b/contrib/gdb-7/gdb/fbsd_ref/fbsd-tdep.h
new file mode 100644
index 0000000000..ff2e207aae
--- /dev/null
+++ b/contrib/gdb-7/gdb/fbsd_ref/fbsd-tdep.h
@@ -0,0 +1,25 @@
+/* Target-dependent code for FreeBSD, architecture independent.
+
+   Copyright (C) 2009-2017 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef FBSD_TDEP_H
+#define FBSD_TDEP_H
+
+extern void fbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch);
+
+#endif /* fbsd-tdep.h */
diff --git a/contrib/gdb-7/gdb/fbsd_ref/i386fbsd-nat.c b/contrib/gdb-7/gdb/fbsd_ref/i386fbsd-nat.c
new file mode 100644
index 0000000000..0b4cd36200
--- /dev/null
+++ b/contrib/gdb-7/gdb/fbsd_ref/i386fbsd-nat.c
@@ -0,0 +1,196 @@
+/* Native-dependent code for FreeBSD/i386.
+
+   Copyright (C) 2001-2017 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "inferior.h"
+#include "regcache.h"
+#include "target.h"
+
+#include <sys/types.h>
+#include <sys/ptrace.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+
+#include "fbsd-nat.h"
+#include "i386-tdep.h"
+#include "x86-nat.h"
+#include "x86bsd-nat.h"
+#include "i386bsd-nat.h"
+
+/* Resume execution of the inferior process.  If STEP is nonzero,
+   single-step it.  If SIGNAL is nonzero, give it that signal.  */
+
+static void
+i386fbsd_resume (struct target_ops *ops,
+		 ptid_t ptid, int step, enum gdb_signal signal)
+{
+  pid_t pid = ptid_get_pid (ptid);
+  int request = PT_STEP;
+
+  if (pid == -1)
+    /* Resume all threads.  This only gets used in the non-threaded
+       case, where "resume all threads" and "resume inferior_ptid" are
+       the same.  */
+    pid = ptid_get_pid (inferior_ptid);
+
+  if (!step)
+    {
+      struct regcache *regcache = get_current_regcache ();
+      ULONGEST eflags;
+
+      /* Workaround for a bug in FreeBSD.  Make sure that the trace
+ 	 flag is off when doing a continue.  There is a code path
+ 	 through the kernel which leaves the flag set when it should
+ 	 have been cleared.  If a process has a signal pending (such
+ 	 as SIGALRM) and we do a PT_STEP, the process never really has
+ 	 a chance to run because the kernel needs to notify the
+ 	 debugger that a signal is being sent.  Therefore, the process
+ 	 never goes through the kernel's trap() function which would
+ 	 normally clear it.  */
+
+      regcache_cooked_read_unsigned (regcache, I386_EFLAGS_REGNUM,
+				     &eflags);
+      if (eflags & 0x0100)
+	regcache_cooked_write_unsigned (regcache, I386_EFLAGS_REGNUM,
+					eflags & ~0x0100);
+
+      request = PT_CONTINUE;
+    }
+
+  /* An addres of (caddr_t) 1 tells ptrace to continue from where it
+     was.  (If GDB wanted it to start some other way, we have already
+     written a new PC value to the child.)  */
+  if (ptrace (request, pid, (caddr_t) 1,
+	      gdb_signal_to_host (signal)) == -1)
+    perror_with_name (("ptrace"));
+}
+
+
+/* Support for debugging kernel virtual memory images.  */
+
+#include <machine/pcb.h>
+
+#include "bsd-kvm.h"
+
+static int
+i386fbsd_supply_pcb (struct regcache *regcache, struct pcb *pcb)
+{
+  /* The following is true for FreeBSD 4.7:
+
+     The pcb contains %eip, %ebx, %esp, %ebp, %esi, %edi and %gs.
+     This accounts for all callee-saved registers specified by the
+     psABI and then some.  Here %esp contains the stack pointer at the
+     point just after the call to cpu_switch().  From this information
+     we reconstruct the register state as it would look when we just
+     returned from cpu_switch().  */
+
+  /* The stack pointer shouldn't be zero.  */
+  if (pcb->pcb_esp == 0)
+    return 0;
+
+  pcb->pcb_esp += 4;
+  regcache_raw_supply (regcache, I386_EDI_REGNUM, &pcb->pcb_edi);
+  regcache_raw_supply (regcache, I386_ESI_REGNUM, &pcb->pcb_esi);
+  regcache_raw_supply (regcache, I386_EBP_REGNUM, &pcb->pcb_ebp);
+  regcache_raw_supply (regcache, I386_ESP_REGNUM, &pcb->pcb_esp);
+  regcache_raw_supply (regcache, I386_EBX_REGNUM, &pcb->pcb_ebx);
+  regcache_raw_supply (regcache, I386_EIP_REGNUM, &pcb->pcb_eip);
+  regcache_raw_supply (regcache, I386_GS_REGNUM, &pcb->pcb_gs);
+
+  return 1;
+}
+
+
+#ifdef PT_GETXSTATE_INFO
+/* Implement the to_read_description method.  */
+
+static const struct target_desc *
+i386fbsd_read_description (struct target_ops *ops)
+{
+  static int xsave_probed;
+  static uint64_t xcr0;
+
+  if (!xsave_probed)
+    {
+      struct ptrace_xstate_info info;
+
+      if (ptrace (PT_GETXSTATE_INFO, ptid_get_pid (inferior_ptid),
+		  (PTRACE_TYPE_ARG3) &info, sizeof (info)) == 0)
+	{
+	  x86bsd_xsave_len = info.xsave_len;
+	  xcr0 = info.xsave_mask;
+	}
+      xsave_probed = 1;
+    }
+
+  if (x86bsd_xsave_len != 0)
+    {
+      return i386_target_description (xcr0);
+    }
+  else
+    return tdesc_i386;
+}
+#endif
+
+/* Prevent warning from -Wmissing-prototypes.  */
+void _initialize_i386fbsd_nat (void);
+
+void
+_initialize_i386fbsd_nat (void)
+{
+  struct target_ops *t;
+
+  /* Add some extra features to the common *BSD/i386 target.  */
+  t = i386bsd_target ();
+
+#ifdef PT_GETXSTATE_INFO
+  t->to_read_description = i386fbsd_read_description;
+#endif
+
+  fbsd_nat_add_target (t);
+
+  /* Support debugging kernel virtual memory images.  */
+  bsd_kvm_add_target (i386fbsd_supply_pcb);
+
+#ifdef KERN_PROC_SIGTRAMP
+  /* Normally signal frames are detected via i386fbsd_sigtramp_p.
+     However, FreeBSD 9.2 through 10.1 do not include the page holding
+     the signal code in core dumps.  These releases do provide a
+     kern.proc.sigtramp.<pid> sysctl that returns the location of the
+     signal trampoline for a running process.  We fetch the location
+     of the current (gdb) process and use this to identify signal
+     frames in core dumps from these releases.  */
+  {
+    int mib[4];
+    struct kinfo_sigtramp kst;
+    size_t len;
+
+    mib[0] = CTL_KERN;
+    mib[1] = KERN_PROC;
+    mib[2] = KERN_PROC_SIGTRAMP;
+    mib[3] = getpid ();
+    len = sizeof (kst);
+    if (sysctl (mib, 4, &kst, &len, NULL, 0) == 0)
+      {
+	i386fbsd_sigtramp_start_addr = (uintptr_t) kst.ksigtramp_start;
+	i386fbsd_sigtramp_end_addr = (uintptr_t) kst.ksigtramp_end;
+      }
+  }
+#endif
+}
diff --git a/contrib/gdb-7/gdb/fbsd_ref/i386fbsd-tdep.c b/contrib/gdb-7/gdb/fbsd_ref/i386fbsd-tdep.c
new file mode 100644
index 0000000000..03f0922bc7
--- /dev/null
+++ b/contrib/gdb-7/gdb/fbsd_ref/i386fbsd-tdep.c
@@ -0,0 +1,498 @@
+/* Target-dependent code for FreeBSD/i386.
+
+   Copyright (C) 2003-2017 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "arch-utils.h"
+#include "gdbcore.h"
+#include "osabi.h"
+#include "regcache.h"
+#include "regset.h"
+#include "i386fbsd-tdep.h"
+#include "x86-xstate.h"
+
+#include "i386-tdep.h"
+#include "i387-tdep.h"
+#include "bsd-uthread.h"
+#include "fbsd-tdep.h"
+#include "solib-svr4.h"
+
+/* Support for signal handlers.  */
+
+/* Return whether THIS_FRAME corresponds to a FreeBSD sigtramp
+   routine.  */
+
+/* FreeBSD/i386 supports three different signal trampolines, one for
+   versions before 4.0, a second for 4.x, and a third for 5.0 and
+   later.  To complicate matters, FreeBSD/i386 binaries running under
+   an amd64 kernel use a different set of trampolines.  These
+   trampolines differ from the i386 kernel trampolines in that they
+   omit a middle section that conditionally restores %gs.  */
+
+static const gdb_byte i386fbsd_sigtramp_start[] =
+{
+  0x8d, 0x44, 0x24, 0x20,       /* lea     SIGF_UC(%esp),%eax */
+  0x50				/* pushl   %eax */
+};
+
+static const gdb_byte i386fbsd_sigtramp_middle[] =
+{
+  0xf7, 0x40, 0x54, 0x00, 0x00, 0x02, 0x00,
+				/* testl   $PSL_VM,UC_EFLAGS(%eax) */
+  0x75, 0x03,			/* jne	   +3 */
+  0x8e, 0x68, 0x14		/* mov	   UC_GS(%eax),%gs */
+};
+
+static const gdb_byte i386fbsd_sigtramp_end[] =
+{
+  0xb8, 0xa1, 0x01, 0x00, 0x00, /* movl   $SYS_sigreturn,%eax */
+  0x50,			/* pushl   %eax */
+  0xcd, 0x80			/* int	   $0x80 */
+};
+
+static const gdb_byte i386fbsd_freebsd4_sigtramp_start[] =
+{
+  0x8d, 0x44, 0x24, 0x14,	/* lea	   SIGF_UC4(%esp),%eax */
+  0x50				/* pushl   %eax */
+};
+
+static const gdb_byte i386fbsd_freebsd4_sigtramp_middle[] =
+{
+  0xf7, 0x40, 0x54, 0x00, 0x00, 0x02, 0x00,
+				/* testl   $PSL_VM,UC4_EFLAGS(%eax) */
+  0x75, 0x03,			/* jne	   +3 */
+  0x8e, 0x68, 0x14		/* mov	   UC4_GS(%eax),%gs */
+};
+
+static const gdb_byte i386fbsd_freebsd4_sigtramp_end[] =
+{
+  0xb8, 0x58, 0x01, 0x00, 0x00, /* movl    $344,%eax */
+  0x50,			/* pushl   %eax */
+  0xcd, 0x80			/* int	   $0x80 */
+};
+
+static const gdb_byte i386fbsd_osigtramp_start[] =
+{
+  0x8d, 0x44, 0x24, 0x14,	/* lea	   SIGF_SC(%esp),%eax */
+  0x50				/* pushl   %eax */
+};
+
+static const gdb_byte i386fbsd_osigtramp_middle[] =
+{
+  0xf7, 0x40, 0x18, 0x00, 0x00, 0x02, 0x00,
+				/* testl   $PSL_VM,SC_PS(%eax) */
+  0x75, 0x03,			/* jne	   +3 */
+  0x8e, 0x68, 0x44		/* mov	   SC_GS(%eax),%gs */
+};
+
+static const gdb_byte i386fbsd_osigtramp_end[] =
+{
+  0xb8, 0x67, 0x00, 0x00, 0x00, /* movl    $103,%eax */
+  0x50,			/* pushl   %eax */
+  0xcd, 0x80			/* int	   $0x80 */
+};
+
+/* The three different trampolines are all the same size.  */
+gdb_static_assert (sizeof i386fbsd_sigtramp_start
+		   == sizeof i386fbsd_freebsd4_sigtramp_start);
+gdb_static_assert (sizeof i386fbsd_sigtramp_start
+		   == sizeof i386fbsd_osigtramp_start);
+gdb_static_assert (sizeof i386fbsd_sigtramp_middle
+		   == sizeof i386fbsd_freebsd4_sigtramp_middle);
+gdb_static_assert (sizeof i386fbsd_sigtramp_middle
+		   == sizeof i386fbsd_osigtramp_middle);
+gdb_static_assert (sizeof i386fbsd_sigtramp_end
+		   == sizeof i386fbsd_freebsd4_sigtramp_end);
+gdb_static_assert (sizeof i386fbsd_sigtramp_end
+		   == sizeof i386fbsd_osigtramp_end);
+
+/* We assume that the middle is the largest chunk below.  */
+gdb_static_assert (sizeof i386fbsd_sigtramp_middle
+		   > sizeof i386fbsd_sigtramp_start);
+gdb_static_assert (sizeof i386fbsd_sigtramp_middle
+		   > sizeof i386fbsd_sigtramp_end);
+
+static int
+i386fbsd_sigtramp_p (struct frame_info *this_frame)
+{
+  CORE_ADDR pc = get_frame_pc (this_frame);
+  gdb_byte buf[sizeof i386fbsd_sigtramp_middle];
+  const gdb_byte *middle, *end;
+
+  /* Look for a matching start.  */
+  if (!safe_frame_unwind_memory (this_frame, pc, buf,
+				 sizeof i386fbsd_sigtramp_start))
+    return 0;
+  if (memcmp (buf, i386fbsd_sigtramp_start, sizeof i386fbsd_sigtramp_start)
+      == 0)
+    {
+      middle = i386fbsd_sigtramp_middle;
+      end = i386fbsd_sigtramp_end;
+    }
+  else if (memcmp (buf, i386fbsd_freebsd4_sigtramp_start,
+		   sizeof i386fbsd_freebsd4_sigtramp_start) == 0)
+    {
+      middle = i386fbsd_freebsd4_sigtramp_middle;
+      end = i386fbsd_freebsd4_sigtramp_end;
+    }
+  else if (memcmp (buf, i386fbsd_osigtramp_start,
+		   sizeof i386fbsd_osigtramp_start) == 0)
+    {
+      middle = i386fbsd_osigtramp_middle;
+      end = i386fbsd_osigtramp_end;
+    }
+  else
+    return 0;
+
+  /* Since the end is shorter than the middle, check for a matching end
+     next.  */
+  pc += sizeof i386fbsd_sigtramp_start;
+  if (!safe_frame_unwind_memory (this_frame, pc, buf,
+				 sizeof i386fbsd_sigtramp_end))
+    return 0;
+  if (memcmp (buf, end, sizeof i386fbsd_sigtramp_end) == 0)
+    return 1;
+
+  /* If the end didn't match, check for a matching middle.  */
+  if (!safe_frame_unwind_memory (this_frame, pc, buf,
+				 sizeof i386fbsd_sigtramp_middle))
+    return 0;
+  if (memcmp (buf, middle, sizeof i386fbsd_sigtramp_middle) != 0)
+    return 0;
+
+  /* The middle matched, check for a matching end.  */
+  pc += sizeof i386fbsd_sigtramp_middle;
+  if (!safe_frame_unwind_memory (this_frame, pc, buf,
+				 sizeof i386fbsd_sigtramp_end))
+    return 0;
+  if (memcmp (buf, end, sizeof i386fbsd_sigtramp_end) != 0)
+    return 0;
+
+  return 1;
+}
+
+/* FreeBSD 3.0-RELEASE or later.  */
+
+/* From <machine/reg.h>.  */
+static int i386fbsd_r_reg_offset[] =
+{
+  9 * 4, 8 * 4, 7 * 4, 6 * 4,	/* %eax, %ecx, %edx, %ebx */
+  15 * 4, 4 * 4,		/* %esp, %ebp */
+  3 * 4, 2 * 4,			/* %esi, %edi */
+  12 * 4, 14 * 4,		/* %eip, %eflags */
+  13 * 4, 16 * 4,		/* %cs, %ss */
+  1 * 4, 0 * 4, -1, -1		/* %ds, %es, %fs, %gs */
+};
+
+/* Sigtramp routine location.  */
+CORE_ADDR i386fbsd_sigtramp_start_addr;
+CORE_ADDR i386fbsd_sigtramp_end_addr;
+
+/* From <machine/signal.h>.  */
+int i386fbsd_sc_reg_offset[] =
+{
+  8 + 14 * 4,			/* %eax */
+  8 + 13 * 4,			/* %ecx */
+  8 + 12 * 4,			/* %edx */
+  8 + 11 * 4,			/* %ebx */
+  8 + 0 * 4,                    /* %esp */
+  8 + 1 * 4,                    /* %ebp */
+  8 + 10 * 4,                   /* %esi */
+  8 + 9 * 4,                    /* %edi */
+  8 + 3 * 4,                    /* %eip */
+  8 + 4 * 4,                    /* %eflags */
+  8 + 7 * 4,                    /* %cs */
+  8 + 8 * 4,                    /* %ss */
+  8 + 6 * 4,                    /* %ds */
+  8 + 5 * 4,                    /* %es */
+  8 + 15 * 4,			/* %fs */
+  8 + 16 * 4			/* %gs */
+};
+
+/* From /usr/src/lib/libc/i386/gen/_setjmp.S.  */
+static int i386fbsd_jmp_buf_reg_offset[] =
+{
+  -1,				/* %eax */
+  -1,				/* %ecx */
+  -1,				/* %edx */
+  1 * 4,			/* %ebx */
+  2 * 4,			/* %esp */
+  3 * 4,			/* %ebp */
+  4 * 4,			/* %esi */
+  5 * 4,			/* %edi */
+  0 * 4				/* %eip */
+};
+
+/* Get XSAVE extended state xcr0 from core dump.  */
+
+uint64_t
+i386fbsd_core_read_xcr0 (bfd *abfd)
+{
+  asection *xstate = bfd_get_section_by_name (abfd, ".reg-xstate");
+  uint64_t xcr0;
+
+  if (xstate)
+    {
+      size_t size = bfd_section_size (abfd, xstate);
+
+      /* Check extended state size.  */
+      if (size < X86_XSTATE_AVX_SIZE)
+	xcr0 = X86_XSTATE_SSE_MASK;
+      else
+	{
+	  char contents[8];
+
+	  if (! bfd_get_section_contents (abfd, xstate, contents,
+					  I386_FBSD_XSAVE_XCR0_OFFSET,
+					  8))
+	    {
+	      warning (_("Couldn't read `xcr0' bytes from "
+			 "`.reg-xstate' section in core file."));
+	      return 0;
+	    }
+
+	  xcr0 = bfd_get_64 (abfd, contents);
+	}
+    }
+  else
+    xcr0 = 0;
+
+  return xcr0;
+}
+
+/* Implement the core_read_description gdbarch method.  */
+
+static const struct target_desc *
+i386fbsd_core_read_description (struct gdbarch *gdbarch,
+				struct target_ops *target,
+				bfd *abfd)
+{
+  return i386_target_description (i386fbsd_core_read_xcr0 (abfd));
+}
+
+/* Similar to i386_supply_fpregset, but use XSAVE extended state.  */
+
+static void
+i386fbsd_supply_xstateregset (const struct regset *regset,
+			      struct regcache *regcache, int regnum,
+			      const void *xstateregs, size_t len)
+{
+  i387_supply_xsave (regcache, regnum, xstateregs);
+}
+
+/* Similar to i386_collect_fpregset, but use XSAVE extended state.  */
+
+static void
+i386fbsd_collect_xstateregset (const struct regset *regset,
+			       const struct regcache *regcache,
+			       int regnum, void *xstateregs, size_t len)
+{
+  i387_collect_xsave (regcache, regnum, xstateregs, 1);
+}
+
+/* Register set definitions.  */
+
+static const struct regset i386fbsd_xstateregset =
+  {
+    NULL,
+    i386fbsd_supply_xstateregset,
+    i386fbsd_collect_xstateregset
+  };
+
+/* Iterate over core file register note sections.  */
+
+static void
+i386fbsd_iterate_over_regset_sections (struct gdbarch *gdbarch,
+				       iterate_over_regset_sections_cb *cb,
+				       void *cb_data,
+				       const struct regcache *regcache)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  cb (".reg", tdep->sizeof_gregset, &i386_gregset, NULL, cb_data);
+  cb (".reg2", tdep->sizeof_fpregset, &i386_fpregset, NULL, cb_data);
+
+  if (tdep->xcr0 & X86_XSTATE_AVX)
+    cb (".reg-xstate", X86_XSTATE_SIZE(tdep->xcr0),
+	&i386fbsd_xstateregset, "XSAVE extended state", cb_data);
+}
+
+static void
+i386fbsd_supply_uthread (struct regcache *regcache,
+			 int regnum, CORE_ADDR addr)
+{
+  gdb_byte buf[4];
+  int i;
+
+  gdb_assert (regnum >= -1);
+
+  for (i = 0; i < ARRAY_SIZE (i386fbsd_jmp_buf_reg_offset); i++)
+    {
+      if (i386fbsd_jmp_buf_reg_offset[i] != -1
+	  && (regnum == -1 || regnum == i))
+	{
+	  read_memory (addr + i386fbsd_jmp_buf_reg_offset[i], buf, 4);
+	  regcache_raw_supply (regcache, i, buf);
+	}
+    }
+}
+
+static void
+i386fbsd_collect_uthread (const struct regcache *regcache,
+			  int regnum, CORE_ADDR addr)
+{
+  gdb_byte buf[4];
+  int i;
+
+  gdb_assert (regnum >= -1);
+
+  for (i = 0; i < ARRAY_SIZE (i386fbsd_jmp_buf_reg_offset); i++)
+    {
+      if (i386fbsd_jmp_buf_reg_offset[i] != -1
+	  && (regnum == -1 || regnum == i))
+	{
+	  regcache_raw_collect (regcache, i, buf);
+	  write_memory (addr + i386fbsd_jmp_buf_reg_offset[i], buf, 4);
+	}
+    }
+}
+
+static void
+i386fbsdaout_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  /* Obviously FreeBSD is BSD-based.  */
+  i386bsd_init_abi (info, gdbarch);
+
+  /* FreeBSD has a different `struct reg', and reserves some space for
+     its FPU emulator in `struct fpreg'.  */
+  tdep->gregset_reg_offset = i386fbsd_r_reg_offset;
+  tdep->gregset_num_regs = ARRAY_SIZE (i386fbsd_r_reg_offset);
+  tdep->sizeof_gregset = 18 * 4;
+  tdep->sizeof_fpregset = 176;
+
+  /* FreeBSD uses -freg-struct-return by default.  */
+  tdep->struct_return = reg_struct_return;
+
+  tdep->sigtramp_p = i386fbsd_sigtramp_p;
+
+  /* FreeBSD uses a different memory layout.  */
+  tdep->sigtramp_start = i386fbsd_sigtramp_start_addr;
+  tdep->sigtramp_end = i386fbsd_sigtramp_end_addr;
+
+  /* FreeBSD has a more complete `struct sigcontext'.  */
+  tdep->sc_reg_offset = i386fbsd_sc_reg_offset;
+  tdep->sc_num_regs = ARRAY_SIZE (i386fbsd_sc_reg_offset);
+
+  /* FreeBSD provides a user-level threads implementation.  */
+  bsd_uthread_set_supply_uthread (gdbarch, i386fbsd_supply_uthread);
+  bsd_uthread_set_collect_uthread (gdbarch, i386fbsd_collect_uthread);
+}
+
+static void
+i386fbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
+{
+  /* It's almost identical to FreeBSD a.out.  */
+  i386fbsdaout_init_abi (info, gdbarch);
+
+  /* Except that it uses ELF.  */
+  i386_elf_init_abi (info, gdbarch);
+
+  /* FreeBSD ELF uses SVR4-style shared libraries.  */
+  set_solib_svr4_fetch_link_map_offsets
+    (gdbarch, svr4_ilp32_fetch_link_map_offsets);
+}
+
+/* FreeBSD 4.0-RELEASE or later.  */
+
+/* From <machine/reg.h>.  */
+static int i386fbsd4_r_reg_offset[] =
+{
+  10 * 4, 9 * 4, 8 * 4, 7 * 4,	/* %eax, %ecx, %edx, %ebx */
+  16 * 4, 5 * 4,		/* %esp, %ebp */
+  4 * 4, 3 * 4,			/* %esi, %edi */
+  13 * 4, 15 * 4,		/* %eip, %eflags */
+  14 * 4, 17 * 4,		/* %cs, %ss */
+  2 * 4, 1 * 4, 0 * 4, 18 * 4	/* %ds, %es, %fs, %gs */
+};
+
+/* From <machine/signal.h>.  */
+int i386fbsd4_sc_reg_offset[] =
+{
+  20 + 11 * 4,			/* %eax */
+  20 + 10 * 4,			/* %ecx */
+  20 + 9 * 4,			/* %edx */
+  20 + 8 * 4,			/* %ebx */
+  20 + 17 * 4,			/* %esp */
+  20 + 6 * 4,			/* %ebp */
+  20 + 5 * 4,			/* %esi */
+  20 + 4 * 4,			/* %edi */
+  20 + 14 * 4,			/* %eip */
+  20 + 16 * 4,			/* %eflags */
+  20 + 15 * 4,			/* %cs */
+  20 + 18 * 4,			/* %ss */
+  20 + 3 * 4,			/* %ds */
+  20 + 2 * 4,			/* %es */
+  20 + 1 * 4,			/* %fs */
+  20 + 0 * 4			/* %gs */
+};
+
+static void
+i386fbsd4_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  /* Generic FreeBSD support. */
+  fbsd_init_abi (info, gdbarch);
+
+  /* Inherit stuff from older releases.  We assume that FreeBSD
+     4.0-RELEASE always uses ELF.  */
+  i386fbsd_init_abi (info, gdbarch);
+
+  /* FreeBSD 4.0 introduced a new `struct reg'.  */
+  tdep->gregset_reg_offset = i386fbsd4_r_reg_offset;
+  tdep->gregset_num_regs = ARRAY_SIZE (i386fbsd4_r_reg_offset);
+  tdep->sizeof_gregset = 19 * 4;
+
+  /* FreeBSD 4.0 introduced a new `struct sigcontext'.  */
+  tdep->sc_reg_offset = i386fbsd4_sc_reg_offset;
+  tdep->sc_num_regs = ARRAY_SIZE (i386fbsd4_sc_reg_offset);
+
+  tdep->xsave_xcr0_offset = I386_FBSD_XSAVE_XCR0_OFFSET;
+
+  /* Iterate over core file register note sections.  */
+  set_gdbarch_iterate_over_regset_sections
+    (gdbarch, i386fbsd_iterate_over_regset_sections);
+
+  set_gdbarch_core_read_description (gdbarch,
+				     i386fbsd_core_read_description);
+}
+
+
+/* Provide a prototype to silence -Wmissing-prototypes.  */
+void _initialize_i386fbsd_tdep (void);
+
+void
+_initialize_i386fbsd_tdep (void)
+{
+  gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_FREEBSD_AOUT,
+			  i386fbsdaout_init_abi);
+  gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_FREEBSD_ELF,
+			  i386fbsd4_init_abi);
+}
diff --git a/contrib/gdb-7/gdb/fbsd_ref/i386fbsd-tdep.h b/contrib/gdb-7/gdb/fbsd_ref/i386fbsd-tdep.h
new file mode 100644
index 0000000000..f1813e1d54
--- /dev/null
+++ b/contrib/gdb-7/gdb/fbsd_ref/i386fbsd-tdep.h
@@ -0,0 +1,31 @@
+/* Target-dependent code for FreeBSD x86.
+
+   Copyright (C) 2015-2017 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef I386FBSD_TDEP_H
+#define I386FBSD_TDEP_H
+
+/* Get XSAVE extended state xcr0 from core dump.  */
+extern uint64_t i386fbsd_core_read_xcr0 (bfd *abfd);
+
+/* The format of the XSAVE extended area is determined by hardware.
+   Cores store the XSAVE extended area in a NT_X86_XSTATE note that
+   matches the layout on Linux.  */
+#define I386_FBSD_XSAVE_XCR0_OFFSET 464
+
+#endif /* i386fbsd-tdep.h */
-- 
2.22.0

