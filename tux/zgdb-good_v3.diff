diff --git a/devel/gdb-good/Makefile b/devel/gdb-good/Makefile
new file mode 100644
index 00000000000..35e89decef7
--- /dev/null
+++ b/devel/gdb-good/Makefile
@@ -0,0 +1,119 @@
+# Created by: Steven Kreuzer <skreuzer@FreeBSD.org>
+# $FreeBSD$
+
+PORTNAME=	gdb
+PKGNAMESUFFIX=	-good
+PORTVERSION=	7.12.1
+PORTREVISION=	2
+CATEGORIES=	devel
+MASTER_SITES=	GNU
+
+MAINTAINER=	luca.pizzamiglio@gmail.com
+COMMENT=	GNU GDB of newer version than comes with the system
+
+LICENSE=	GPLv3
+
+USES=		cpe iconv gmake libtool tar:xz
+USE_CSTD=	gnu89
+CPE_VENDOR=	gnu
+GNU_CONFIGURE=	yes
+CONFIGURE_ENV=	CONFIGURED_M4=m4 CONFIGURED_BISON=byacc
+CONFIGURE_ARGS=	--program-suffix=${PORTVERSION:S/.//g} \
+		--enable-64-bit-bfd \
+		--with-gdb-datadir=${PREFIX}/share/gdb${PORTVERSION:S/.//g} \
+		--with-separate-debug-dir=/usr/lib/debug \
+		${ICONV_CONFIGURE_ARG} \
+		--without-libunwind-ia64 --without-python --without-expat --disable-nls
+CFLAGS:=	${CFLAGS:C/ +$//}	# blanks at EOL creep in sometimes
+CFLAGS+=	-DRL_NO_COMPAT -Wno-unused-function -Wno-unused-variable -Wno-implicit-fallthrough
+EXCLUDE=	dejagnu expect sim texinfo intl
+EXTRACT_AFTER_ARGS=	${EXCLUDE:S/^/--exclude /}
+EXTRA_PATCHES=	${FILESDIR}/commit-387360daf9 \
+		${FILESDIR}/commit-b268007c68
+
+VER=		${PORTVERSION:S/.//g}
+PLIST_SUB=	VER=${VER}
+
+OPTIONS_DEFINE=	DEBUG GDB_LINK KGDB TUI NATIVE EXPAT
+
+#OPTIONS_DEFAULT=	GDB_LINK TUI PORT_READLINE
+OPTIONS_DEFAULT=	TUI BUNDLED_READLINE NATIVE KGDB #EXPAT
+
+OPTIONS_SINGLE=	READLINE
+OPTIONS_SINGLE_READLINE=	BUNDLED_READLINE PORT_READLINE
+
+GDB_LINK_DESC=		Create ${PREFIX}/bin/gdb symlink
+KGDB_DESC=		Kernel Debugging Support
+BUNDLED_READLINE_DESC=	from gdb distfile
+PORT_READLINE_DESC=	from devel/readline port
+TUI_DESC=		Text User Interface enabled
+NATIVE_DESC=		Build only native target support
+EXPAT_DESC=		Some XML shit
+
+OPTIONS_SUB=	yes
+
+BUNDLED_READLINE_CONFIGURE_OFF=	--with-system-readline
+DEBUG_CFLAGS=		-g
+PORT_READLINE_USES=	readline:port
+TUI_CONFIGURE_ENABLE=	tui
+TUI_USES=		ncurses
+EXPAT_LIB_DEPENDS=	libexpat.so:textproc/expat2
+EXPAT_CONFIGURE_ON=	--with-expat=yes --with-libexpat-prefix=${LOCALBASE}
+NATIVE_CONFIGURE_OFF=	--enable-targets=all
+
+BUILD_DEPENDS+=		runtest:misc/dejagnu
+
+.include <bsd.port.pre.mk>
+
+.if ! ${PORT_OPTIONS:MBUNDLED_READLINE}
+EXCLUDE+=	readline
+.endif
+
+# Wow c++ smth.c too on gdb, gcc wasn't enough? throw helpers for c-- and try to kill it
+#CFLAGS+=	-D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS
+CONFIGURE_ARGS+=	--disable-build-with-cxx
+
+post-patch:
+	@${REINPLACE_CMD} -e 's|$$| [GDB v${PORTVERSION} for ${OPSYS}]|' \
+		${WRKSRC}/gdb/version.in
+
+post-patch-KGDB-on:
+	@${CP} -r ${FILESDIR}/kgdb/*.[ch] ${WRKSRC}/gdb/
+	@${PATCH} -d ${PATCH_WRKSRC} ${PATCH_ARGS} < ${FILESDIR}/extrapatch-kgdb
+
+do-install:
+	${INSTALL_PROGRAM} ${WRKSRC}/gdb/gdb \
+		${STAGEDIR}${PREFIX}/bin/gdb${VER}
+	${INSTALL_MAN} ${WRKSRC}/gdb/doc/gdb.1 \
+		${STAGEDIR}${MAN1PREFIX}/man/man1/gdb${VER}.1
+	(cd ${WRKSRC}/gdb/data-directory ; \
+		${SETENV} ${MAKE_ENV} ${MAKE_CMD} ${MAKE_ARGS} install-syscalls )
+
+do-install-KGDB-on:
+	${INSTALL_PROGRAM} ${WRKSRC}/gdb/kgdb \
+		${STAGEDIR}${PREFIX}/bin/kgdb${VER}
+	${INSTALL_MAN} ${FILESDIR}/kgdb/kgdb.1 \
+		${STAGEDIR}${MAN1PREFIX}/man/man1/kgdb${VER}.1
+
+do-install-TUI-on:
+	${LN} -sf gdb${VER} ${STAGEDIR}${PREFIX}/bin/gdbtui${VER}
+
+do-install-GDB_LINK-on:
+	${LN} -sf gdb${VER} ${STAGEDIR}${PREFIX}/bin/gdb
+.if ${PORT_OPTIONS:MKGDB}
+	${LN} -sf kgdb${VER} ${STAGEDIR}${PREFIX}/bin/kgdb
+.endif
+
+dfly-patch:
+	${CP} ${DFLY_FILESDIR}/dfly64.mh ${WRKSRC}/gdb/config/i386/
+	${CP} ${DFLY_FILESDIR}/dfly-nat.* ${WRKSRC}/gdb/
+	${CP} ${DFLY_FILESDIR}/i386* ${WRKSRC}/gdb/
+	${CP} ${DFLY_FILESDIR}/amd64* ${WRKSRC}/gdb/
+.if ${PORT_OPTIONS:MKGDB}
+	${PATCH} -d ${PATCH_WRKSRC} ${PATCH_ARGS} < ${DFLY_FILESDIR}/extrapatch-kgdb
+.endif
+.if ${PORT_OPTIONS:MNATIVE}
+	${PATCH} -d ${PATCH_WRKSRC} ${PATCH_ARGS} < ${DFLY_FILESDIR}/extrapatch-native
+.endif
+
+.include <bsd.port.post.mk>
diff --git a/devel/gdb-good/Makefile.DragonFly b/devel/gdb-good/Makefile.DragonFly
new file mode 100644
index 00000000000..ce6a64f7f98
--- /dev/null
+++ b/devel/gdb-good/Makefile.DragonFly
@@ -0,0 +1 @@
+#MAKE_JOBS_UNSAFE=yes
diff --git a/devel/gdb-good/distinfo b/devel/gdb-good/distinfo
new file mode 100644
index 00000000000..2e2fc98cb05
--- /dev/null
+++ b/devel/gdb-good/distinfo
@@ -0,0 +1,3 @@
+TIMESTAMP = 1485162707
+SHA256 (gdb-7.12.1.tar.xz) = 4607680b973d3ec92c30ad029f1b7dbde3876869e6b3a117d8a7e90081113186
+SIZE (gdb-7.12.1.tar.xz) = 19225392
diff --git a/devel/gdb-good/dragonfly/amd64dfly-nat.c b/devel/gdb-good/dragonfly/amd64dfly-nat.c
new file mode 100644
index 00000000000..f0574034996
--- /dev/null
+++ b/devel/gdb-good/dragonfly/amd64dfly-nat.c
@@ -0,0 +1,334 @@
+/* Native-dependent code for DragonFly/amd64.
+
+   Copyright (C) 2003-2016 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "inferior.h"
+#include "regcache.h"
+#include "target.h"
+#include "gregset.h"
+
+#include "gdb_assert.h"
+#include <signal.h>
+#include <stddef.h>
+#include <sys/types.h>
+#include <sys/procfs.h>
+#include <sys/ptrace.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <machine/reg.h>
+#include <machine/segments.h>
+
+#include "dfly-nat.h"
+#include "amd64-tdep.h"
+#include "amd64-nat.h"
+#include "x86bsd-nat.h"
+#include "x86-nat.h"
+
+
+/* Offset in `struct reg' where MEMBER is stored.  */
+#define REG_OFFSET(member) offsetof (struct reg, member)
+
+/* At amd64dfly64_r_reg_offset[REGNUM] you'll find the offset in
+   `struct reg' location where the GDB register REGNUM is stored.
+   Unsupported registers are marked with `-1'.  */
+static int amd64dfly64_r_reg_offset[] =
+{
+  REG_OFFSET (r_rax),
+  REG_OFFSET (r_rbx),
+  REG_OFFSET (r_rcx),
+  REG_OFFSET (r_rdx),
+  REG_OFFSET (r_rsi),
+  REG_OFFSET (r_rdi),
+  REG_OFFSET (r_rbp),
+  REG_OFFSET (r_rsp),
+  REG_OFFSET (r_r8),
+  REG_OFFSET (r_r9),
+  REG_OFFSET (r_r10),
+  REG_OFFSET (r_r11),
+  REG_OFFSET (r_r12),
+  REG_OFFSET (r_r13),
+  REG_OFFSET (r_r14),
+  REG_OFFSET (r_r15),
+  REG_OFFSET (r_rip),
+  REG_OFFSET (r_rflags),
+  REG_OFFSET (r_cs),
+  REG_OFFSET (r_ss),
+  -1,
+  -1,
+  -1,
+  -1
+};
+
+
+/* Mapping between the general-purpose registers in DragonFly/amd64
+   `struct reg' format and GDB's register cache layout for
+   DragonFly/x86.
+
+   Note that most DragonFly/amd64 registers are 64-bit, while the
+   DragonFly/x86 registers are all 32-bit, but since we're
+   little-endian we get away with that.  */
+
+/* From <machine/reg.h>.  */
+static int amd64dfly32_r_reg_offset[I386_NUM_GREGS] =
+{
+  14 * 8, 13 * 8,		/* %eax, %ecx */
+  12 * 8, 11 * 8,		/* %edx, %ebx */
+  20 * 8, 10 * 8,		/* %esp, %ebp */
+  9 * 8, 8 * 8,			/* %esi, %edi */
+  17 * 8, 19 * 8,		/* %eip, %eflags */
+  18 * 8, 21 * 8,		/* %cs, %ss */
+  -1, -1, -1, -1		/* %ds, %es, %fs, %gs */
+};
+
+
+#ifdef DFLY_PCB_SUPPLY
+/* Transfering the registers between GDB, inferiors and core files.  */
+
+/* Fill GDB's register array with the general-purpose register values
+   in *GREGSETP.  */
+
+void
+supply_gregset (struct regcache *regcache, const gregset_t *gregsetp)
+{
+  amd64_supply_native_gregset (regcache, gregsetp, -1);
+}
+
+/* Fill register REGNUM (if it is a general-purpose register) in
+   *GREGSETPS with the value in GDB's register array.  If REGNUM is -1,
+   do this for all registers.  */
+
+void
+fill_gregset (const struct regcache *regcache, gdb_gregset_t *gregsetp, int regnum)
+{
+  amd64_collect_native_gregset (regcache, gregsetp, regnum);
+}
+
+/* Fill GDB's register array with the floating-point register values
+   in *FPREGSETP.  */
+
+void
+supply_fpregset (struct regcache *regcache, const fpregset_t *fpregsetp)
+{
+  amd64_supply_fxsave (regcache, -1, fpregsetp);
+}
+
+/* Fill register REGNUM (if it is a floating-point register) in
+   *FPREGSETP with the value in GDB's register array.  If REGNUM is -1,
+   do this for all registers.  */
+
+void
+fill_fpregset (const struct regcache *regcache, gdb_fpregset_t *fpregsetp, int regnum)
+{
+  amd64_collect_fxsave (regcache, regnum, fpregsetp);
+}
+
+/* Support for debugging kernel virtual memory images.  */
+
+#include <sys/types.h>
+#include <machine/pcb.h>
+#include <osreldate.h>
+
+#include "bsd-kvm.h"
+
+static int
+amd64dfly_supply_pcb (struct regcache *regcache, struct pcb *pcb)
+{
+  /* The following is true for FreeBSD 5.2:
+
+     The pcb contains %rip, %rbx, %rsp, %rbp, %r12, %r13, %r14, %r15,
+     %ds, %es, %fs and %gs.  This accounts for all callee-saved
+     registers specified by the psABI and then some.  Here %esp
+     contains the stack pointer at the point just after the call to
+     cpu_switch().  From this information we reconstruct the register
+     state as it would like when we just returned from cpu_switch().  */
+
+  /* The stack pointer shouldn't be zero.  */
+  if (pcb->pcb_rsp == 0)
+    return 0;
+
+  pcb->pcb_rsp += 8;
+  regcache_raw_supply (regcache, AMD64_RIP_REGNUM, &pcb->pcb_rip);
+  regcache_raw_supply (regcache, AMD64_RBX_REGNUM, &pcb->pcb_rbx);
+  regcache_raw_supply (regcache, AMD64_RSP_REGNUM, &pcb->pcb_rsp);
+  regcache_raw_supply (regcache, AMD64_RBP_REGNUM, &pcb->pcb_rbp);
+  regcache_raw_supply (regcache, 12, &pcb->pcb_r12);
+  regcache_raw_supply (regcache, 13, &pcb->pcb_r13);
+  regcache_raw_supply (regcache, 14, &pcb->pcb_r14);
+  regcache_raw_supply (regcache, 15, &pcb->pcb_r15);
+#if 0 && (__FreeBSD_version < 800075) && (__FreeBSD_kernel_version < 800075)
+  /* struct pcb provides the pcb_ds/pcb_es/pcb_fs/pcb_gs fields only
+     up until __FreeBSD_version 800074: The removal of these fields
+     occurred on 2009-04-01 while the __FreeBSD_version number was
+     bumped to 800075 on 2009-04-06.  So 800075 is the closest version
+     number where we should not try to access these fields.  */
+  regcache_raw_supply (regcache, AMD64_DS_REGNUM, &pcb->pcb_ds);
+  regcache_raw_supply (regcache, AMD64_ES_REGNUM, &pcb->pcb_es);
+  regcache_raw_supply (regcache, AMD64_FS_REGNUM, &pcb->pcb_fs);
+  regcache_raw_supply (regcache, AMD64_GS_REGNUM, &pcb->pcb_gs);
+#endif
+
+  return 1;
+}
+#endif /* DFLY_PCB_SUPPLY */
+
+
+/* Implement the to_read_description method.  */
+
+static const struct target_desc *
+amd64dfly_read_description (struct target_ops *ops)
+{
+#ifdef PT_GETXSTATE_INFO
+  static int xsave_probed;
+  static uint64_t xcr0;
+#endif
+  struct reg regs;
+  int is64;
+
+  if (ptrace (PT_GETREGS, ptid_get_pid (inferior_ptid),
+	      (PTRACE_TYPE_ARG3) &regs, 0) == -1)
+    perror_with_name (_("Couldn't get registers"));
+  is64 = (regs.r_cs == GSEL (GUCODE_SEL, SEL_UPL));
+#ifdef PT_GETXSTATE_INFO
+  if (!xsave_probed)
+    {
+      struct ptrace_xstate_info info;
+
+      if (ptrace (PT_GETXSTATE_INFO, ptid_get_pid (inferior_ptid),
+		  (PTRACE_TYPE_ARG3) &info, sizeof (info)) == 0)
+	{
+	  x86bsd_xsave_len = info.xsave_len;
+	  xcr0 = info.xsave_mask;
+	}
+      xsave_probed = 1;
+    }
+
+  if (x86bsd_xsave_len != 0)
+    {
+      if (is64)
+	return amd64_target_description (xcr0);
+      else
+	return i386_target_description (xcr0);
+    }
+#endif
+  if (is64)
+    return tdesc_amd64;
+  else
+    return tdesc_i386;
+}
+
+/* Provide a prototype to silence -Wmissing-prototypes.  */
+void _initialize_amd64dfly_nat (void);
+
+void
+_initialize_amd64dfly_nat (void)
+{
+  struct target_ops *t;
+  int offset;
+
+  amd64_native_gregset32_reg_offset = amd64dfly32_r_reg_offset;
+  amd64_native_gregset64_reg_offset = amd64dfly64_r_reg_offset;
+
+  /* Add some extra features to the common *BSD/x86 target.  */
+  t = amd64bsd_target ();
+  t->to_read_description = amd64dfly_read_description;
+
+  dfly_nat_add_target (t);
+
+#ifdef DFLY_PCB_SUPPLY
+  /* Support debugging kernel virtual memory images.  */
+  bsd_kvm_add_target (amd64dfly_supply_pcb);
+#endif
+
+  /* To support the recognition of signal handlers, i386bsd-tdep.c
+     hardcodes some constants.  Inclusion of this file means that we
+     are compiling a native debugger, which means that we can use the
+     system header files and sysctl(3) to get at the relevant
+     information.  */
+
+#define SC_REG_OFFSET amd64dfly_sc_reg_offset
+
+  /* We only check the program counter, stack pointer and frame
+     pointer since these members of `struct sigcontext' are essential
+     for providing backtraces.  */
+
+#define SC_RIP_OFFSET SC_REG_OFFSET[AMD64_RIP_REGNUM]
+#define SC_RSP_OFFSET SC_REG_OFFSET[AMD64_RSP_REGNUM]
+#define SC_RBP_OFFSET SC_REG_OFFSET[AMD64_RBP_REGNUM]
+
+  /* Override the default value for the offset of the program counter
+     in the sigcontext structure.  */
+  offset = offsetof (struct sigcontext, sc_rip);
+
+  if (SC_RIP_OFFSET != offset)
+    {
+      warning (_("\
+offsetof (struct sigcontext, sc_rip) yields %d instead of %d.\n\
+Please report this to <bug-gdb@gnu.org>."),
+	       offset, SC_RIP_OFFSET);
+    }
+
+  SC_RIP_OFFSET = offset;
+
+  /* Likewise for the stack pointer.  */
+  offset = offsetof (struct sigcontext, sc_rsp);
+
+  if (SC_RSP_OFFSET != offset)
+    {
+      warning (_("\
+offsetof (struct sigcontext, sc_rsp) yields %d instead of %d.\n\
+Please report this to <bug-gdb@gnu.org>."),
+	       offset, SC_RSP_OFFSET);
+    }
+
+  SC_RSP_OFFSET = offset;
+
+  /* And the frame pointer.  */
+  offset = offsetof (struct sigcontext, sc_rbp);
+
+  if (SC_RBP_OFFSET != offset)
+    {
+      warning (_("\
+offsetof (struct sigcontext, sc_rbp) yields %d instead of %d.\n\
+Please report this to <bug-gdb@gnu.org>."),
+	       offset, SC_RBP_OFFSET);
+    }
+
+  SC_RBP_OFFSET = offset;
+
+  /* DragonFly provides a kern.ps_strings sysctl that we can use to
+     locate the sigtramp.  That way we can still recognize a sigtramp
+     if its location is changed in a new kernel.  Of course this is
+     still based on the assumption that the sigtramp is placed
+     directly under the location where the program arguments and
+     environment can be found.  */
+  {
+    int mib[2];
+    long ps_strings;
+    size_t len;
+
+    mib[0] = CTL_KERN;
+    mib[1] = KERN_PS_STRINGS;
+    len = sizeof (ps_strings);
+    if (sysctl (mib, 2, &ps_strings, &len, NULL, 0) == 0)
+      {
+	amd64dfly_sigtramp_start_addr = ps_strings - 32;
+	amd64dfly_sigtramp_end_addr = ps_strings;
+      }
+  }
+}
diff --git a/devel/gdb-good/dragonfly/amd64dfly-tdep.c b/devel/gdb-good/dragonfly/amd64dfly-tdep.c
new file mode 100644
index 00000000000..6fb9b213286
--- /dev/null
+++ b/devel/gdb-good/dragonfly/amd64dfly-tdep.c
@@ -0,0 +1,176 @@
+/* Target-dependent code for DragonFly/amd64.
+
+   Copyright (C) 2003-2013 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "arch-utils.h"
+#include "frame.h"
+#include "gdbcore.h"
+#include "regcache.h"
+#include "osabi.h"
+
+#include "gdb_assert.h"
+#include <string.h>
+
+#include "amd64-tdep.h"
+#include "solib-svr4.h"
+
+/* Support for signal handlers.  */
+
+/* Assuming THIS_FRAME is for a BSD sigtramp routine, return the
+   address of the associated sigcontext structure.  */
+
+static CORE_ADDR
+amd64dfly_sigcontext_addr (struct frame_info *this_frame)
+{
+  struct gdbarch *gdbarch = get_frame_arch (this_frame);
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+  CORE_ADDR sp;
+  gdb_byte buf[8];
+
+  /* The `struct sigcontext' (which really is an `ucontext_t' on
+     DragonFly/amd64) lives at a fixed offset in the signal frame.  See
+     <machine/sigframe.h>.  */
+  get_frame_register (this_frame, AMD64_RSP_REGNUM, buf);
+  sp = extract_unsigned_integer (buf, 8, byte_order);
+  return sp + 16;
+}
+
+/* Mapping between the general-purpose registers in `struct reg'
+   format and GDB's register cache layout.
+
+   Note that some registers are 32-bit, but since we're little-endian
+   we get away with that.  */
+
+/* From <machine/reg.h>.  */
+static int amd64dfly_r_reg_offset[] =
+{
+  6 * 8,			/* %rax */
+  7 * 8,			/* %rbx */
+  3 * 8,			/* %rcx */
+  2 * 8,			/* %rdx */
+  1 * 8,			/* %rsi */
+  0 * 8,			/* %rdi */
+  8 * 8,			/* %rbp */
+  23 * 8,			/* %rsp */
+  4 * 8,			/* %r8 ... */
+  5 * 8,
+  9 * 8,
+  10 * 8,
+  11 * 8,
+  12 * 8,
+  13 * 8,
+  14 * 8,			/* ... %r15 */
+  20 * 8,			/* %rip */
+  22 * 8,			/* %eflags */
+  21 * 8,			/* %cs */
+  24 * 8,			/* %ss */
+  -1,				/* %ds */
+  -1,				/* %es */
+  -1,				/* %fs */
+  -1				/* %gs */
+};
+
+/* Location of the signal trampoline.  */
+CORE_ADDR amd64dfly_sigtramp_start_addr = 0x7fffffffffc0ULL;
+CORE_ADDR amd64dfly_sigtramp_end_addr = 0x7fffffffffe0ULL;
+
+/* From <machine/signal.h>.  */
+int amd64dfly_sc_reg_offset[] =
+{
+  24 + 6 * 8,			/* %rax */
+  24 + 7 * 8,			/* %rbx */
+  24 + 3 * 8,			/* %rcx */
+  24 + 2 * 8,			/* %rdx */
+  24 + 1 * 8,			/* %rsi */
+  24 + 0 * 8,			/* %rdi */
+  24 + 8 * 8,			/* %rbp */
+  24 + 23 * 8,			/* %rsp */
+  24 + 4 * 8,			/* %r8 ... */
+  24 + 5 * 8,
+  24 + 9 * 8,
+  24 + 10 * 8,
+  24 + 11 * 8,
+  24 + 12 * 8,
+  24 + 13 * 8,
+  24 + 14 * 8,			/* ... %r15 */
+  24 + 20 * 8,			/* %rip */
+  24 + 22 * 8,			/* %eflags */
+  24 + 21 * 8,			/* %cs */
+  24 + 24 * 8,			/* %ss */
+  -1,				/* %ds */
+  -1,				/* %es */
+  -1,				/* %fs */
+  -1				/* %gs */
+};
+
+/* From /usr/src/lib/libc/amd64/gen/_setjmp.S.  */
+static int amd64dfly_jmp_buf_reg_offset[] =
+{
+  -1,				/* %rax */
+  1 * 8,			/* %rbx */
+  -1,				/* %rcx */
+  -1,				/* %rdx */
+  -1,				/* %rsi */
+  -1,				/* %rdi */
+  3 * 8,			/* %rbp */
+  2 * 8,			/* %rsp */
+  -1,				/* %r8 ... */
+  -1,
+  -1,
+  -1,				/* ... %r11 */
+  4 * 8,			/* %r12 ... */
+  5 * 8,
+  6 * 8,
+  7 * 8,			/* ... %r15 */
+  0 * 8				/* %rip */
+};
+
+static void
+amd64dfly_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  i386bsd_init_abi (info, gdbarch);
+
+  tdep->gregset_reg_offset = amd64dfly_r_reg_offset;
+  tdep->gregset_num_regs = ARRAY_SIZE (amd64dfly_r_reg_offset);
+  tdep->sizeof_gregset = 25 * 8;
+
+  amd64_init_abi (info, gdbarch);
+
+  tdep->sigtramp_start = amd64dfly_sigtramp_start_addr;
+  tdep->sigtramp_end = amd64dfly_sigtramp_end_addr;
+  tdep->sigcontext_addr = amd64dfly_sigcontext_addr;
+  tdep->sc_reg_offset = amd64dfly_sc_reg_offset;
+  tdep->sc_num_regs = ARRAY_SIZE (amd64dfly_sc_reg_offset);
+
+  set_solib_svr4_fetch_link_map_offsets
+    (gdbarch, svr4_lp64_fetch_link_map_offsets);
+}
+
+
+/* Provide a prototype to silence -Wmissing-prototypes.  */
+void _initialize_amd64dfly_tdep (void);
+
+void
+_initialize_amd64dfly_tdep (void)
+{
+  gdbarch_register_osabi (bfd_arch_i386, bfd_mach_x86_64,
+			  GDB_OSABI_DRAGONFLY, amd64dfly_init_abi);
+}
diff --git a/devel/gdb-good/dragonfly/dfly-nat.c b/devel/gdb-good/dragonfly/dfly-nat.c
new file mode 100644
index 00000000000..f64b6e29ce7
--- /dev/null
+++ b/devel/gdb-good/dragonfly/dfly-nat.c
@@ -0,0 +1,166 @@
+/* Native-dependent code for DragonFly.
+
+   Copyright (C) 2002-2016 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "gdbcore.h"
+#include "inferior.h"
+#include "regcache.h"
+#include "regset.h"
+#include "gdbcmd.h"
+#include "gdbthread.h"
+#include "gdb_wait.h"
+#include <sys/types.h>
+#include <sys/procfs.h>
+#include <sys/ptrace.h>
+#include <sys/sysctl.h>
+#ifdef HAVE_KINFO_GETVMMAP
+#include <sys/user.h>
+#include <libutil.h>
+#endif
+
+#include "elf-bfd.h"
+#include "dfly-nat.h"
+
+/* Return the name of a file that can be opened to get the symbols for
+   the child process identified by PID.  */
+
+static char *
+dfly_pid_to_exec_file (struct target_ops *self, int pid)
+{
+  ssize_t len;
+  static char buf[PATH_MAX];
+  char name[PATH_MAX];
+
+#ifdef KERN_PROC_PATHNAME
+  size_t buflen;
+  int mib[4];
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PROC;
+  mib[2] = KERN_PROC_PATHNAME;
+  mib[3] = pid;
+  buflen = sizeof buf;
+  if (sysctl (mib, 4, buf, &buflen, NULL, 0) == 0)
+    return buf;
+#endif
+
+  xsnprintf (name, PATH_MAX, "/proc/%d/exe", pid);
+  len = readlink (name, buf, PATH_MAX - 1);
+  if (len != -1)
+    {
+      buf[len] = '\0';
+      return buf;
+    }
+
+  return NULL;
+}
+
+static int
+dfly_read_mapping (FILE *mapfile, unsigned long *start, unsigned long *end,
+		   char *protection)
+{
+  /* FreeBSD 5.1-RELEASE uses a 256-byte buffer.  */
+  char buf[256];
+  int resident, privateresident;
+  unsigned long obj;
+  int ret = EOF;
+
+  /* As of FreeBSD 5.0-RELEASE, the layout is described in
+     /usr/src/sys/fs/procfs/procfs_map.c.  Somewhere in 5.1-CURRENT a
+     new column was added to the procfs map.  Therefore we can't use
+     fscanf since we need to support older releases too.  */
+  if (fgets (buf, sizeof buf, mapfile) != NULL)
+    ret = sscanf (buf, "%lx %lx %d %d %lx %s", start, end,
+		  &resident, &privateresident, &obj, protection);
+
+  return (ret != 0 && ret != EOF);
+}
+
+/* Iterate over all the memory regions in the current inferior,
+   calling FUNC for each memory region.  OBFD is passed as the last
+   argument to FUNC.  */
+
+static int
+dfly_find_memory_regions (struct target_ops *self,
+			  find_memory_region_ftype func, void *obfd)
+{
+  pid_t pid = ptid_get_pid (inferior_ptid);
+  char *mapfilename;
+  FILE *mapfile;
+  unsigned long start, end, size;
+  char protection[4];
+  int read, write, exec;
+  struct cleanup *cleanup;
+
+  mapfilename = xstrprintf ("/proc/%ld/map", (long) pid);
+  cleanup = make_cleanup (xfree, mapfilename);
+  mapfile = fopen (mapfilename, "r");
+  if (mapfile == NULL)
+    error (_("Couldn't open %s."), mapfilename);
+  make_cleanup_fclose (mapfile);
+
+  if (info_verbose)
+    fprintf_filtered (gdb_stdout, 
+		      "Reading memory regions from %s\n", mapfilename);
+
+  /* Now iterate until end-of-file.  */
+  while (dfly_read_mapping (mapfile, &start, &end, &protection[0]))
+    {
+      size = end - start;
+
+      read = (strchr (protection, 'r') != 0);
+      write = (strchr (protection, 'w') != 0);
+      exec = (strchr (protection, 'x') != 0);
+
+      if (info_verbose)
+	{
+	  fprintf_filtered (gdb_stdout, 
+			    "Save segment, %ld bytes at %s (%c%c%c)\n",
+			    size, paddress (target_gdbarch (), start),
+			    read ? 'r' : '-',
+			    write ? 'w' : '-',
+			    exec ? 'x' : '-');
+	}
+
+      /* Invoke the callback function to create the corefile segment.
+	 Pass MODIFIED as true, we do not know the real modification state.  */
+      func (start, size, read, write, exec, 1, obfd);
+    }
+
+  do_cleanups (cleanup);
+  return 0;
+}
+
+void
+dfly_nat_add_target (struct target_ops *t)
+{
+  t->to_pid_to_exec_file = dfly_pid_to_exec_file;
+  t->to_find_memory_regions = dfly_find_memory_regions;
+  /* XXX: thread vfork support */
+  add_target (t);
+}
+
+/* Provide a prototype to silence -Wmissing-prototypes.  */
+extern initialize_file_ftype _initialize_dfly_nat;
+
+void
+_initialize_dfly_nat (void)
+{
+/* XXX: todo add_setshow_boolean_cmd() */
+}
diff --git a/devel/gdb-good/dragonfly/dfly-nat.h b/devel/gdb-good/dragonfly/dfly-nat.h
new file mode 100644
index 00000000000..9212cea2b50
--- /dev/null
+++ b/devel/gdb-good/dragonfly/dfly-nat.h
@@ -0,0 +1,27 @@
+/* Native-dependent code for DragonFly.
+
+   Copyright (C) 2004-2015 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef DFLY_NAT_H
+#define DFLY_NAT_H
+
+/* Register the customized DragonFly target.  This should be used
+   instead of calling add_target directly.  */
+extern void dfly_nat_add_target (struct target_ops *);
+
+#endif /* dfly-nat.h */
diff --git a/devel/gdb-good/dragonfly/dfly64.mh b/devel/gdb-good/dragonfly/dfly64.mh
new file mode 100644
index 00000000000..0f29dd5f348
--- /dev/null
+++ b/devel/gdb-good/dragonfly/dfly64.mh
@@ -0,0 +1,6 @@
+# Host: DragonFly/amd64
+NATDEPFILES= fork-child.o inf-ptrace.o \
+	dfly-nat.o amd64-nat.o x86bsd-nat.o amd64bsd-nat.o amd64dfly-nat.o \
+	x86-nat.o x86-dregs.o
+
+LOADLIBES= -lkvm
diff --git a/devel/gdb-good/dragonfly/extrapatch-kgdb b/devel/gdb-good/dragonfly/extrapatch-kgdb
new file mode 100644
index 00000000000..407c21d2261
--- /dev/null
+++ b/devel/gdb-good/dragonfly/extrapatch-kgdb
@@ -0,0 +1,350 @@
+--- gdb/i386fbsd-kern.c.orig	2016-12-19 10:24:53.000000000 +0200
++++ gdb/i386fbsd-kern.c
+@@ -28,7 +28,11 @@
+ __FBSDID("$FreeBSD: head/devel/gdb/files/kgdb/i386fbsd-kern.c 414115 2016-04-27 16:11:53Z jhb $");
+ 
+ #include <sys/param.h>
++#ifdef __DragonFly__
++#include <sys/user.h>
++#else
+ #include <sys/proc.h>
++#endif
+ #ifdef __i386__
+ #include <machine/pcb.h>
+ #include <machine/frame.h>
+--- gdb/amd64fbsd-kern.c.orig	2016-12-19 12:45:07.000000000 +0200
++++ gdb/amd64fbsd-kern.c
+@@ -32,6 +32,9 @@ __FBSDID("$FreeBSD: head/devel/gdb/files
+ #include <machine/pcb.h>
+ #include <machine/frame.h>
+ #endif
++#ifdef __DragonFly__
++#include <machine/segments.h>
++#endif
+ #include <string.h>
+ 
+ #include <defs.h>
+@@ -241,6 +244,7 @@ _initialize_amd64_kgdb_tdep(void)
+ 	    GDB_OSABI_FREEBSD_ELF_KERNEL, amd64fbsd_kernel_init_abi);
+ 
+ #ifdef __amd64__
++#ifndef __DragonFly__ /* XXX */
+ 	gdb_assert(offsetof(struct pcb, pcb_rbx)
+ 		   == amd64fbsd_pcb_offset[AMD64_RBX_REGNUM]);
+ 	gdb_assert(offsetof(struct pcb, pcb_rbp)
+@@ -301,4 +305,5 @@ _initialize_amd64_kgdb_tdep(void)
+ 	gdb_assert(offsetof(struct trapframe, tf_ss)
+ 		   == amd64fbsd_trapframe_offset[AMD64_SS_REGNUM]);
+ #endif
++#endif
+ }
+--- gdb/fbsd-kthr.c.orig	2016-12-19 10:07:48.000000000 +0200
++++ gdb/fbsd-kthr.c
+@@ -28,7 +28,11 @@
+ __FBSDID("$FreeBSD: head/devel/gdb/files/kgdb/fbsd-kthr.c 398712 2015-10-06 18:52:58Z jhb $");
+ 
+ #include <sys/param.h>
++#ifdef __DragonFly__
++#include <sys/user.h>
++#else
+ #include <sys/proc.h>
++#endif
+ #include <stdbool.h>
+ 
+ #include <defs.h>
+@@ -47,10 +51,14 @@ static LONGEST mp_maxid;
+ static struct kthr *first;
+ struct kthr *curkthr;
+ 
++#ifdef __DragonFly__
++static int proc_off_p_pid, proc_off_p_comm, proc_off_p_list, thread_off_td_pcb;
++#else
+ static int proc_off_p_pid, proc_off_p_comm, proc_off_p_list, proc_off_p_threads;
+ static int thread_off_td_tid, thread_off_td_oncpu, thread_off_td_pcb;
+ static int thread_off_td_name, thread_off_td_plist;
+ static int thread_oncpu_size;
++#endif
+ 
+ CORE_ADDR
+ kgdb_lookup(const char *sym)
+@@ -101,14 +109,21 @@ kgdb_thr_add_procs(CORE_ADDR paddr, CORE
+ 	struct type *ptr_type = builtin_type (gdbarch)->builtin_data_ptr;
+ 	enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+ 	struct kthr *kt;
++#ifndef __DragonFly__
++	CORE_ADDR pcb, pnext, tdnext;
++	LONGEST pid;
++#else
+ 	CORE_ADDR pcb, pnext, tdaddr, tdnext;
+ 	ULONGEST oncpu;
+ 	LONGEST pid, tid;
++#endif
+ 
+ 	while (paddr != 0) {
+ 		TRY {
++#ifndef __DragonFly__
+ 			tdaddr = read_memory_typed_address (paddr +
+ 			    proc_off_p_threads, ptr_type);
++#endif
+ 			pid = read_memory_integer (paddr + proc_off_p_pid, 4,
+ 			    byte_order);
+ 			pnext = read_memory_typed_address (paddr +
+@@ -118,15 +133,19 @@ kgdb_thr_add_procs(CORE_ADDR paddr, CORE
+ 		} END_CATCH
+ 		while (tdaddr != 0) {
+ 			TRY {
++#ifndef __DragonFly__
+ 				tid = read_memory_integer (tdaddr +
+ 				    thread_off_td_tid, 4, byte_order);
+ 				oncpu = read_memory_unsigned_integer (tdaddr +
+ 				    thread_off_td_oncpu, thread_oncpu_size,
+ 				    byte_order);
++#endif
+ 				pcb = read_memory_typed_address (tdaddr +
+ 				    thread_off_td_pcb, ptr_type);
++#ifndef __DragonFly__
+ 				tdnext = read_memory_typed_address (tdaddr +
+ 				    thread_off_td_plist, ptr_type);
++#endif
+ 			} CATCH(e, RETURN_MASK_ERROR) {
+ 				break;
+ 			} END_CATCH
+@@ -139,10 +158,14 @@ kgdb_thr_add_procs(CORE_ADDR paddr, CORE
+ 				kt->pcb = cpu_pcb_addr(oncpu);
+ 			else
+ 				kt->pcb = pcb;
++#ifndef __DragonFly__
+ 			kt->tid = tid;
++#endif
+ 			kt->pid = pid;
+ 			kt->paddr = paddr;
++#ifndef __DragonFly__
+ 			kt->cpu = oncpu;
++#endif
+ 			first = kt;
+ 			tdaddr = tdnext;
+ 		}
+@@ -165,7 +188,11 @@ kgdb_thr_init(CORE_ADDR (*cpu_pcb_addr)
+ 		free(kt);
+ 	}
+ 
++#ifdef __DragonFly__
++	addr = kgdb_lookup("_ncpus");
++#else
+ 	addr = kgdb_lookup("allproc");
++#endif
+ 	if (addr == 0)
+ 		return (NULL);
+ 	TRY {
+@@ -174,18 +201,30 @@ kgdb_thr_init(CORE_ADDR (*cpu_pcb_addr)
+ 		return (NULL);
+ 	} END_CATCH
+ 
++#ifdef __DragonFly__
++	dumppcb = kgdb_lookup("_dumppcb");
++#else
+ 	dumppcb = kgdb_lookup("dumppcb");
++#endif
+ 	if (dumppcb == 0)
+ 		return (NULL);
+ 
+ #if 1
+ 	TRY {
++#ifdef __DragonFly__
++		dumptid = parse_and_eval_long("_dumpthread");
++#else
+ 		dumptid = parse_and_eval_long("dumptid");
++#endif
+ 	} CATCH(e, RETURN_MASK_ERROR) {
+ 		dumptid = -1;
+ 	} END_CATCH
+ #else
++#ifdef __DragonFly__
++	addr = kgdb_lookup("_dumpthread");
++#else
+ 	addr = kgdb_lookup("dumptid");
++#endif
+ 	if (addr != 0) {
+ 		TRY {
+ 			dumptid = read_memory_integer (addr, 4, byte_order);
+@@ -209,6 +248,7 @@ kgdb_thr_init(CORE_ADDR (*cpu_pcb_addr)
+ 	 * kernels, try to extract these offsets using debug symbols.  If
+ 	 * that fails, use native values.
+ 	 */
++#ifndef __DragonFly__
+ 	TRY {
+ 		proc_off_p_pid = parse_and_eval_long("proc_off_p_pid");
+ 		proc_off_p_comm = parse_and_eval_long("proc_off_p_comm");
+@@ -221,6 +261,7 @@ kgdb_thr_init(CORE_ADDR (*cpu_pcb_addr)
+ 		thread_off_td_plist = parse_and_eval_long("thread_off_td_plist");
+ 		thread_oncpu_size = 4;
+ 	} CATCH(e, RETURN_MASK_ERROR) {
++#endif
+ 		TRY {
+ 			proc_off_p_pid = parse_and_eval_address(
+ 			    "&((struct proc *)0)->p_pid");
+@@ -228,6 +269,7 @@ kgdb_thr_init(CORE_ADDR (*cpu_pcb_addr)
+ 			    "&((struct proc *)0)->p_comm");
+ 			proc_off_p_list = parse_and_eval_address(
+ 			    "&((struct proc *)0)->p_list");
++#ifndef __DragonFly__
+ 			proc_off_p_threads = parse_and_eval_address(
+ 			    "&((struct proc *)0)->p_threads");
+ 			thread_off_td_tid = parse_and_eval_address(
+@@ -236,26 +278,35 @@ kgdb_thr_init(CORE_ADDR (*cpu_pcb_addr)
+ 			    "&((struct thread *)0)->td_name");
+ 			thread_off_td_oncpu = parse_and_eval_address(
+ 			    "&((struct thread *)0)->td_oncpu");
++#endif
+ 			thread_off_td_pcb = parse_and_eval_address(
+ 			    "&((struct thread *)0)->td_pcb");
++#ifndef __DragonFly__
+ 			thread_off_td_plist = parse_and_eval_address(
+ 			    "&((struct thread *)0)->td_plist");
+ 			thread_oncpu_size = parse_and_eval_long(
+ 			    "sizeof(((struct thread *)0)->td_oncpu)");
++#endif
+ 		} CATCH(e, RETURN_MASK_ERROR) {
+ 			proc_off_p_pid = offsetof(struct proc, p_pid);
+ 			proc_off_p_comm = offsetof(struct proc, p_comm);
+ 			proc_off_p_list = offsetof(struct proc, p_list);
++#ifndef __DragonFly__
+ 			proc_off_p_threads = offsetof(struct proc, p_threads);
+ 			thread_off_td_tid = offsetof(struct thread, td_tid);
+ 			thread_off_td_name = offsetof(struct thread, td_name);
+ 			thread_off_td_oncpu = offsetof(struct thread, td_oncpu);
++#endif
+ 			thread_off_td_pcb = offsetof(struct thread, td_pcb);
++#ifndef __DragonFly__
+ 			thread_off_td_plist = offsetof(struct thread, td_plist);
+ 			thread_oncpu_size =
+ 			    sizeof(((struct thread *)0)->td_oncpu);
++#endif
+ 		} END_CATCH
++#ifndef __DragonFly__
+ 	} END_CATCH
++#endif
+ 
+ 	kgdb_thr_add_procs(paddr, cpu_pcb_addr);
+ 	addr = kgdb_lookup("zombproc");
+@@ -326,7 +377,9 @@ char *
+ kgdb_thr_extra_thread_info(int tid)
+ {
+ 	char comm[MAXCOMLEN + 1];
++#ifndef __DragonFly__
+ 	char td_name[MAXCOMLEN + 1];
++#endif
+ 	struct kthr *kt;
+ 	static char buf[64];
+ 
+@@ -339,12 +392,14 @@ kgdb_thr_extra_thread_info(int tid)
+ 		    sizeof(comm));
+ 		strlcat(buf, ": ", sizeof(buf));
+ 		strlcat(buf, comm, sizeof(buf));
++#ifndef __DragonFly__
+ 		read_memory_string (kt->kaddr + thread_off_td_name, td_name,
+ 		    sizeof(td_name));
+ 		if (strcmp(comm, td_name) != 0) {
+ 			strlcat(buf, "/", sizeof(buf));
+ 			strlcat(buf, td_name, sizeof(buf));
+ 		}
++#endif
+ 	} CATCH(e, RETURN_MASK_ERROR) {
+ 	} END_CATCH
+ 	return (buf);
+--- gdb/fbsd-kvm.c.orig	2016-12-19 10:07:48.000000000 +0200
++++ gdb/fbsd-kvm.c
+@@ -28,7 +28,11 @@
+ __FBSDID("$FreeBSD: head/devel/gdb/files/kgdb/fbsd-kvm.c 411099 2016-03-14 16:19:34Z tijl $");
+ 
+ #include <sys/param.h>
++#ifdef __DragonFly__
++#include <sys/user.h>
++#else
+ #include <sys/proc.h>
++#endif
+ #include <sys/sysctl.h>
+ #include <sys/user.h>
+ #include <err.h>
+@@ -153,8 +157,13 @@ kgdb_dmesg(void)
+ 	TRY {
+ 		bufp = parse_and_eval_address("msgbufp->msg_ptr");
+ 		size = parse_and_eval_long("msgbufp->msg_size");
++#ifdef __DragonFly__
++		rseq = parse_and_eval_long("msgbufp->msg_bufr");
++		wseq = parse_and_eval_long("msgbufp->msg_bufx");
++#else
+ 		rseq = parse_and_eval_long("msgbufp->msg_rseq");
+ 		wseq = parse_and_eval_long("msgbufp->msg_wseq");
++#endif
+ 	} CATCH(e, RETURN_MASK_ERROR) {
+ 		return;
+ 	} END_CATCH
+@@ -189,6 +198,7 @@ fbsd_kernel_osabi_sniffer(bfd *abfd)
+ 	if (elf_elfheader(abfd)->e_ident[EI_OSABI] != ELFOSABI_FREEBSD)
+ 		return (GDB_OSABI_UNKNOWN);
+ 
++#ifndef __DragonFly__
+ 	/* FreeBSD ELF kernels have an interpreter path of "/red/herring". */
+ 	bufp = buf;
+ 	s = bfd_get_section_by_name(abfd, ".interp");
+@@ -196,6 +206,7 @@ fbsd_kernel_osabi_sniffer(bfd *abfd)
+ 	    bfd_get_full_section_contents(abfd, s, &bufp) &&
+ 	    memcmp(buf, KERNEL_INTERP, sizeof(buf)) == 0)
+ 		return (GDB_OSABI_FREEBSD_ELF_KERNEL);
++#endif
+ 
+ 	return (GDB_OSABI_UNKNOWN);
+ }
+@@ -375,7 +386,11 @@ kgdb_trgt_files_info(struct target_ops *
+ 
+ 	printf_filtered ("\t`%s', ", vmcore);
+ 	wrap_here ("        ");
++#ifdef __DragonFly__
++	printf_filtered ("file type %s.\n", "DragonFly kernel vmcore");
++#else
+ 	printf_filtered ("file type %s.\n", "FreeBSD kernel vmcore");
++#endif
+ }
+ 
+ static void
+--- gdb/bsd-kvm.c.orig	2016-08-01 18:50:20.000000000 +0300
++++ gdb/bsd-kvm.c
+@@ -35,7 +35,9 @@
+ #include <paths.h>
+ #include "readline/readline.h"
+ #include <sys/param.h>
++#ifndef __DragonFly__
+ #include <sys/proc.h>
++#endif
+ #include <sys/user.h>
+ 
+ #include "bsd-kvm.h"
+@@ -273,7 +275,7 @@ bsd_kvm_cmd (char *arg, int fromtty)
+   /* ??? Should this become an alias for "target kvm"?  */
+ }
+ 
+-#ifndef HAVE_STRUCT_THREAD_TD_PCB
++#ifndef __DragonFly__ //#ifndef HAVE_STRUCT_THREAD_TD_PCB
+ 
+ static void
+ bsd_kvm_proc_cmd (char *arg, int fromtty)
+@@ -376,7 +378,7 @@ Optionally specify the filename of a cor
+ Generic command for manipulating the kernel memory interface."),
+ 		  &bsd_kvm_cmdlist, "kvm ", 0, &cmdlist);
+ 
+-#ifndef HAVE_STRUCT_THREAD_TD_PCB
++#ifndef __DragonFly__ //#ifndef HAVE_STRUCT_THREAD_TD_PCB
+   add_cmd ("proc", class_obscure, bsd_kvm_proc_cmd,
+ 	   _("Set current context from proc address"), &bsd_kvm_cmdlist);
+ #endif
+--- gdb/config/i386/dfly64.mh.orig	2016-12-19 15:30:10.000000000 +0200
++++ gdb/config/i386/dfly64.mh
+@@ -1,6 +1,6 @@
+ # Host: DragonFly/amd64
+ NATDEPFILES= fork-child.o inf-ptrace.o \
+ 	dfly-nat.o amd64-nat.o x86bsd-nat.o amd64bsd-nat.o amd64dfly-nat.o \
+-	x86-nat.o x86-dregs.o
++	x86-nat.o x86-dregs.o bsd-kvm.o
+ 
+ LOADLIBES= -lkvm
diff --git a/devel/gdb-good/dragonfly/extrapatch-native b/devel/gdb-good/dragonfly/extrapatch-native
new file mode 100644
index 00000000000..06433cf04d6
--- /dev/null
+++ b/devel/gdb-good/dragonfly/extrapatch-native
@@ -0,0 +1,29 @@
+--- gdb/Makefile.in.intermediate2	2019-05-29 15:31:11.000000000 +0000
++++ gdb/Makefile.in
+@@ -678,7 +678,7 @@ ALL_TARGET_OBS = \
+ 	i386-sol2-tdep.o i386-tdep.o i387-tdep.o \
+ 	i386-dicos-tdep.o i386-darwin-tdep.o \
+ 	iq2000-tdep.o \
+-	fbsd-kld.o fbsd-kthr.o fbsd-kvm.o i386fbsd-kern.o ppcfbsd-kern.o \
++	i386fbsd-kern.o ppcfbsd-kern.o \
+ 	mipsfbsd-kern.o \
+ 	linux-tdep.o \
+ 	lm32-tdep.o \
+@@ -1705,6 +1705,7 @@ ALLDEPFILES = \
+ 	fbsd-tdep.c \
+ 	fork-child.c \
+ 	ft32-tdep.c \
++	fbsd-kld.c fbsd-kthr.c fbsd-kvm.c \
+ 	dfly-nat.c glibc-tdep.c \
+ 	go32-nat.c h8300-tdep.c \
+ 	hppa-tdep.c \
+--- /tmp/dfly64.mh	2019-05-29 14:45:59.000000000 +0000
++++ gdb/config/i386/dfly64.mh	2019-05-29 15:50:32.000000000 +0000
+@@ -1,6 +1,6 @@
+ # Host: DragonFly/amd64
+ NATDEPFILES= fork-child.o inf-ptrace.o \
+ 	dfly-nat.o amd64-nat.o x86bsd-nat.o amd64bsd-nat.o amd64dfly-nat.o \
+-	x86-nat.o x86-dregs.o bsd-kvm.o
++	x86-nat.o x86-dregs.o bsd-kvm.o fbsd-kld.o fbsd-kthr.o fbsd-kvm.o
+ 
+ LOADLIBES= -lkvm
diff --git a/devel/gdb-good/dragonfly/i386dfly-tdep.c b/devel/gdb-good/dragonfly/i386dfly-tdep.c
new file mode 100644
index 00000000000..0830c60b9bb
--- /dev/null
+++ b/devel/gdb-good/dragonfly/i386dfly-tdep.c
@@ -0,0 +1,103 @@
+/* Target-dependent code for DragonFly/i386.
+
+   Copyright (C) 2003-2013 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "arch-utils.h"
+#include "gdbcore.h"
+#include "osabi.h"
+#include "regcache.h"
+
+#include "gdb_assert.h"
+
+#include "i386-tdep.h"
+#include "i387-tdep.h"
+#include "solib-svr4.h"
+
+static int i386dfly_r_reg_offset[] =
+{
+  44, /* %eax */
+  40, /* %ecx */
+  36, /* %edx */
+  32, /* %ebx */
+  72, /* %esp */
+  24, /* %ebp */
+  20, /* %esi */
+  16, /* %edi */
+  60, /* %eip */
+  68, /* %eflags */
+  64, /* %cs */
+  76, /* %ss */
+  12, /* %ds */
+  8, /* %es */
+  4, /* %fs */
+  0  /* %gs */
+};
+
+/* Sigtramp routine location.  */
+CORE_ADDR i386dfly_sigtramp_start_addr = 0xbfbfdf20;
+CORE_ADDR i386dfly_sigtramp_end_addr = 0xbfbfdff0;
+
+int i386dfly_sc_reg_offset[] =
+{
+  64, /* %eax */
+  60, /* %ecx */
+  56, /* %edx */
+  52, /* %ebx */
+  92, /* %esp */
+  44, /* %ebp */
+  40, /* %esi */
+  36, /* %edi */
+  80, /* %eip */
+  88, /* %eflags */
+  84, /* %cs */
+  96, /* %ss */
+  32, /* %ds */
+  28, /* %es */
+  24, /* %fs */
+  20  /* %gs */
+};
+
+static void
+i386dfly_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  i386_elf_init_abi(info, gdbarch);
+
+  tdep->gregset_reg_offset = i386dfly_r_reg_offset;
+  tdep->gregset_num_regs = ARRAY_SIZE (i386dfly_r_reg_offset);
+  tdep->sizeof_gregset = 80;
+
+  tdep->sc_reg_offset = i386dfly_sc_reg_offset;
+  tdep->sc_num_regs = ARRAY_SIZE (i386dfly_sc_reg_offset);
+
+  set_solib_svr4_fetch_link_map_offsets
+    (gdbarch, svr4_ilp32_fetch_link_map_offsets);
+}
+
+
+/* Provide a prototype to silence -Wmissing-prototypes.  */
+void _initialize_i386dfly_tdep (void);
+
+void
+_initialize_i386dfly_tdep (void)
+{
+  gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_DRAGONFLY,
+			  i386dfly_init_abi);
+}
diff --git a/devel/gdb-good/dragonfly/patch-bfd_config.bfd b/devel/gdb-good/dragonfly/patch-bfd_config.bfd
new file mode 100644
index 00000000000..f5068d6284d
--- /dev/null
+++ b/devel/gdb-good/dragonfly/patch-bfd_config.bfd
@@ -0,0 +1,11 @@
+--- bfd/config.bfd.orig	2017-01-21 13:48:42 UTC
++++ bfd/config.bfd
+@@ -625,7 +625,7 @@ case "${targ}" in
+   i[3-7]86-*-dragonfly*)
+     targ_defvec=i386_elf32_vec
+     targ_selvecs=iamcu_elf32_vec
+-    targ64_selvecs="x86_64_elf64_vec l1om_elf64_vec k1om_elf64_vec"
++    targ64_selvecs="x86_64_elf64_vec l1om_elf64_vec k1om_elf64_vec x86_64_pei_vec"
+     ;;
+   i[3-7]86-*-freebsdaout* | i[3-7]86-*-freebsd[12].* | \
+   i[3-7]86-*-freebsd[12])
diff --git a/devel/gdb-good/dragonfly/patch-gdb_Makefile.in b/devel/gdb-good/dragonfly/patch-gdb_Makefile.in
new file mode 100644
index 00000000000..55b050d6ee2
--- /dev/null
+++ b/devel/gdb-good/dragonfly/patch-gdb_Makefile.in
@@ -0,0 +1,38 @@
+--- gdb/Makefile.in.intermediate	2016-12-19 09:53:30.000000000 +0200
++++ gdb/Makefile.in
+@@ -648,7 +648,7 @@ ALL_64_TARGET_OBS = \
+ 	aarch64-tdep.o aarch64-linux-tdep.o aarch64-newlib-tdep.o aarch64-insn.o \
+ 	alphabsd-tdep.o alphafbsd-tdep.o alpha-linux-tdep.o alpha-mdebug-tdep.o \
+ 	alphanbsd-tdep.o alphaobsd-tdep.o alpha-tdep.o \
+-	amd64fbsd-tdep.o amd64-darwin-tdep.o amd64-dicos-tdep.o \
++	amd64dfly-tdep.o amd64fbsd-tdep.o amd64-darwin-tdep.o amd64-dicos-tdep.o \
+ 	amd64-linux-tdep.o amd64nbsd-tdep.o \
+ 	amd64obsd-tdep.o amd64-sol2-tdep.o amd64-tdep.o amd64-windows-tdep.o \
+ 	ia64-linux-tdep.o ia64-vms-tdep.o ia64-tdep.o \
+@@ -673,7 +673,7 @@ ALL_TARGET_OBS = \
+ 	h8300-tdep.o \
+ 	hppabsd-tdep.o hppanbsd-tdep.o hppaobsd-tdep.o \
+ 	hppa-linux-tdep.o hppa-tdep.o \
+-	i386bsd-tdep.o i386-cygwin-tdep.o i386fbsd-tdep.o i386gnu-tdep.o \
++	i386bsd-tdep.o i386-cygwin-tdep.o i386dfly-tdep.o i386fbsd-tdep.o i386gnu-tdep.o \
+ 	i386-linux-tdep.o i386nbsd-tdep.o i386-nto-tdep.o i386obsd-tdep.o \
+ 	i386-sol2-tdep.o i386-tdep.o i387-tdep.o \
+ 	i386-dicos-tdep.o i386-darwin-tdep.o \
+@@ -933,7 +933,7 @@ ser-unix.h inf-ptrace.h terminal.h ui-ou
+ f-lang.h dwarf2loc.h value.h sparc-tdep.h defs.h target-descriptions.h \
+ objfiles.h common/vec.h disasm.h mips-tdep.h ser-base.h \
+ gdb_curses.h bfd-target.h memattr.h inferior.h ax.h dummy-frame.h \
+-inflow.h fbsd-nat.h ia64-libunwind-tdep.h completer.h \
++inflow.h dfly-nat.h fbsd-nat.h ia64-libunwind-tdep.h completer.h \
+ solib-target.h gdb_vfork.h alpha-tdep.h dwarf2expr.h \
+ m2-lang.h stack.h charset.h addrmap.h command.h solist.h source.h \
+ target.h target-dcache.h prologue-value.h cp-abi.h tui/tui-hooks.h tui/tui.h \
+@@ -1703,7 +1703,7 @@ ALLDEPFILES = \
+ 	fbsd-tdep.c \
+ 	fork-child.c \
+ 	ft32-tdep.c \
+-	glibc-tdep.c \
++	dfly-nat.c glibc-tdep.c \
+ 	go32-nat.c h8300-tdep.c \
+ 	hppa-tdep.c \
+ 	hppa-linux-tdep.c hppa-linux-nat.c \
diff --git a/devel/gdb-good/dragonfly/patch-gdb_amd64-tdep.h b/devel/gdb-good/dragonfly/patch-gdb_amd64-tdep.h
new file mode 100644
index 00000000000..3c3af6a5d90
--- /dev/null
+++ b/devel/gdb-good/dragonfly/patch-gdb_amd64-tdep.h
@@ -0,0 +1,16 @@
+--- gdb/amd64-tdep.h.orig	2013-01-01 06:32:37.000000000 +0000
++++ gdb/amd64-tdep.h
+@@ -121,9 +121,9 @@ extern int amd64nbsd_r_reg_offset[];
+ /* Variables exported from amd64obsd-tdep.c.  */
+ extern int amd64obsd_r_reg_offset[];
+ 
+-/* Variables exported from amd64fbsd-tdep.c.  */
+-extern CORE_ADDR amd64fbsd_sigtramp_start_addr;
+-extern CORE_ADDR amd64fbsd_sigtramp_end_addr;
+-extern int amd64fbsd_sc_reg_offset[];
++/* Variables exported from amd64dfly-tdep.c.  */
++extern CORE_ADDR amd64dfly_sigtramp_start_addr;
++extern CORE_ADDR amd64dfly_sigtramp_end_addr;
++extern int amd64dfly_sc_reg_offset[];
+ 
+ #endif /* amd64-tdep.h */
diff --git a/devel/gdb-good/dragonfly/patch-gdb_configure.host b/devel/gdb-good/dragonfly/patch-gdb_configure.host
new file mode 100644
index 00000000000..13fd6c93401
--- /dev/null
+++ b/devel/gdb-good/dragonfly/patch-gdb_configure.host
@@ -0,0 +1,10 @@
+--- gdb/configure.host.orig	2015-05-13 17:36:05 UTC
++++ gdb/configure.host
+@@ -175,6 +175,7 @@ vax-*-netbsdelf* | vax-*-knetbsd*-gnu)
+ vax-*-openbsd*)		gdb_host=obsd ;;
+ 
+ x86_64-*-linux*)	gdb_host=linux64 ;;
++x86_64-*-dragonfly*)	gdb_host=dfly64 ;;
+ x86_64-*-freebsd* | x86_64-*-kfreebsd*-gnu)
+ 			gdb_host=fbsd64 ;;
+ x86_64-*-netbsd* | x86_64-*-knetbsd*-gnu)
diff --git a/devel/gdb-good/dragonfly/patch-gdb_configure.tgt b/devel/gdb-good/dragonfly/patch-gdb_configure.tgt
new file mode 100644
index 00000000000..f727fd1150a
--- /dev/null
+++ b/devel/gdb-good/dragonfly/patch-gdb_configure.tgt
@@ -0,0 +1,24 @@
+--- gdb/configure.tgt.orig	2015-05-13 17:36:05 UTC
++++ gdb/configure.tgt
+@@ -659,6 +659,12 @@ x86_64-*-linux*)
+ 			solib-svr4.o symfile-mem.o linux-tdep.o linux-record.o"
+ 	build_gdbserver=yes
+ 	;;
++x86_64-*-dragonfly*)
++	# Target: DragonFly/amd64
++	gdb_target_obs="amd64-tdep.o amd64dfly-tdep.o i386-tdep.o \
++			i387-tdep.o i386bsd-tdep.o i386dfly-tdep.o \
++			bsd-uthread.o solib-svr4.o"
++	;;
+ x86_64-*-freebsd* | x86_64-*-kfreebsd*-gnu)
+ 	# Target: FreeBSD/amd64
+ 	gdb_target_obs="amd64-tdep.o amd64fbsd-tdep.o i386-tdep.o \
+@@ -699,6 +705,8 @@ esac
+ # map target onto default OS ABI
+ 
+ case "${targ}" in
++*-*-dragonfly*)
++		gdb_osabi=GDB_OSABI_DRAGONFLY ;;
+ *-*-freebsd* | *-*-kfreebsd*-gnu)
+ 		gdb_osabi=GDB_OSABI_FREEBSD_ELF ;;
+ *-*-linux* | *-*-uclinux*)
diff --git a/devel/gdb-good/dragonfly/patch-gdb_defs.h b/devel/gdb-good/dragonfly/patch-gdb_defs.h
new file mode 100644
index 00000000000..b82b622e737
--- /dev/null
+++ b/devel/gdb-good/dragonfly/patch-gdb_defs.h
@@ -0,0 +1,10 @@
+--- gdb/defs.h.orig	2013-02-04 12:57:44.000000000 +0000
++++ gdb/defs.h
+@@ -581,6 +581,7 @@ enum gdb_osabi
+   GDB_OSABI_NETBSD_AOUT,
+   GDB_OSABI_NETBSD_ELF,
+   GDB_OSABI_OPENBSD_ELF,
++  GDB_OSABI_DRAGONFLY,
+   GDB_OSABI_WINCE,
+   GDB_OSABI_GO32,
+   GDB_OSABI_IRIX,
diff --git a/devel/gdb-good/dragonfly/patch-gdb_i386-tdep.h b/devel/gdb-good/dragonfly/patch-gdb_i386-tdep.h
new file mode 100644
index 00000000000..f2bdccc3dcc
--- /dev/null
+++ b/devel/gdb-good/dragonfly/patch-gdb_i386-tdep.h
@@ -0,0 +1,18 @@
+--- gdb/i386-tdep.h.orig	2013-01-01 06:32:45.000000000 +0000
++++ gdb/i386-tdep.h
+@@ -387,12 +387,11 @@ extern int i386_process_record (struct g
+ /* Functions and variables exported from i386bsd-tdep.c.  */
+ 
+ extern void i386bsd_init_abi (struct gdbarch_info, struct gdbarch *);
+-extern CORE_ADDR i386fbsd_sigtramp_start_addr;
+-extern CORE_ADDR i386fbsd_sigtramp_end_addr;
++extern CORE_ADDR i386dfly_sigtramp_start_addr;
++extern CORE_ADDR i386dfly_sigtramp_end_addr;
+ extern CORE_ADDR i386obsd_sigtramp_start_addr;
+ extern CORE_ADDR i386obsd_sigtramp_end_addr;
+-extern int i386fbsd4_sc_reg_offset[];
+-extern int i386fbsd_sc_reg_offset[];
++extern int i386dfly_sc_reg_offset[];
+ extern int i386nbsd_sc_reg_offset[];
+ extern int i386obsd_sc_reg_offset[];
+ extern int i386bsd_sc_reg_offset[];
diff --git a/devel/gdb-good/dragonfly/patch-gdb_i386bsd-nat.c b/devel/gdb-good/dragonfly/patch-gdb_i386bsd-nat.c
new file mode 100644
index 00000000000..422e4239237
--- /dev/null
+++ b/devel/gdb-good/dragonfly/patch-gdb_i386bsd-nat.c
@@ -0,0 +1,11 @@
+--- gdb/i386bsd-nat.c.orig	2013-05-17 18:49:06.543945000 +0000
++++ gdb/i386bsd-nat.c
+@@ -353,6 +353,8 @@ _initialize_i386bsd_nat (void)
+ #define SC_REG_OFFSET i386nbsd_sc_reg_offset
+ #elif defined (OpenBSD)
+ #define SC_REG_OFFSET i386obsd_sc_reg_offset
++#elif defined (DragonFly)
++#define SC_REG_OFFSET i386dfly_sc_reg_offset
+ #endif
+ 
+ #ifdef SC_REG_OFFSET
diff --git a/devel/gdb-good/dragonfly/patch-gdb_osabi.c b/devel/gdb-good/dragonfly/patch-gdb_osabi.c
new file mode 100644
index 00000000000..5180aed9b1a
--- /dev/null
+++ b/devel/gdb-good/dragonfly/patch-gdb_osabi.c
@@ -0,0 +1,26 @@
+--- gdb/osabi.c.orig	2015-02-19 11:58:07 UTC
++++ gdb/osabi.c
+@@ -69,6 +69,7 @@ static const struct osabi_names gdb_osab
+   { "NetBSD/a.out", NULL },
+   { "NetBSD/ELF", NULL },
+   { "OpenBSD/ELF", NULL },
++  { "DragonFly/ELF", NULL },
+   { "WindowsCE", NULL },
+   { "DJGPP", NULL },
+   { "Irix", NULL },
+@@ -501,6 +502,15 @@ generic_elf_osabi_sniff_abi_tag_sections
+ 	  return;
+ 	}
+ 
++      /* DragonFly.  */
++      if (check_note (abfd, sect, note, &sectsize, "DragonFly", 4,
++		      NT_DRAGONFLY_ABI_TAG))
++	{
++	  /* There is no need to check the version yet.  */
++	  *osabi = GDB_OSABI_DRAGONFLY;
++	  return;
++	}
++
+       /* FreeBSD.  */
+       if (check_note (abfd, sect, note, &sectsize, "FreeBSD", 4,
+ 		      NT_FREEBSD_ABI_TAG))
diff --git a/devel/gdb-good/dragonfly/patch-include_elf_common.h b/devel/gdb-good/dragonfly/patch-include_elf_common.h
new file mode 100644
index 00000000000..6d86b197541
--- /dev/null
+++ b/devel/gdb-good/dragonfly/patch-include_elf_common.h
@@ -0,0 +1,10 @@
+--- include/elf/common.h.orig	2013-03-08 17:13:31.000000000 +0000
++++ include/elf/common.h
+@@ -628,6 +628,7 @@
+ /* Values for FreeBSD .note.ABI-tag notes.  Note name is "FreeBSD".  */
+ 
+ #define NT_FREEBSD_ABI_TAG	1
++#define NT_DRAGONFLY_ABI_TAG	1
+ 
+ /* These three macros disassemble and assemble a symbol table st_info field,
+    which contains the symbol binding and symbol type.  The STB_ and STT_
diff --git a/devel/gdb-good/files/commit-387360daf9 b/devel/gdb-good/files/commit-387360daf9
new file mode 100644
index 00000000000..692e650e256
--- /dev/null
+++ b/devel/gdb-good/files/commit-387360daf9
@@ -0,0 +1,680 @@
+commit 9978d70207d8a6bc7ff3c570814053c68e78b913
+Author: John Baldwin <jhb@FreeBSD.org>
+Date:   Wed Jan 4 09:41:58 2017 -0800
+
+    Add FreeBSD/mips architecture.
+    
+    This has been tested for the n64 and o32 ABIs.  Signal frame unwinders for
+    both ABIs are provided.  FreeBSD/mips requires custom linkmap offsets since
+    it contains an additional l_off member in 'struct link_map' that other
+    FreeBSD platforms do not have.  Support for collecting and supplying
+    general purpose and floating point register sets are provided.  Common
+    routines for working with native format register sets are exported for
+    use by the native target.
+    
+    gdb/ChangeLog:
+    
+            * Makefile.in (ALL_TARGET_OBS): Add mips-fbsd-tdep.o.
+            (ALLDEPFILES): Add mips-fbsd-tdep.c.
+            * NEWS: Mention new FreeBSD/mips target.
+            * configure.tgt: Add mips*-*-freebsd*.
+            * mips-fbsd-tdep.c: New file.
+            * mips-fbsd-tdep.h: New file.
+    
+    gdb/doc/ChangeLog:
+    
+            * gdb.texinfo (Contributors): Add SRI International and University
+            of Cambridge for FreeBSD/mips.
+
+diff --git gdb/Makefile.in gdb/Makefile.in
+index 7b2df86878..300c2cb702 100644
+--- gdb/Makefile.in
++++ gdb/Makefile.in
+@@ -685,6 +685,7 @@ ALL_TARGET_OBS = \
+ 	m88k-tdep.o \
+ 	mep-tdep.o \
+ 	microblaze-tdep.o microblaze-linux-tdep.o \
++	mips-fbsd-tdep.o \
+ 	mips-linux-tdep.o mips-sde-tdep.o \
+ 	mipsnbsd-tdep.o mips-tdep.o \
+ 	mn10300-linux-tdep.o mn10300-tdep.o \
+@@ -1724,6 +1725,7 @@ ALLDEPFILES = \
+ 	m88k-tdep.c m88kbsd-nat.c \
+ 	microblaze-tdep.c microblaze-linux-tdep.c \
+ 	mingw-hdep.c common/mingw-strerror.c \
++	mips-fbsd-tdep.c \
+ 	mips-linux-nat.c mips-linux-tdep.c \
+ 	mips-sde-tdep.c \
+ 	mips-tdep.c \
+diff --git gdb/configure.tgt gdb/configure.tgt
+index 7f1aac3742..9ee9f7a799 100644
+--- gdb/configure.tgt
++++ gdb/configure.tgt
+@@ -358,6 +358,11 @@ mips*-*-netbsd* | mips*-*-knetbsd*-gnu)
+ 	gdb_target_obs="mips-tdep.o mipsnbsd-tdep.o solib-svr4.o nbsd-tdep.o"
+ 	gdb_sim=../sim/mips/libsim.a
+ 	;;
++mips*-*-freebsd*)
++	# Target: MIPS running FreeBSD
++	gdb_target_obs="mips-tdep.o mips-fbsd-tdep.o solib-svr4.o fbsd-tdep.o"
++	gdb_sim=../sim/mips/libsim.a
++	;;
+ mips64*-*-openbsd*)
+ 	# Target: OpenBSD/mips64
+ 	gdb_target_obs="mips-tdep.o mips64obsd-tdep.o obsd-tdep.o solib-svr4.o"
+diff --git gdb/doc/gdb.texinfo gdb/doc/gdb.texinfo
+index 067a45b2de..179da5cdb3 100644
+--- gdb/doc/gdb.texinfo
++++ gdb/doc/gdb.texinfo
+@@ -541,6 +541,11 @@ Steve Tjiang, John Newlin, and Scott Foehner.
+ Michael Eager and staff of Xilinx, Inc., contributed support for the
+ Xilinx MicroBlaze architecture.
+ 
++Initial support for the FreeBSD/mips target and native configuration
++was developed by SRI International and the University of Cambridge
++Computer Laboratory under DARPA/AFRL contract FA8750-10-C-0237
++("CTSRD"), as part of the DARPA CRASH research programme.
++
+ @node Sample Session
+ @chapter A Sample @value{GDBN} Session
+ 
+diff --git gdb/mips-fbsd-tdep.c gdb/mips-fbsd-tdep.c
+new file mode 100644
+index 0000000000..733534ddac
+--- /dev/null
++++ gdb/mips-fbsd-tdep.c
+@@ -0,0 +1,560 @@
++/* Target-dependent code for FreeBSD/mips.
++
++   Copyright (C) 2017 Free Software Foundation, Inc.
++
++   This file is part of GDB.
++
++   This program is free software; you can redistribute it and/or modify
++   it under the terms of the GNU General Public License as published by
++   the Free Software Foundation; either version 3 of the License, or
++   (at your option) any later version.
++
++   This program is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++   GNU General Public License for more details.
++
++   You should have received a copy of the GNU General Public License
++   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
++
++#include "defs.h"
++#include "osabi.h"
++#include "regset.h"
++#include "trad-frame.h"
++#include "tramp-frame.h"
++
++#include "fbsd-tdep.h"
++#include "mips-tdep.h"
++#include "mips-fbsd-tdep.h"
++
++#include "solib-svr4.h"
++
++/* Shorthand for some register numbers used below.  */
++#define MIPS_PC_REGNUM  MIPS_EMBED_PC_REGNUM
++#define MIPS_FP0_REGNUM MIPS_EMBED_FP0_REGNUM
++#define MIPS_FSR_REGNUM MIPS_EMBED_FP0_REGNUM + 32
++
++/* Core file support. */
++
++/* Number of registers in `struct reg' from <machine/reg.h>.  The
++   first 38 follow the standard MIPS layout.  The 39th holds
++   IC_INT_REG on RM7K and RM9K processors.  The 40th is a dummy for
++   padding.  */
++#define MIPS_FBSD_NUM_GREGS	40
++
++/* Number of registers in `struct fpreg' from <machine/reg.h>.  The
++   first 32 hold floating point registers.  33 holds the FSR.  The
++   34th is a dummy for padding.  */
++#define MIPS_FBSD_NUM_FPREGS	34
++
++/* Supply a single register.  If the source register size matches the
++   size the regcache expects, this can use regcache_raw_supply().  If
++   they are different, this copies the source register into a buffer
++   that can be passed to regcache_raw_supply().  */
++
++static void
++mips_fbsd_supply_reg (struct regcache *regcache, int regnum, const void *addr,
++		      size_t len)
++{
++  struct gdbarch *gdbarch = get_regcache_arch (regcache);
++
++  if (register_size (gdbarch, regnum) == len)
++    regcache_raw_supply (regcache, regnum, addr);
++  else
++    {
++      enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
++      gdb_byte buf[MAX_REGISTER_SIZE];
++      LONGEST val;
++
++      val = extract_signed_integer ((const gdb_byte *) addr, len, byte_order);
++      store_signed_integer (buf, register_size (gdbarch, regnum), byte_order,
++			    val);
++      regcache_raw_supply (regcache, regnum, buf);
++    }
++}
++
++/* Collect a single register.  If the destination register size
++   matches the size the regcache expects, this can use
++   regcache_raw_supply().  If they are different, this fetches the
++   register via regcache_raw_supply() into a buffer and then copies it
++   into the final destination.  */
++
++static void
++mips_fbsd_collect_reg (const struct regcache *regcache, int regnum, void *addr,
++		       size_t len)
++{
++  struct gdbarch *gdbarch = get_regcache_arch (regcache);
++
++  if (register_size (gdbarch, regnum) == len)
++    regcache_raw_collect (regcache, regnum, addr);
++  else
++    {
++      enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
++      gdb_byte buf[MAX_REGISTER_SIZE];
++      LONGEST val;
++
++      regcache_raw_collect (regcache, regnum, buf);
++      val = extract_signed_integer (buf, register_size (gdbarch, regnum),
++				    byte_order);
++      store_signed_integer ((gdb_byte *) addr, len, byte_order, val);
++    }
++}
++
++/* Supply the floating-point registers stored in FPREGS to REGCACHE.
++   Each floating-point register in FPREGS is REGSIZE bytes in
++   length.  */
++
++void
++mips_fbsd_supply_fpregs (struct regcache *regcache, int regnum,
++			 const void *fpregs, size_t regsize)
++{
++  const gdb_byte *regs = (const gdb_byte *) fpregs;
++  int i;
++
++  for (i = MIPS_FP0_REGNUM; i <= MIPS_FSR_REGNUM; i++)
++    if (regnum == i || regnum == -1)
++      mips_fbsd_supply_reg (regcache, i,
++			    regs + (i - MIPS_FP0_REGNUM) * regsize, regsize);
++}
++
++/* Supply the general-purpose registers stored in GREGS to REGCACHE.
++   Each general-purpose register in GREGS is REGSIZE bytes in
++   length.  */
++
++void
++mips_fbsd_supply_gregs (struct regcache *regcache, int regnum,
++			const void *gregs, size_t regsize)
++{
++  const gdb_byte *regs = (const gdb_byte *) gregs;
++  int i;
++
++  for (i = 0; i <= MIPS_PC_REGNUM; i++)
++    if (regnum == i || regnum == -1)
++      mips_fbsd_supply_reg (regcache, i, regs + i * regsize, regsize);
++}
++
++/* Collect the floating-point registers from REGCACHE and store them
++   in FPREGS.  Each floating-point register in FPREGS is REGSIZE bytes
++   in length.  */
++
++void
++mips_fbsd_collect_fpregs (const struct regcache *regcache, int regnum,
++			  void *fpregs, size_t regsize)
++{
++  gdb_byte *regs = (gdb_byte *) fpregs;
++  int i;
++
++  for (i = MIPS_FP0_REGNUM; i <= MIPS_FSR_REGNUM; i++)
++    if (regnum == i || regnum == -1)
++      mips_fbsd_collect_reg (regcache, i,
++			     regs + (i - MIPS_FP0_REGNUM) * regsize, regsize);
++}
++
++/* Collect the general-purpose registers from REGCACHE and store them
++   in GREGS.  Each general-purpose register in GREGS is REGSIZE bytes
++   in length.  */
++
++void
++mips_fbsd_collect_gregs (const struct regcache *regcache, int regnum,
++			 void *gregs, size_t regsize)
++{
++  gdb_byte *regs = (gdb_byte *) gregs;
++  int i;
++
++  for (i = 0; i <= MIPS_PC_REGNUM; i++)
++    if (regnum == i || regnum == -1)
++      mips_fbsd_collect_reg (regcache, i, regs + i * regsize, regsize);
++}
++
++/* Supply register REGNUM from the buffer specified by FPREGS and LEN
++   in the floating-point register set REGSET to register cache
++   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */
++
++static void
++mips_fbsd_supply_fpregset (const struct regset *regset,
++			   struct regcache *regcache,
++			   int regnum, const void *fpregs, size_t len)
++{
++  size_t regsize = mips_abi_regsize (get_regcache_arch (regcache));
++
++  gdb_assert (len >= MIPS_FBSD_NUM_FPREGS * regsize);
++
++  mips_fbsd_supply_fpregs (regcache, regnum, fpregs, regsize);
++}
++
++/* Collect register REGNUM from the register cache REGCACHE and store
++   it in the buffer specified by FPREGS and LEN in the floating-point
++   register set REGSET.  If REGNUM is -1, do this for all registers in
++   REGSET.  */
++
++static void
++mips_fbsd_collect_fpregset (const struct regset *regset,
++			    const struct regcache *regcache,
++			    int regnum, void *fpregs, size_t len)
++{
++  size_t regsize = mips_abi_regsize (get_regcache_arch (regcache));
++
++  gdb_assert (len >= MIPS_FBSD_NUM_FPREGS * regsize);
++
++  mips_fbsd_collect_fpregs (regcache, regnum, fpregs, regsize);
++}
++
++/* Supply register REGNUM from the buffer specified by GREGS and LEN
++   in the general-purpose register set REGSET to register cache
++   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */
++
++static void
++mips_fbsd_supply_gregset (const struct regset *regset,
++			  struct regcache *regcache, int regnum,
++			  const void *gregs, size_t len)
++{
++  size_t regsize = mips_abi_regsize (get_regcache_arch (regcache));
++
++  gdb_assert (len >= MIPS_FBSD_NUM_GREGS * regsize);
++
++  mips_fbsd_supply_gregs (regcache, regnum, gregs, regsize);
++}
++
++/* Collect register REGNUM from the register cache REGCACHE and store
++   it in the buffer specified by GREGS and LEN in the general-purpose
++   register set REGSET.  If REGNUM is -1, do this for all registers in
++   REGSET.  */
++
++static void
++mips_fbsd_collect_gregset (const struct regset *regset,
++			   const struct regcache *regcache,
++			   int regnum, void *gregs, size_t len)
++{
++  size_t regsize = mips_abi_regsize (get_regcache_arch (regcache));
++
++  gdb_assert (len >= MIPS_FBSD_NUM_GREGS * regsize);
++
++  mips_fbsd_collect_gregs (regcache, regnum, gregs, regsize);
++}
++
++/* FreeBSD/mips register sets.  */
++
++static const struct regset mips_fbsd_gregset =
++{
++  NULL,
++  mips_fbsd_supply_gregset,
++  mips_fbsd_collect_gregset,
++};
++
++static const struct regset mips_fbsd_fpregset =
++{
++  NULL,
++  mips_fbsd_supply_fpregset,
++  mips_fbsd_collect_fpregset,
++};
++
++/* Iterate over core file register note sections.  */
++
++static void
++mips_fbsd_iterate_over_regset_sections (struct gdbarch *gdbarch,
++					iterate_over_regset_sections_cb *cb,
++					void *cb_data,
++					const struct regcache *regcache)
++{
++  size_t regsize = mips_abi_regsize (gdbarch);
++
++  cb (".reg", MIPS_FBSD_NUM_GREGS * regsize, &mips_fbsd_gregset,
++      NULL, cb_data);
++  cb (".reg2", MIPS_FBSD_NUM_FPREGS * regsize, &mips_fbsd_fpregset,
++      NULL, cb_data);
++}
++
++/* Signal trampoline support.  */
++
++#define FBSD_SYS_sigreturn	417
++
++#define MIPS_INST_LI_V0_SIGRETURN 0x24020000 + FBSD_SYS_sigreturn
++#define MIPS_INST_SYSCALL	0x0000000c
++#define MIPS_INST_BREAK		0x0000000d
++
++#define O32_SIGFRAME_UCONTEXT_OFFSET	(16)
++#define O32_SIGSET_T_SIZE	(16)
++
++#define O32_UCONTEXT_ONSTACK	(O32_SIGSET_T_SIZE)
++#define O32_UCONTEXT_PC		(O32_UCONTEXT_ONSTACK + 4)
++#define O32_UCONTEXT_REGS	(O32_UCONTEXT_PC + 4)
++#define O32_UCONTEXT_SR		(O32_UCONTEXT_REGS + 4 * 32)
++#define O32_UCONTEXT_LO		(O32_UCONTEXT_SR + 4)
++#define O32_UCONTEXT_HI		(O32_UCONTEXT_LO + 4)
++#define O32_UCONTEXT_FPUSED	(O32_UCONTEXT_HI + 4)
++#define O32_UCONTEXT_FPREGS	(O32_UCONTEXT_FPUSED + 4)
++
++#define O32_UCONTEXT_REG_SIZE	4
++
++static void
++mips_fbsd_sigframe_init (const struct tramp_frame *self,
++			 struct frame_info *this_frame,
++			 struct trad_frame_cache *cache,
++			 CORE_ADDR func)
++{
++  struct gdbarch *gdbarch = get_frame_arch (this_frame);
++  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
++  CORE_ADDR sp, ucontext_addr, addr;
++  int regnum;
++  gdb_byte buf[4];
++
++  /* We find the appropriate instance of `ucontext_t' at a
++     fixed offset in the signal frame.  */
++  sp = get_frame_register_signed (this_frame,
++				  MIPS_SP_REGNUM + gdbarch_num_regs (gdbarch));
++  ucontext_addr = sp + O32_SIGFRAME_UCONTEXT_OFFSET;
++
++  /* PC.  */
++  regnum = mips_regnum (gdbarch)->pc;
++  trad_frame_set_reg_addr (cache,
++			   regnum + gdbarch_num_regs (gdbarch),
++			   ucontext_addr + O32_UCONTEXT_PC);
++
++  /* GPRs.  */
++  for (regnum = MIPS_ZERO_REGNUM, addr = ucontext_addr + O32_UCONTEXT_REGS;
++       regnum <= MIPS_RA_REGNUM; regnum++, addr += O32_UCONTEXT_REG_SIZE)
++    trad_frame_set_reg_addr (cache,
++			     regnum + gdbarch_num_regs (gdbarch),
++			     addr);
++
++  regnum = MIPS_PS_REGNUM;
++  trad_frame_set_reg_addr (cache,
++			   regnum + gdbarch_num_regs (gdbarch),
++			   ucontext_addr + O32_UCONTEXT_SR);
++
++  /* HI and LO.  */
++  regnum = mips_regnum (gdbarch)->lo;
++  trad_frame_set_reg_addr (cache,
++			   regnum + gdbarch_num_regs (gdbarch),
++			   ucontext_addr + O32_UCONTEXT_LO);
++  regnum = mips_regnum (gdbarch)->hi;
++  trad_frame_set_reg_addr (cache,
++			   regnum + gdbarch_num_regs (gdbarch),
++			   ucontext_addr + O32_UCONTEXT_HI);
++
++  if (target_read_memory (ucontext_addr + O32_UCONTEXT_FPUSED, buf, 4) == 0 &&
++      extract_unsigned_integer (buf, 4, byte_order) != 0)
++    {
++      for (regnum = 0, addr = ucontext_addr + O32_UCONTEXT_FPREGS;
++	   regnum < 32; regnum++, addr += O32_UCONTEXT_REG_SIZE)
++	trad_frame_set_reg_addr (cache,
++				 regnum + gdbarch_fp0_regnum (gdbarch),
++				 addr);
++      trad_frame_set_reg_addr (cache, mips_regnum (gdbarch)->fp_control_status,
++			       addr);
++    }
++
++  trad_frame_set_id (cache, frame_id_build (sp, func));
++}
++
++#define MIPS_INST_ADDIU_A0_SP_O32 (0x27a40000 \
++				   + O32_SIGFRAME_UCONTEXT_OFFSET)
++
++static const struct tramp_frame mips_fbsd_sigframe =
++{
++  SIGTRAMP_FRAME,
++  MIPS_INSN32_SIZE,
++  {
++    { MIPS_INST_ADDIU_A0_SP_O32, -1 },	/* addiu   a0, sp, SIGF_UC */
++    { MIPS_INST_LI_V0_SIGRETURN, -1 },	/* li      v0, SYS_sigreturn */
++    { MIPS_INST_SYSCALL, -1 },		/* syscall */
++    { MIPS_INST_BREAK, -1 },		/* break */
++    { TRAMP_SENTINEL_INSN, -1 }
++  },
++  mips_fbsd_sigframe_init
++};
++
++#define N64_SIGFRAME_UCONTEXT_OFFSET	(32)
++#define N64_SIGSET_T_SIZE	(16)
++
++#define N64_UCONTEXT_ONSTACK	(N64_SIGSET_T_SIZE)
++#define N64_UCONTEXT_PC		(N64_UCONTEXT_ONSTACK + 8)
++#define N64_UCONTEXT_REGS	(N64_UCONTEXT_PC + 8)
++#define N64_UCONTEXT_SR		(N64_UCONTEXT_REGS + 8 * 32)
++#define N64_UCONTEXT_LO		(N64_UCONTEXT_SR + 8)
++#define N64_UCONTEXT_HI		(N64_UCONTEXT_LO + 8)
++#define N64_UCONTEXT_FPUSED	(N64_UCONTEXT_HI + 8)
++#define N64_UCONTEXT_FPREGS	(N64_UCONTEXT_FPUSED + 8)
++
++#define N64_UCONTEXT_REG_SIZE	8
++
++static void
++mips64_fbsd_sigframe_init (const struct tramp_frame *self,
++			   struct frame_info *this_frame,
++			   struct trad_frame_cache *cache,
++			   CORE_ADDR func)
++{
++  struct gdbarch *gdbarch = get_frame_arch (this_frame);
++  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
++  CORE_ADDR sp, ucontext_addr, addr;
++  int regnum;
++  gdb_byte buf[4];
++
++  /* We find the appropriate instance of `ucontext_t' at a
++     fixed offset in the signal frame.  */
++  sp = get_frame_register_signed (this_frame,
++				  MIPS_SP_REGNUM + gdbarch_num_regs (gdbarch));
++  ucontext_addr = sp + N64_SIGFRAME_UCONTEXT_OFFSET;
++
++  /* PC.  */
++  regnum = mips_regnum (gdbarch)->pc;
++  trad_frame_set_reg_addr (cache,
++			   regnum + gdbarch_num_regs (gdbarch),
++			   ucontext_addr + N64_UCONTEXT_PC);
++
++  /* GPRs.  */
++  for (regnum = MIPS_ZERO_REGNUM, addr = ucontext_addr + N64_UCONTEXT_REGS;
++       regnum <= MIPS_RA_REGNUM; regnum++, addr += N64_UCONTEXT_REG_SIZE)
++    trad_frame_set_reg_addr (cache,
++			     regnum + gdbarch_num_regs (gdbarch),
++			     addr);
++
++  regnum = MIPS_PS_REGNUM;
++  trad_frame_set_reg_addr (cache,
++			   regnum + gdbarch_num_regs (gdbarch),
++			   ucontext_addr + N64_UCONTEXT_SR);
++
++  /* HI and LO.  */
++  regnum = mips_regnum (gdbarch)->lo;
++  trad_frame_set_reg_addr (cache,
++			   regnum + gdbarch_num_regs (gdbarch),
++			   ucontext_addr + N64_UCONTEXT_LO);
++  regnum = mips_regnum (gdbarch)->hi;
++  trad_frame_set_reg_addr (cache,
++			   regnum + gdbarch_num_regs (gdbarch),
++			   ucontext_addr + N64_UCONTEXT_HI);
++
++  if (target_read_memory (ucontext_addr + N64_UCONTEXT_FPUSED, buf, 4) == 0 &&
++      extract_unsigned_integer (buf, 4, byte_order) != 0)
++    {
++      for (regnum = 0, addr = ucontext_addr + N64_UCONTEXT_FPREGS;
++	   regnum < 32; regnum++, addr += N64_UCONTEXT_REG_SIZE)
++	trad_frame_set_reg_addr (cache,
++				 regnum + gdbarch_fp0_regnum (gdbarch),
++				 addr);
++      trad_frame_set_reg_addr (cache, mips_regnum (gdbarch)->fp_control_status,
++			       addr);
++    }
++
++  trad_frame_set_id (cache, frame_id_build (sp, func));
++}
++
++#define MIPS_INST_DADDIU_A0_SP_N64 (0x67a40000 \
++				    + N64_SIGFRAME_UCONTEXT_OFFSET)
++
++static const struct tramp_frame mips64_fbsd_sigframe =
++{
++  SIGTRAMP_FRAME,
++  MIPS_INSN32_SIZE,
++  {
++    { MIPS_INST_DADDIU_A0_SP_N64, -1 },	/* daddiu  a0, sp, SIGF_UC */
++    { MIPS_INST_LI_V0_SIGRETURN, -1 },	/* li      v0, SYS_sigreturn */
++    { MIPS_INST_SYSCALL, -1 },		/* syscall */
++    { MIPS_INST_BREAK, -1 },		/* break */
++    { TRAMP_SENTINEL_INSN, -1 }
++  },
++  mips64_fbsd_sigframe_init
++};
++
++/* Shared library support.  */
++
++/* FreeBSD/mips uses a slightly different `struct link_map' than the
++   other FreeBSD platforms as it includes an additional `l_off'
++   member.  */
++
++static struct link_map_offsets *
++mips_fbsd_ilp32_fetch_link_map_offsets (void)
++{
++  static struct link_map_offsets lmo;
++  static struct link_map_offsets *lmp = NULL;
++
++  if (lmp == NULL)
++    {
++      lmp = &lmo;
++
++      lmo.r_version_offset = 0;
++      lmo.r_version_size = 4;
++      lmo.r_map_offset = 4;
++      lmo.r_brk_offset = 8;
++      lmo.r_ldsomap_offset = -1;
++
++      lmo.link_map_size = 24;
++      lmo.l_addr_offset = 0;
++      lmo.l_name_offset = 8;
++      lmo.l_ld_offset = 12;
++      lmo.l_next_offset = 16;
++      lmo.l_prev_offset = 20;
++    }
++
++  return lmp;
++}
++
++static struct link_map_offsets *
++mips_fbsd_lp64_fetch_link_map_offsets (void)
++{
++  static struct link_map_offsets lmo;
++  static struct link_map_offsets *lmp = NULL;
++
++  if (lmp == NULL)
++    {
++      lmp = &lmo;
++
++      lmo.r_version_offset = 0;
++      lmo.r_version_size = 4;
++      lmo.r_map_offset = 8;
++      lmo.r_brk_offset = 16;
++      lmo.r_ldsomap_offset = -1;
++
++      lmo.link_map_size = 48;
++      lmo.l_addr_offset = 0;
++      lmo.l_name_offset = 16;
++      lmo.l_ld_offset = 24;
++      lmo.l_next_offset = 32;
++      lmo.l_prev_offset = 40;
++    }
++
++  return lmp;
++}
++
++static void
++mips_fbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
++{
++  enum mips_abi abi = mips_abi (gdbarch);
++
++  /* Generic FreeBSD support.  */
++  fbsd_init_abi (info, gdbarch);
++
++  set_gdbarch_software_single_step (gdbarch, mips_software_single_step);
++
++  switch (abi)
++    {
++      case MIPS_ABI_O32:
++	tramp_frame_prepend_unwinder (gdbarch, &mips_fbsd_sigframe);
++	break;
++      case MIPS_ABI_N32:
++	break;
++      case MIPS_ABI_N64:
++	tramp_frame_prepend_unwinder (gdbarch, &mips64_fbsd_sigframe);
++	break;
++    }
++
++  set_gdbarch_iterate_over_regset_sections
++    (gdbarch, mips_fbsd_iterate_over_regset_sections);
++
++  /* FreeBSD/mips has SVR4-style shared libraries.  */
++  set_solib_svr4_fetch_link_map_offsets
++    (gdbarch, (gdbarch_ptr_bit (gdbarch) == 32 ?
++	       mips_fbsd_ilp32_fetch_link_map_offsets :
++	       mips_fbsd_lp64_fetch_link_map_offsets));
++}
++
++
++/* Provide a prototype to silence -Wmissing-prototypes.  */
++void _initialize_mips_fbsd_tdep (void);
++
++void
++_initialize_mips_fbsd_tdep (void)
++{
++  gdbarch_register_osabi (bfd_arch_mips, 0, GDB_OSABI_FREEBSD_ELF,
++			  mips_fbsd_init_abi);
++}
+diff --git gdb/mips-fbsd-tdep.h gdb/mips-fbsd-tdep.h
+new file mode 100644
+index 0000000000..8a197e6325
+--- /dev/null
++++ gdb/mips-fbsd-tdep.h
+@@ -0,0 +1,28 @@
++/* Common target dependent code for GDB on MIPS systems running FreeBSD.
++
++   Copyright (C) 2017 Free Software Foundation, Inc.
++
++   This file is part of GDB.
++
++   This program is free software; you can redistribute it and/or modify
++   it under the terms of the GNU General Public License as published by
++   the Free Software Foundation; either version 3 of the License, or
++   (at your option) any later version.
++
++   This program is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++   GNU General Public License for more details.
++
++   You should have received a copy of the GNU General Public License
++   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
++
++#ifndef MIPS_FBSD_TDEP_H
++#define MIPS_FBSD_TDEP_H
++
++void mips_fbsd_supply_fpregs (struct regcache *, int, const void *, size_t);
++void mips_fbsd_supply_gregs (struct regcache *, int, const void *, size_t);
++void mips_fbsd_collect_fpregs (const struct regcache *, int, void *, size_t);
++void mips_fbsd_collect_gregs (const struct regcache *, int, void *, size_t);
++
++#endif /* MIPS_FBSD_TDEP_H */
diff --git a/devel/gdb-good/files/commit-b268007c68 b/devel/gdb-good/files/commit-b268007c68
new file mode 100644
index 00000000000..86eb3c8971a
--- /dev/null
+++ b/devel/gdb-good/files/commit-b268007c68
@@ -0,0 +1,191 @@
+commit acde9e8dc95a053909e137c1fcda94c719eb8cc1
+Author: John Baldwin <jhb@FreeBSD.org>
+Date:   Wed Jan 4 09:41:58 2017 -0800
+
+    Add native target for FreeBSD/mips.
+    
+    This supports the o32 and n64 ABIs.
+    
+    gdb/ChangeLog:
+    
+            * Makefile.in (ALLDEPFILES): Add mips-fbsd-nat.c.
+            * NEWS: Mention new FreeBSD/mips native configuration.
+            * config/mips/fbsd.mh: New file.
+            * configure.host: Add mips*-*-freebsd*.
+            * mips-fbsd-nat.c: New file.
+
+diff --git gdb/Makefile.in gdb/Makefile.in
+index 300c2cb702..433dd1203a 100644
+--- gdb/Makefile.in
++++ gdb/Makefile.in
+@@ -1725,6 +1725,7 @@ ALLDEPFILES = \
+ 	m88k-tdep.c m88kbsd-nat.c \
+ 	microblaze-tdep.c microblaze-linux-tdep.c \
+ 	mingw-hdep.c common/mingw-strerror.c \
++	mips-fbsd-nat.c \
+ 	mips-fbsd-tdep.c \
+ 	mips-linux-nat.c mips-linux-tdep.c \
+ 	mips-sde-tdep.c \
+diff --git gdb/config/mips/fbsd.mh gdb/config/mips/fbsd.mh
+new file mode 100644
+index 0000000000..f433347a20
+--- /dev/null
++++ gdb/config/mips/fbsd.mh
+@@ -0,0 +1,3 @@
++# Host: FreeBSD/mips
++NATDEPFILES= fork-child.o inf-ptrace.o fbsd-nat.o mips-fbsd-nat.o
++HAVE_NATIVE_GCORE_HOST = 1
+diff --git gdb/configure.host gdb/configure.host
+index ef265ebe29..c45f61dbba 100644
+--- gdb/configure.host
++++ gdb/configure.host
+@@ -129,6 +129,7 @@ m88*-*-openbsd*)	gdb_host=obsd ;;
+ mips*-*-linux*)		gdb_host=linux ;;
+ mips*-*-netbsd* | mips*-*-knetbsd*-gnu)
+ 			gdb_host=nbsd ;;
++mips*-*-freebsd*)	gdb_host=fbsd ;;
+ mips64*-*-openbsd*)	gdb_host=obsd64 ;;
+ 
+ powerpc-*-aix* | rs6000-*-* | powerpc64-*-aix*)
+diff --git gdb/mips-fbsd-nat.c gdb/mips-fbsd-nat.c
+new file mode 100644
+index 0000000000..0472df88f4
+--- /dev/null
++++ gdb/mips-fbsd-nat.c
+@@ -0,0 +1,136 @@
++/* Native-dependent code for FreeBSD/mips.
++
++   Copyright (C) 2017 Free Software Foundation, Inc.
++
++   This file is part of GDB.
++
++   This program is free software; you can redistribute it and/or modify
++   it under the terms of the GNU General Public License as published by
++   the Free Software Foundation; either version 3 of the License, or
++   (at your option) any later version.
++
++   This program is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++   GNU General Public License for more details.
++
++   You should have received a copy of the GNU General Public License
++   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
++
++#include "defs.h"
++#include "inferior.h"
++#include "regcache.h"
++#include "target.h"
++
++#include <sys/types.h>
++#include <sys/ptrace.h>
++#include <machine/reg.h>
++
++#include "fbsd-nat.h"
++#include "mips-tdep.h"
++#include "mips-fbsd-tdep.h"
++#include "inf-ptrace.h"
++
++/* Determine if PT_GETREGS fetches this register.  */
++
++static bool
++getregs_supplies (struct gdbarch *gdbarch, int regnum)
++{
++  return (regnum >= MIPS_ZERO_REGNUM
++	  && regnum <= gdbarch_pc_regnum (gdbarch));
++}
++
++/* Fetch register REGNUM from the inferior.  If REGNUM is -1, do this
++   for all registers.  */
++
++static void
++mips_fbsd_fetch_inferior_registers (struct target_ops *ops,
++				    struct regcache *regcache, int regnum)
++{
++  struct gdbarch *gdbarch = get_regcache_arch (regcache);
++  if (regnum == -1 || getregs_supplies (gdbarch, regnum))
++    {
++      struct reg regs;
++
++      if (ptrace (PT_GETREGS, get_ptrace_pid (inferior_ptid),
++		  (PTRACE_TYPE_ARG3) &regs, 0) == -1)
++	perror_with_name (_("Couldn't get registers"));
++
++      mips_fbsd_supply_gregs (regcache, regnum, &regs, sizeof (register_t));
++      if (regnum != -1)
++	return;
++    }
++
++  if (regnum == -1
++      || regnum >= gdbarch_fp0_regnum (get_regcache_arch (regcache)))
++    {
++      struct fpreg fpregs;
++
++      if (ptrace (PT_GETFPREGS, get_ptrace_pid (inferior_ptid),
++		  (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)
++	perror_with_name (_("Couldn't get floating point status"));
++
++      mips_fbsd_supply_fpregs (regcache, regnum, &fpregs,
++			       sizeof (f_register_t));
++    }
++}
++
++/* Store register REGNUM back into the inferior.  If REGNUM is -1, do
++   this for all registers.  */
++
++static void
++mips_fbsd_store_inferior_registers (struct target_ops *ops,
++				    struct regcache *regcache, int regnum)
++{
++  struct gdbarch *gdbarch = get_regcache_arch (regcache);
++  if (regnum == -1 || getregs_supplies (gdbarch, regnum))
++    {
++      struct reg regs;
++
++      if (ptrace (PT_GETREGS, get_ptrace_pid (inferior_ptid),
++		  (PTRACE_TYPE_ARG3) &regs, 0) == -1)
++	perror_with_name (_("Couldn't get registers"));
++
++      mips_fbsd_collect_gregs (regcache, regnum, (char *) &regs,
++			       sizeof (register_t));
++
++      if (ptrace (PT_SETREGS, get_ptrace_pid (inferior_ptid),
++		  (PTRACE_TYPE_ARG3) &regs, 0) == -1)
++	perror_with_name (_("Couldn't write registers"));
++
++      if (regnum != -1)
++	return;
++    }
++
++  if (regnum == -1
++      || regnum >= gdbarch_fp0_regnum (get_regcache_arch (regcache)))
++    {
++      struct fpreg fpregs;
++
++      if (ptrace (PT_GETFPREGS, get_ptrace_pid (inferior_ptid),
++		  (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)
++	perror_with_name (_("Couldn't get floating point status"));
++
++      mips_fbsd_collect_fpregs (regcache, regnum, (char *) &fpregs,
++				sizeof (f_register_t));
++
++      if (ptrace (PT_SETFPREGS, get_ptrace_pid (inferior_ptid),
++		  (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)
++	perror_with_name (_("Couldn't write floating point status"));
++    }
++}
++
++
++/* Provide a prototype to silence -Wmissing-prototypes.  */
++void _initialize_mips_fbsd_nat (void);
++
++void
++_initialize_mips_fbsd_nat (void)
++{
++  struct target_ops *t;
++
++  t = inf_ptrace_target ();
++  t->to_fetch_registers = mips_fbsd_fetch_inferior_registers;
++  t->to_store_registers = mips_fbsd_store_inferior_registers;
++  fbsd_nat_add_target (t);
++}
diff --git a/devel/gdb-good/files/extrapatch-kgdb b/devel/gdb-good/files/extrapatch-kgdb
new file mode 100644
index 00000000000..78f68e81e4e
--- /dev/null
+++ b/devel/gdb-good/files/extrapatch-kgdb
@@ -0,0 +1,316 @@
+diff --git gdb/Makefile.in gdb/Makefile.in
+index 5b6ccea764..f501cf29d1 100644
+--- gdb/Makefile.in
++++ gdb/Makefile.in
+@@ -212,7 +212,8 @@ INCGNU = -I$(srcdir)/gnulib/import -I$(GNULIB_BUILDDIR)/import
+ 
+ # Generated headers in the gnulib directory.  These must be listed
+ # so that they are generated before other files are compiled.
+-GNULIB_H = $(GNULIB_BUILDDIR)/import/string.h @GNULIB_STDINT_H@
++GNULIB_H = $(GNULIB_BUILDDIR)/import/string.h \
++	$(GNULIB_BUILDDIR)/import/alloca.h @GNULIB_STDINT_H@
+ 
+ #
+ # CLI sub directory definitons
+@@ -653,7 +654,8 @@ ALL_64_TARGET_OBS = \
+ 	ia64-linux-tdep.o ia64-vms-tdep.o ia64-tdep.o \
+ 	mips64obsd-tdep.o \
+ 	sparc64fbsd-tdep.o sparc64-linux-tdep.o sparc64nbsd-tdep.o \
+-	sparc64obsd-tdep.o sparc64-sol2-tdep.o sparc64-tdep.o
++	sparc64obsd-tdep.o sparc64-sol2-tdep.o sparc64-tdep.o \
++	amd64fbsd-kern.o sparc64fbsd-kern.o
+ 
+ # All other target-dependent objects files (used with --enable-targets=all).
+ ALL_TARGET_OBS = \
+@@ -676,6 +678,8 @@ ALL_TARGET_OBS = \
+ 	i386-sol2-tdep.o i386-tdep.o i387-tdep.o \
+ 	i386-dicos-tdep.o i386-darwin-tdep.o \
+ 	iq2000-tdep.o \
++	fbsd-kld.o fbsd-kthr.o fbsd-kvm.o i386fbsd-kern.o ppcfbsd-kern.o \
++	mipsfbsd-kern.o \
+ 	linux-tdep.o \
+ 	lm32-tdep.o \
+ 	m32c-tdep.o \
+@@ -1133,7 +1137,7 @@ generated_files = config.h observer.h observer.inc ada-lex.c jit-reader.h \
+ 	$(COMPILE) $<
+ 	$(POSTCOMPILE)
+ 
+-all: gdb$(EXEEXT) $(CONFIG_ALL)
++all: gdb$(EXEEXT) kgdb$(EXEEXT) $(CONFIG_ALL)
+ 	@$(MAKE) $(FLAGS_TO_PASS) DO=all "DODIRS=`echo $(SUBDIRS) | sed 's/testsuite//'`" subdir_do
+ 
+ installcheck:
+@@ -1412,6 +1416,12 @@ gdb$(EXEEXT): gdb.o $(LIBGDB_OBS) $(ADD_DEPS) $(CDEPS) $(TDEPLIBS)
+ 		-o gdb$(EXEEXT) gdb.o $(LIBGDB_OBS) \
+ 		$(TDEPLIBS) $(TUI_LIBRARY) $(CLIBS) $(LOADLIBES)
+ 
++kgdb$(EXEEXT): kgdb-main.o $(LIBGDB_OBS) $(ADD_DEPS) $(CDEPS) $(TDEPLIBS)
++	rm -f kgdb$(EXEEXT)
++	$(CC_LD) $(INTERNAL_LDFLAGS) $(WIN32LDAPP) \
++		-o kgdb$(EXEEXT) kgdb-main.o $(LIBGDB_OBS) \
++		$(TDEPLIBS) $(TUI_LIBRARY) $(CLIBS) $(LOADLIBES)
++
+ # Convenience rule to handle recursion.
+ $(LIBGNU) $(GNULIB_H): all-lib
+ all-lib: $(GNULIB_BUILDDIR)/Makefile
+@@ -1456,7 +1466,7 @@ clean mostlyclean: $(CONFIG_CLEAN)
+ 	@$(MAKE) $(FLAGS_TO_PASS) DO=clean "DODIRS=$(CLEANDIRS)" subdir_do
+ 	rm -f *.o *.a $(ADD_FILES) *~ init.c-tmp init.l-tmp version.c-tmp
+ 	rm -f init.c version.c observer.h observer.inc
+-	rm -f gdb$(EXEEXT) core make.log
++	rm -f gdb$(EXEEXT) core make.log kgdb$(EXEEXT)
+ 	rm -f gdb[0-9]$(EXEEXT)
+ 	rm -f test-cp-name-parser$(EXEEXT)
+ 	rm -f xml-builtin.c stamp-xml
+@@ -1688,6 +1698,9 @@ ALLDEPFILES = \
+ 	core-regset.c \
+ 	dcache.c dicos-tdep.c darwin-nat.c \
+ 	exec.c \
++	fbsd-kld.c fbsd-kthr.c fbsd-kvm.c \
++	amd64fbsd-kern.c i386fbsd-kern.c mipsfbsd-kern.c ppcfbsd-kern.c \
++	sparc64fbsd-kern.c \
+ 	fbsd-nat.c \
+ 	fbsd-tdep.c \
+ 	fork-child.c \
+@@ -2761,7 +2774,7 @@ py-varobj.o: $(srcdir)/python/py-varobj.c
+ 
+ # A list of all the objects we might care about in this build, for
+ # dependency tracking.
+-all_object_files = gdb.o $(LIBGDB_OBS) gdbtk-main.o \
++all_object_files = kgdb-main.o gdb.o $(LIBGDB_OBS) gdbtk-main.o \
+ 	test-cp-name-parser.o
+ 
+ # Ensure that generated files are created early.  Use order-only
+diff --git gdb/config.in gdb/config.in
+index c82a5b4bac..34140b2d59 100644
+--- gdb/config.in
++++ gdb/config.in
+@@ -219,6 +219,9 @@
+ /* Define to 1 if your system has the kinfo_getvmmap function. */
+ #undef HAVE_KINFO_GETVMMAP
+ 
++/* Define to 1 if your system has the kvm_open2 function. */
++#undef HAVE_KVM_OPEN2
++
+ /* Define if you have <langinfo.h> and nl_langinfo(CODESET). */
+ #undef HAVE_LANGINFO_CODESET
+ 
+diff --git gdb/config/mips/fbsd.mh gdb/config/mips/fbsd.mh
+index f433347a20..5470795612 100644
+--- gdb/config/mips/fbsd.mh
++++ gdb/config/mips/fbsd.mh
+@@ -1,3 +1,5 @@
+ # Host: FreeBSD/mips
+ NATDEPFILES= fork-child.o inf-ptrace.o fbsd-nat.o mips-fbsd-nat.o
+ HAVE_NATIVE_GCORE_HOST = 1
++
++LOADLIBES= -lkvm
+diff --git gdb/configure gdb/configure
+index b5c045cf10..68299ff16c 100755
+--- gdb/configure
++++ gdb/configure
+@@ -7112,6 +7112,66 @@ $as_echo "#define HAVE_KINFO_GETVMMAP 1" >>confdefs.h
+ fi
+ 
+ 
++# kgdb needs kvm_open2 for cross-debugging
++{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing kvm_open2" >&5
++$as_echo_n "checking for library containing kvm_open2... " >&6; }
++if test "${ac_cv_search_kvm_open2+set}" = set; then :
++  $as_echo_n "(cached) " >&6
++else
++  ac_func_search_save_LIBS=$LIBS
++cat confdefs.h - <<_ACEOF >conftest.$ac_ext
++/* end confdefs.h.  */
++
++/* Override any GCC internal prototype to avoid an error.
++   Use char because int might match the return type of a GCC
++   builtin and then its argument prototype would still apply.  */
++#ifdef __cplusplus
++extern "C"
++#endif
++char kvm_open2 ();
++int
++main ()
++{
++return kvm_open2 ();
++  ;
++  return 0;
++}
++_ACEOF
++for ac_lib in '' kvm; do
++  if test -z "$ac_lib"; then
++    ac_res="none required"
++  else
++    ac_res=-l$ac_lib
++    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
++  fi
++  if ac_fn_c_try_link "$LINENO"; then :
++  ac_cv_search_kvm_open2=$ac_res
++fi
++rm -f core conftest.err conftest.$ac_objext \
++    conftest$ac_exeext
++  if test "${ac_cv_search_kvm_open2+set}" = set; then :
++  break
++fi
++done
++if test "${ac_cv_search_kvm_open2+set}" = set; then :
++
++else
++  ac_cv_search_kvm_open2=no
++fi
++rm conftest.$ac_ext
++LIBS=$ac_func_search_save_LIBS
++fi
++{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_kvm_open2" >&5
++$as_echo "$ac_cv_search_kvm_open2" >&6; }
++ac_res=$ac_cv_search_kvm_open2
++if test "$ac_res" != no; then :
++  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
++
++$as_echo "#define HAVE_KVM_OPEN2 1" >>confdefs.h
++
++fi
++
++
+ 
+       if test "X$prefix" = "XNONE"; then
+     acl_final_prefix="$ac_default_prefix"
+diff --git gdb/configure.ac gdb/configure.ac
+index f774db7ea6..efccdd3fb1 100644
+--- gdb/configure.ac
++++ gdb/configure.ac
+@@ -540,6 +540,11 @@ AC_SEARCH_LIBS(kinfo_getvmmap, util util-freebsd,
+   [AC_DEFINE(HAVE_KINFO_GETVMMAP, 1,
+             [Define to 1 if your system has the kinfo_getvmmap function. ])])
+ 
++# kgdb needs kvm_open2 for cross-debugging
++AC_SEARCH_LIBS(kvm_open2, kvm,
++  [AC_DEFINE(HAVE_KVM_OPEN2, 1,
++            [Define to 1 if your system has the kvm_open2 function. ])])
++
+ AM_ICONV
+ 
+ # GDB may fork/exec the iconv program to get the list of supported character
+diff --git gdb/configure.tgt gdb/configure.tgt
+index 9ee9f7a799..fb14b19405 100644
+--- gdb/configure.tgt
++++ gdb/configure.tgt
+@@ -190,7 +190,13 @@ i[34567]86-*-dicos*)
+ i[34567]86-*-freebsd* | i[34567]86-*-kfreebsd*-gnu)
+ 	# Target: FreeBSD/i386
+ 	gdb_target_obs="i386-tdep.o i387-tdep.o i386bsd-tdep.o i386fbsd-tdep.o \
+-			bsd-uthread.o fbsd-tdep.o solib-svr4.o"
++			bsd-uthread.o fbsd-tdep.o solib-svr4.o \
++			fbsd-kld.o fbsd-kthr.o fbsd-kvm.o i386fbsd-kern.o"
++	if test "x$enable_64_bit_bfd" = "xyes"; then
++	    # Target: FreeBSD amd64
++	    gdb_target_obs="amd64-tdep.o amd64fbsd-tdep.o amd64fbsd-kern.o \
++			    ${gdb_target_obs}"
++	fi
+ 	;;
+ i[34567]86-*-netbsd* | i[34567]86-*-knetbsd*-gnu)
+ 	# Target: NetBSD/i386
+@@ -360,7 +366,8 @@ mips*-*-netbsd* | mips*-*-knetbsd*-gnu)
+ 	;;
+ mips*-*-freebsd*)
+ 	# Target: MIPS running FreeBSD
+-	gdb_target_obs="mips-tdep.o mips-fbsd-tdep.o solib-svr4.o fbsd-tdep.o"
++	gdb_target_obs="mips-tdep.o mips-fbsd-tdep.o solib-svr4.o fbsd-tdep.o \
++			fbsd-kld.o fbsd-kthr.o fbsd-kvm.o mipsfbsd-kern.o"
+ 	gdb_sim=../sim/mips/libsim.a
+ 	;;
+ mips64*-*-openbsd*)
+@@ -419,7 +426,8 @@ powerpc*-*-freebsd*)
+ 	# Target: FreeBSD/powerpc
+ 	gdb_target_obs="rs6000-tdep.o ppc-sysv-tdep.o ppc64-tdep.o \
+ 		        ppcfbsd-tdep.o fbsd-tdep.o solib-svr4.o \
+-			ravenscar-thread.o ppc-ravenscar-thread.o"
++			ravenscar-thread.o ppc-ravenscar-thread.o \
++			fbsd-kld.o fbsd-kthr.o fbsd-kvm.o ppcfbsd-kern.o"
+ 	;;
+ 
+ powerpc-*-netbsd* | powerpc-*-knetbsd*-gnu)
+@@ -543,7 +551,8 @@ sparc*-*-freebsd* | sparc*-*-kfreebsd*-gnu)
+ 	# Target: FreeBSD/sparc64
+ 	gdb_target_obs="sparc-tdep.o sparc64-tdep.o sparc64fbsd-tdep.o \
+ 			fbsd-tdep.o solib-svr4.o \
+-			ravenscar-thread.o sparc-ravenscar-thread.o"
++			ravenscar-thread.o sparc-ravenscar-thread.o \
++			fbsd-kld.o fbsd-kthr.o fbsd-kvm.o sparc64fbsd-kern.o"
+ 	;;
+ sparc-*-netbsd* | sparc-*-knetbsd*-gnu)
+ 	# Target: NetBSD/sparc
+@@ -674,7 +683,9 @@ x86_64-*-freebsd* | x86_64-*-kfreebsd*-gnu)
+ 	# Target: FreeBSD/amd64
+ 	gdb_target_obs="amd64-tdep.o amd64fbsd-tdep.o i386-tdep.o \
+ 			i387-tdep.o i386bsd-tdep.o i386fbsd-tdep.o \
+-			bsd-uthread.o fbsd-tdep.o solib-svr4.o"
++			bsd-uthread.o fbsd-tdep.o solib-svr4.o \
++			fbsd-kld.o fbsd-kthr.o fbsd-kvm.o amd64fbsd-kern.o \
++			i386fbsd-kern.o"
+ 	;;
+ x86_64-*-mingw* | x86_64-*-cygwin*)
+         # Target: MingW/amd64
+diff --git gdb/defs.h gdb/defs.h
+index 9b44f44349..f176be1108 100644
+--- gdb/defs.h
++++ gdb/defs.h
+@@ -598,6 +598,7 @@ enum gdb_osabi
+   GDB_OSABI_LINUX,
+   GDB_OSABI_FREEBSD_AOUT,
+   GDB_OSABI_FREEBSD_ELF,
++  GDB_OSABI_FREEBSD_ELF_KERNEL,
+   GDB_OSABI_NETBSD_AOUT,
+   GDB_OSABI_NETBSD_ELF,
+   GDB_OSABI_OPENBSD_ELF,
+diff --git gdb/osabi.c gdb/osabi.c
+index f7d4e74239..130ffef37e 100644
+--- gdb/osabi.c
++++ gdb/osabi.c
+@@ -66,6 +66,7 @@ static const struct osabi_names gdb_osabi_names[] =
+   { "GNU/Linux", "linux(-gnu)?" },
+   { "FreeBSD/a.out", NULL },
+   { "FreeBSD/ELF", NULL },
++  { "FreeBSD/kernel", NULL },
+   { "NetBSD/a.out", NULL },
+   { "NetBSD/ELF", NULL },
+   { "OpenBSD/ELF", NULL },
+diff --git gdb/regcache.c gdb/regcache.c
+index a5c90a6314..05044e5293 100644
+--- gdb/regcache.c
++++ gdb/regcache.c
+@@ -1083,6 +1083,20 @@ regcache_raw_supply (struct regcache *regcache, int regnum, const void *buf)
+     }
+ }
+ 
++void
++regcache_raw_supply_unsigned (struct regcache *regcache, int regnum,
++			      ULONGEST val)
++{
++  gdb_byte *buf;
++
++  gdb_assert (regcache != NULL);
++  gdb_assert (regnum >=0 && regnum < regcache->descr->nr_raw_registers);
++  buf = (gdb_byte *)alloca (regcache->descr->sizeof_register[regnum]);
++  store_unsigned_integer (buf, regcache->descr->sizeof_register[regnum],
++			  gdbarch_byte_order (regcache->descr->gdbarch), val);
++  regcache_raw_supply (regcache, regnum, buf);
++}
++
+ /* Collect register REGNUM from REGCACHE and store its contents in BUF.  */
+ 
+ void
+diff --git gdb/regcache.h gdb/regcache.h
+index 1bb0ce0ec8..65783b6355 100644
+--- gdb/regcache.h
++++ gdb/regcache.h
+@@ -135,6 +135,8 @@ extern void regcache_write_pc (struct regcache *regcache, CORE_ADDR pc);
+ 
+ extern void regcache_raw_supply (struct regcache *regcache,
+ 				 int regnum, const void *buf);
++extern void regcache_raw_supply_unsigned (struct regcache *regcache,
++					  int regnum, ULONGEST val);
+ extern void regcache_raw_collect (const struct regcache *regcache,
+ 				  int regnum, void *buf);
+ 
diff --git a/devel/gdb-good/files/kgdb/amd64fbsd-kern.c b/devel/gdb-good/files/kgdb/amd64fbsd-kern.c
new file mode 100644
index 00000000000..70b5f317ec9
--- /dev/null
+++ b/devel/gdb-good/files/kgdb/amd64fbsd-kern.c
@@ -0,0 +1,304 @@
+/*
+ * Copyright (c) 2004 Marcel Moolenaar
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: head/devel/gdb/files/kgdb/amd64fbsd-kern.c 428876 2016-12-18 16:08:14Z tijl $");
+
+#include <sys/types.h>
+#ifdef __amd64__
+#include <machine/pcb.h>
+#include <machine/frame.h>
+#endif
+#include <string.h>
+
+#include <defs.h>
+#include <frame-unwind.h>
+#include "gdbcore.h"
+#include "osabi.h"
+#include <regcache.h>
+#include "solib.h"
+#include "stack.h"
+#include "symtab.h"
+#include "trad-frame.h"
+#include <amd64-tdep.h>
+
+#include "kgdb.h"
+
+static const int amd64fbsd_pcb_offset[] = {
+  -1,				/* %rax */
+  6 * 8,			/* %rbx */
+  -1,				/* %rcx */
+  -1,				/* %rdx */
+  -1,				/* %rsi */
+  -1,				/* %rdi */
+  4 * 8,			/* %rbp */
+  5 * 8,			/* %rsp */
+  -1,				/* %r8 ...  */
+  -1,
+  -1,
+  -1,
+  3 * 8,
+  2 * 8,
+  1 * 8,
+  0 * 8,			/* ... %r15 */
+  7 * 8,			/* %rip */
+  -1,				/* %eflags */
+  -1,				/* %cs */
+  -1,				/* %ss */
+  -1,				/* %ds */
+  -1,				/* %es */
+  -1,				/* %fs */
+  -1				/* %gs */
+};
+
+#define	CODE_SEL	(4 << 3)
+#define	DATA_SEL	(5 << 3)
+
+static void
+amd64fbsd_supply_pcb(struct regcache *regcache, CORE_ADDR pcb_addr)
+{
+  gdb_byte buf[8];
+  int i;
+  
+  for (i = 0; i < ARRAY_SIZE (amd64fbsd_pcb_offset); i++)
+    if (amd64fbsd_pcb_offset[i] != -1) {
+      if (target_read_memory(pcb_addr + amd64fbsd_pcb_offset[i], buf,
+			     sizeof buf) != 0)
+	continue;
+      regcache_raw_supply(regcache, i, buf);
+    }
+
+  regcache_raw_supply_unsigned(regcache, AMD64_CS_REGNUM, CODE_SEL);
+  regcache_raw_supply_unsigned(regcache, AMD64_SS_REGNUM, DATA_SEL);
+}
+
+static const int amd64fbsd_trapframe_offset[] = {
+  6 * 8,			/* %rax */
+  7 * 8,			/* %rbx */
+  3 * 8,			/* %rcx */
+  2 * 8,			/* %rdx */
+  1 * 8,			/* %rsi */
+  0 * 8,			/* %rdi */
+  8 * 8,			/* %rbp */
+  22 * 8,			/* %rsp */
+  4 * 8,			/* %r8 ...  */
+  5 * 8,
+  9 * 8,
+  10 * 8,
+  11 * 8,
+  12 * 8,
+  13 * 8,
+  14 * 8,			/* ... %r15 */
+  19 * 8,			/* %rip */
+  21 * 8,			/* %eflags */
+  20 * 8,			/* %cs */
+  23 * 8,			/* %ss */
+  -1,				/* %ds */
+  -1,				/* %es */
+  -1,				/* %fs */
+  -1				/* %gs */
+};
+
+#define TRAPFRAME_SIZE	192
+
+static struct trad_frame_cache *
+amd64fbsd_trapframe_cache (struct frame_info *this_frame, void **this_cache)
+{
+  struct gdbarch *gdbarch = get_frame_arch (this_frame);
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+  struct trad_frame_cache *cache;
+  CORE_ADDR addr, func, pc, sp;
+  const char *name;
+  int i;
+
+  if (*this_cache != NULL)
+    return ((struct trad_frame_cache *)*this_cache);
+
+  cache = trad_frame_cache_zalloc (this_frame);
+  *this_cache = cache;
+
+  func = get_frame_func (this_frame);
+  sp = get_frame_register_unsigned (this_frame, AMD64_RSP_REGNUM);
+
+  find_pc_partial_function (func, &name, NULL, NULL);
+  if (strcmp(name, "fork_trampoline") == 0 && get_frame_pc (this_frame) == func)
+    {
+      /* fork_exit hasn't been called (kthread has never run), so %rsp
+	 in the pcb points to the trapframe.  GDB has auto-adjusted
+	 %rsp for this frame to account for the "call" into
+	 fork_trampoline, so "undo" the adjustment.  */
+      sp += 8;
+    }
+  
+  for (i = 0; i < ARRAY_SIZE (amd64fbsd_trapframe_offset); i++)
+    if (amd64fbsd_trapframe_offset[i] != -1)
+      trad_frame_set_reg_addr (cache, i, sp + amd64fbsd_trapframe_offset[i]);
+
+  /* Read %rip from trap frame.  */
+  addr = sp + amd64fbsd_trapframe_offset[AMD64_RIP_REGNUM];
+  pc = read_memory_unsigned_integer (addr, 8, byte_order);
+
+  if (pc == 0 && strcmp(name, "fork_trampoline") == 0)
+    {
+      /* Initial frame of a kthread; terminate backtrace.  */
+      trad_frame_set_id (cache, outer_frame_id);
+    }
+  else
+    {
+      /* Construct the frame ID using the function start.  */
+      trad_frame_set_id (cache, frame_id_build (sp + TRAPFRAME_SIZE, func));
+    }
+
+  return cache;
+}
+
+static void
+amd64fbsd_trapframe_this_id (struct frame_info *this_frame,
+			     void **this_cache, struct frame_id *this_id)
+{
+  struct trad_frame_cache *cache =
+    amd64fbsd_trapframe_cache (this_frame, this_cache);
+  
+  trad_frame_get_id (cache, this_id);
+}
+
+static struct value *
+amd64fbsd_trapframe_prev_register (struct frame_info *this_frame,
+				   void **this_cache, int regnum)
+{
+  struct trad_frame_cache *cache =
+    amd64fbsd_trapframe_cache (this_frame, this_cache);
+
+  return trad_frame_get_register (cache, this_frame, regnum);
+}
+
+static int
+amd64fbsd_trapframe_sniffer (const struct frame_unwind *self,
+			     struct frame_info *this_frame,
+			     void **this_prologue_cache)
+{
+  const char *name;
+
+  find_pc_partial_function (get_frame_func (this_frame), &name, NULL, NULL);
+  return (name && ((strcmp (name, "calltrap") == 0)
+		   || (strcmp (name, "fork_trampoline") == 0)
+		   || (strcmp (name, "nmi_calltrap") == 0)
+		   || (name[0] == 'X' && name[1] != '_')));
+}
+
+static const struct frame_unwind amd64fbsd_trapframe_unwind = {
+  SIGTRAMP_FRAME,
+  default_frame_unwind_stop_reason,
+  amd64fbsd_trapframe_this_id,
+  amd64fbsd_trapframe_prev_register,
+  NULL,
+  amd64fbsd_trapframe_sniffer
+};
+
+static void
+amd64fbsd_kernel_init_abi(struct gdbarch_info info, struct gdbarch *gdbarch)
+{
+
+	amd64_init_abi(info, gdbarch);
+
+	frame_unwind_prepend_unwinder(gdbarch, &amd64fbsd_trapframe_unwind);
+
+	set_solib_ops(gdbarch, &kld_so_ops);
+
+	fbsd_vmcore_set_supply_pcb(gdbarch, amd64fbsd_supply_pcb);
+	fbsd_vmcore_set_cpu_pcb_addr(gdbarch, kgdb_trgt_stop_pcb);
+}
+
+void _initialize_amd64_kgdb_tdep(void);
+
+void
+_initialize_amd64_kgdb_tdep(void)
+{
+	gdbarch_register_osabi (bfd_arch_i386, bfd_mach_x86_64,
+	    GDB_OSABI_FREEBSD_ELF_KERNEL, amd64fbsd_kernel_init_abi);
+
+#ifdef __amd64__
+	gdb_assert(offsetof(struct pcb, pcb_rbx)
+		   == amd64fbsd_pcb_offset[AMD64_RBX_REGNUM]);
+	gdb_assert(offsetof(struct pcb, pcb_rbp)
+		   == amd64fbsd_pcb_offset[AMD64_RBP_REGNUM]);
+	gdb_assert(offsetof(struct pcb, pcb_rsp)
+		   == amd64fbsd_pcb_offset[AMD64_RSP_REGNUM]);
+	gdb_assert(offsetof(struct pcb, pcb_r12)
+		   == amd64fbsd_pcb_offset[AMD64_R12_REGNUM]);
+	gdb_assert(offsetof(struct pcb, pcb_r13)
+		   == amd64fbsd_pcb_offset[AMD64_R13_REGNUM]);
+	gdb_assert(offsetof(struct pcb, pcb_r14)
+		   == amd64fbsd_pcb_offset[AMD64_R14_REGNUM]);
+	gdb_assert(offsetof(struct pcb, pcb_r15)
+		   == amd64fbsd_pcb_offset[AMD64_R15_REGNUM]);
+	gdb_assert(offsetof(struct pcb, pcb_rip)
+		   == amd64fbsd_pcb_offset[AMD64_RIP_REGNUM]);
+	gdb_assert(CODE_SEL == GSEL(GCODE_SEL, SEL_KPL));
+	gdb_assert(DATA_SEL == GSEL(GDATA_SEL, SEL_KPL));
+	gdb_assert(sizeof(struct trapframe) == TRAPFRAME_SIZE);
+	gdb_assert(offsetof(struct trapframe, tf_rax)
+		   == amd64fbsd_trapframe_offset[AMD64_RAX_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_rbx)
+		   == amd64fbsd_trapframe_offset[AMD64_RBX_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_rcx)
+		   == amd64fbsd_trapframe_offset[AMD64_RCX_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_rdx)
+		   == amd64fbsd_trapframe_offset[AMD64_RDX_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_rsi)
+		   == amd64fbsd_trapframe_offset[AMD64_RSI_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_rdi)
+		   == amd64fbsd_trapframe_offset[AMD64_RDI_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_rbp)
+		   == amd64fbsd_trapframe_offset[AMD64_RBP_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_rsp)
+		   == amd64fbsd_trapframe_offset[AMD64_RSP_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_r8)
+		   == amd64fbsd_trapframe_offset[AMD64_R8_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_r9)
+		   == amd64fbsd_trapframe_offset[AMD64_R9_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_r10)
+		   == amd64fbsd_trapframe_offset[AMD64_R10_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_r11)
+		   == amd64fbsd_trapframe_offset[AMD64_R11_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_r12)
+		   == amd64fbsd_trapframe_offset[AMD64_R12_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_r13)
+		   == amd64fbsd_trapframe_offset[AMD64_R13_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_r14)
+		   == amd64fbsd_trapframe_offset[AMD64_R14_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_r15)
+		   == amd64fbsd_trapframe_offset[AMD64_R15_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_rip)
+		   == amd64fbsd_trapframe_offset[AMD64_RIP_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_rflags)
+		   == amd64fbsd_trapframe_offset[AMD64_EFLAGS_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_cs)
+		   == amd64fbsd_trapframe_offset[AMD64_CS_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_ss)
+		   == amd64fbsd_trapframe_offset[AMD64_SS_REGNUM]);
+#endif
+}
diff --git a/devel/gdb-good/files/kgdb/fbsd-kld.c b/devel/gdb-good/files/kgdb/fbsd-kld.c
new file mode 100644
index 00000000000..22f79daab49
--- /dev/null
+++ b/devel/gdb-good/files/kgdb/fbsd-kld.c
@@ -0,0 +1,592 @@
+/*
+ * Copyright (c) 2004 Marcel Moolenaar
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: head/devel/gdb/files/kgdb/fbsd-kld.c 440447 2017-05-08 19:02:25Z jhb $");
+
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <libgen.h>
+
+#include <defs.h>
+#include <command.h>
+#include <completer.h>
+#include <environ.h>
+#include <exec.h>
+#include <frame-unwind.h>
+#include <inferior.h>
+#include <objfiles.h>
+#include <gdbcore.h>
+#include <language.h>
+#include "solib.h"
+#include <solist.h>
+
+#include "kgdb.h"
+
+struct lm_info {
+	CORE_ADDR base_address;
+};
+
+struct kld_info {
+	/* Offsets of fields in linker_file structure. */
+	CORE_ADDR off_address, off_filename, off_pathname, off_next;
+
+	/* KVA of 'linker_path' which corresponds to the kern.module_path sysctl .*/
+	CORE_ADDR module_path_addr;
+	CORE_ADDR linker_files_addr;
+	CORE_ADDR kernel_file_addr;
+};
+
+struct target_so_ops kld_so_ops;
+
+/* Per-program-space data key.  */
+static const struct program_space_data *kld_pspace_data;
+
+static void
+kld_pspace_data_cleanup (struct program_space *pspace, void *arg)
+{
+  struct kld_info *info = (struct kld_info *)arg;
+
+  xfree (info);
+}
+
+/* Get the current kld data.  If none is found yet, add it now.  This
+   function always returns a valid object.  */
+
+static struct kld_info *
+get_kld_info (void)
+{
+  struct kld_info *info;
+
+  info = (struct kld_info *)
+    program_space_data (current_program_space, kld_pspace_data);
+  if (info != NULL)
+    return info;
+
+  info = XCNEW (struct kld_info);
+  set_program_space_data (current_program_space, kld_pspace_data, info);
+  return info;
+}
+
+static int
+kld_ok (char *path)
+{
+	struct stat sb;
+
+	if (stat(path, &sb) == 0 && S_ISREG(sb.st_mode))
+		return (1);
+	return (0);
+}
+
+/*
+ * Look for a matching file checking for debug suffixes before the raw file:
+ * - filename + ".debug" (e.g. foo.ko.debug)
+ * - filename (e.g. foo.ko)
+ */
+static const char *kld_suffixes[] = {
+	".debug",
+	".symbols",
+	"",
+	NULL
+};
+
+static int
+check_kld_path (char *path, size_t path_size)
+{
+	const char **suffix;
+	char *ep;
+
+	ep = path + strlen(path);
+	suffix = kld_suffixes;
+	while (*suffix != NULL) {
+		if (strlcat(path, *suffix, path_size) < path_size) {
+			if (kld_ok(path))
+				return (1);
+		}
+
+		/* Restore original path to remove suffix. */
+		*ep = '\0';
+		suffix++;
+	}
+	return (0);
+}
+
+/*
+ * Try to find the path for a kld by looking in the kernel's directory and
+ * in the various paths in the module path.
+ */
+static int
+find_kld_path (char *filename, char *path, size_t path_size)
+{
+	struct kld_info *info;
+	struct cleanup *cleanup;
+	char *module_path;
+	char *kernel_dir, *module_dir, *cp;
+	int error;
+
+	info = get_kld_info();
+	if (exec_bfd) {
+		kernel_dir = ldirname(bfd_get_filename(exec_bfd));
+		if (kernel_dir != NULL) {
+			cleanup = make_cleanup(xfree, kernel_dir);
+			snprintf(path, path_size, "%s/%s", kernel_dir,
+			    filename);
+			if (check_kld_path(path, path_size)) {
+				do_cleanups(cleanup);
+				return (1);
+			}
+			do_cleanups(cleanup);
+		}
+	}
+	if (info->module_path_addr != 0) {
+		target_read_string(info->module_path_addr, &module_path,
+		    PATH_MAX, &error);
+		if (error == 0) {
+			cleanup = make_cleanup(xfree, module_path);
+			cp = module_path;
+			while ((module_dir = strsep(&cp, ";")) != NULL) {
+				snprintf(path, path_size, "%s/%s", module_dir,
+				    filename);
+				if (check_kld_path(path, path_size)) {
+					do_cleanups(cleanup);
+					return (1);
+				}
+			}
+			do_cleanups(cleanup);
+		}
+	}
+	return (0);
+}
+
+/*
+ * Read a kernel pointer given a KVA in 'address'.
+ */
+static CORE_ADDR
+read_pointer (CORE_ADDR address)
+{
+	struct type *ptr_type;
+	gdb_byte ptr_buf[8];
+	int arch_size;
+
+	arch_size = bfd_get_arch_size (exec_bfd);
+	if (arch_size == -1)
+		return (0);
+	ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;
+	if (target_read_memory(address, ptr_buf, arch_size / 8) != 0)
+		return (0);
+	return (extract_typed_address (ptr_buf, ptr_type));
+}
+
+/*
+ * Try to find this kld in the kernel linker's list of linker files.
+ */
+static int
+find_kld_address (char *arg, CORE_ADDR *address)
+{
+	struct kld_info *info;
+	CORE_ADDR kld;
+	char *kld_filename;
+	const char *filename;
+	int error;
+
+	info = get_kld_info();
+	if (info->linker_files_addr == 0 || info->off_address == 0 ||
+	    info->off_filename == 0 || info->off_next == 0)
+		return (0);
+
+	filename = lbasename(arg);
+	for (kld = read_pointer(info->linker_files_addr); kld != 0;
+	     kld = read_pointer(kld + info->off_next)) {
+		/* Try to read this linker file's filename. */
+		target_read_string(read_pointer(kld + info->off_filename),
+		    &kld_filename, PATH_MAX, &error);
+		if (error)
+			continue;
+
+		/* Compare this kld's filename against our passed in name. */
+		if (strcmp(kld_filename, filename) != 0) {
+			xfree(kld_filename);
+			continue;
+		}
+		xfree(kld_filename);
+
+		/*
+		 * We found a match, use its address as the base
+		 * address if we can read it.
+		 */
+		*address = read_pointer(kld + info->off_address);
+		if (*address == 0)
+			return (0);
+		return (1);
+	}
+	return (0);
+}
+
+static void
+adjust_section_address (struct target_section *sec, CORE_ADDR *curr_base)
+{
+	struct bfd_section *asect = sec->the_bfd_section;
+	bfd *abfd = asect->owner;
+
+	if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0) {
+		sec->addr += *curr_base;
+		sec->endaddr += *curr_base;
+		return;
+	}
+
+	*curr_base = align_power(*curr_base,
+	    bfd_get_section_alignment(abfd, asect));
+	sec->addr = *curr_base;
+	sec->endaddr = sec->addr + bfd_section_size(abfd, asect);
+	*curr_base = sec->endaddr;
+}
+
+static void
+load_kld (char *path, CORE_ADDR base_addr, int from_tty)
+{
+	struct section_addr_info *sap;
+	struct target_section *sections = NULL, *sections_end = NULL, *s;
+	struct cleanup *cleanup;
+	bfd *bfd;
+	CORE_ADDR curr_addr;
+	int add_flags, i;
+
+	/* Open the kld. */
+	bfd = bfd_openr(path, gnutarget);
+	if (bfd == NULL)
+		error("\"%s\": can't open: %s", path,
+		    bfd_errmsg(bfd_get_error()));
+	cleanup = make_cleanup_bfd_unref(bfd);
+
+	if (!bfd_check_format(bfd, bfd_object))
+		error("\%s\": not an object file", path);
+
+	/* Make sure we have a .text section. */
+	if (bfd_get_section_by_name (bfd, ".text") == NULL)
+		error("\"%s\": can't find text section", path);
+
+	/* Build a section table from the bfd and relocate the sections. */
+	if (build_section_table (bfd, &sections, &sections_end))
+		error("\"%s\": can't find file sections", path);
+	make_cleanup(xfree, sections);
+	curr_addr = base_addr;
+	for (s = sections; s < sections_end; s++)
+		adjust_section_address(s, &curr_addr);
+
+	/* Build a section addr info to pass to symbol_file_add(). */
+	sap = build_section_addr_info_from_section_table (sections,
+	    sections_end);
+	make_cleanup((make_cleanup_ftype *)free_section_addr_info, sap);
+
+	printf_unfiltered("add symbol table from file \"%s\" at\n", path);
+	for (i = 0; i < sap->num_sections; i++)
+		printf_unfiltered("\t%s_addr = %s\n", sap->other[i].name,
+		    paddress(target_gdbarch(), sap->other[i].addr));		
+
+	if (from_tty && (!query("%s", "")))
+		error("Not confirmed.");
+
+	add_flags = 0;
+	if (from_tty)
+		add_flags |= SYMFILE_VERBOSE;
+	symbol_file_add(path, add_flags, sap, OBJF_USERLOADED);
+
+	do_cleanups(cleanup);
+}
+
+static void
+kgdb_add_kld_cmd (char *arg, int from_tty)
+{
+	char path[PATH_MAX];
+	CORE_ADDR base_addr;
+
+	if (!exec_bfd)
+		error("No kernel symbol file");
+
+	/* Try to open the raw path to handle absolute paths first. */
+	snprintf(path, sizeof(path), "%s", arg);
+	if (!check_kld_path(path, sizeof(path))) {
+
+		/*
+		 * If that didn't work, look in the various possible
+		 * paths for the module.
+		 */
+		if (!find_kld_path(arg, path, sizeof(path))) {
+			error("Unable to locate kld");
+			return;
+		}
+	}
+
+	if (!find_kld_address(arg, &base_addr)) {
+		error("Unable to find kld in kernel");
+		return;
+	}
+
+	load_kld(path, base_addr, from_tty);
+
+	reinit_frame_cache();
+}
+
+static void
+kld_relocate_section_addresses (struct so_list *so, struct target_section *sec)
+{
+	static CORE_ADDR curr_addr;
+
+	if (sec == so->sections)
+		curr_addr = so->lm_info->base_address;
+
+	adjust_section_address(sec, &curr_addr);
+}
+
+static void
+kld_free_so (struct so_list *so)
+{
+
+	xfree(so->lm_info);
+}
+
+static void
+kld_clear_so (struct so_list *so)
+{
+	if (so->lm_info != NULL)
+		so->lm_info->base_address = 0;
+}
+
+static void
+kld_clear_solib (void)
+{
+	struct kld_info *info;
+
+	info = get_kld_info();
+
+	memset(info, 0, sizeof(*info));
+}
+
+static void
+kld_solib_create_inferior_hook (int from_tty)
+{
+	struct kld_info *info;
+
+	info = get_kld_info();
+	
+	/*
+	 * Compute offsets of relevant members in struct linker_file
+	 * and the addresses of global variables.  Newer kernels
+	 * include constants we can use without requiring debug
+	 * symbols.  If those aren't present, fall back to using
+	 * home-grown offsetof() equivalents.
+	 */
+	TRY {
+		info->off_address = parse_and_eval_long("kld_off_address");
+		info->off_filename = parse_and_eval_long("kld_off_filename");
+		info->off_pathname = parse_and_eval_long("kld_off_pathname");
+		info->off_next = parse_and_eval_long("kld_off_next");
+	} CATCH(e, RETURN_MASK_ERROR) {
+		TRY {
+			info->off_address = parse_and_eval_address(
+			    "&((struct linker_file *)0)->address");
+			info->off_filename = parse_and_eval_address(
+			    "&((struct linker_file *)0)->filename");
+			info->off_pathname = parse_and_eval_address(
+			    "&((struct linker_file *)0)->pathname");
+			info->off_next = parse_and_eval_address(
+			    "&((struct linker_file *)0)->link.tqe_next");
+		} CATCH(e, RETURN_MASK_ERROR) {
+			return;
+		}
+		END_CATCH
+	}
+	END_CATCH
+
+	TRY {
+		info->module_path_addr = parse_and_eval_address("linker_path");
+		info->linker_files_addr = kgdb_lookup("linker_files");
+		info->kernel_file_addr = kgdb_lookup("linker_kernel_file");
+	} CATCH(e, RETURN_MASK_ERROR) {
+		return;
+	}
+	END_CATCH
+
+	solib_add(NULL, 1, &current_target, auto_solib_add);
+}
+
+static void
+kld_special_symbol_handling (void)
+{
+}
+
+static struct so_list *
+kld_current_sos (void)
+{
+	struct so_list *head, **prev, *newobj;
+	struct kld_info *info;
+	CORE_ADDR kld, kernel;
+	char *path;
+	int error;
+
+	info = get_kld_info();
+	if (info->linker_files_addr == 0 || info->kernel_file_addr == 0 ||
+	    info->off_address == 0 || info->off_filename == 0 ||
+	    info->off_next == 0)
+		return (NULL);
+
+	head = NULL;
+	prev = &head;
+
+	/*
+	 * Walk the list of linker files creating so_list entries for
+	 * each non-kernel file.
+	 */
+	kernel = read_pointer(info->kernel_file_addr);
+	for (kld = read_pointer(info->linker_files_addr); kld != 0;
+	     kld = read_pointer(kld + info->off_next)) {
+		/* Skip the main kernel file. */
+		if (kld == kernel)
+			continue;
+
+		newobj = XCNEW (struct so_list);
+
+		newobj->lm_info = XNEW (struct lm_info);
+		newobj->lm_info->base_address = 0;
+
+		/* Read the base filename and store it in so_original_name. */
+		target_read_string(read_pointer(kld + info->off_filename),
+		    &path, sizeof(newobj->so_original_name), &error);
+		if (error != 0) {
+			warning("kld_current_sos: Can't read filename: %s\n",
+			    safe_strerror(error));
+			free_so(newobj);
+			continue;
+		}
+		strlcpy(newobj->so_original_name, path,
+		    sizeof(newobj->so_original_name));
+		xfree(path);
+
+		/*
+		 * Try to read the pathname (if it exists) and store
+		 * it in so_name.
+		 */
+		if (find_kld_path(newobj->so_original_name, newobj->so_name,
+		    sizeof(newobj->so_name))) {
+			/* we found the kld */;
+		} else if (info->off_pathname != 0) {
+			target_read_string(read_pointer(kld +
+			    info->off_pathname),
+			    &path, sizeof(newobj->so_name), &error);
+			if (error != 0) {
+				warning(
+		    "kld_current_sos: Can't read pathname for \"%s\": %s\n",
+				    newobj->so_original_name,
+				    safe_strerror(error));
+				strlcpy(newobj->so_name, newobj->so_original_name,
+				    sizeof(newobj->so_name));
+			} else {
+				strlcpy(newobj->so_name, path,
+				    sizeof(newobj->so_name));
+				xfree(path);
+			}
+		} else
+			strlcpy(newobj->so_name, newobj->so_original_name,
+			    sizeof(newobj->so_name));
+
+		/* Read this kld's base address. */
+		newobj->lm_info->base_address = read_pointer(kld +
+		    info->off_address);
+		if (newobj->lm_info->base_address == 0) {
+			warning(
+			    "kld_current_sos: Invalid address for kld \"%s\"",
+			    newobj->so_original_name);
+			free_so(newobj);
+			continue;
+		}
+
+		/* Append to the list. */
+		*prev = newobj;
+		prev = &newobj->next;
+	}
+
+	return (head);
+}
+
+static int
+kld_open_symbol_file_object (void *from_ttyp)
+{
+
+	return (0);
+}
+
+static int
+kld_in_dynsym_resolve_code (CORE_ADDR pc)
+{
+
+	return (0);
+}
+
+static int
+kld_find_and_open_solib (char *solib, unsigned o_flags, char **temp_pathname)
+{
+	char path[PATH_MAX];
+	int fd;
+
+	*temp_pathname = NULL;
+	if (!find_kld_path(solib, path, sizeof(path))) {
+		errno = ENOENT;
+		return (-1);
+	}
+	fd = open(path, o_flags, 0);
+	if (fd >= 0)
+		*temp_pathname = xstrdup(path);
+	return (fd);
+}
+
+void _initialize_kld_target(void);
+
+void
+_initialize_kld_target(void)
+{
+	struct cmd_list_element *c;
+
+	kld_so_ops.relocate_section_addresses = kld_relocate_section_addresses;
+	kld_so_ops.free_so = kld_free_so;
+	kld_so_ops.clear_so = kld_clear_so;
+	kld_so_ops.clear_solib = kld_clear_solib;
+	kld_so_ops.solib_create_inferior_hook = kld_solib_create_inferior_hook;
+	kld_so_ops.special_symbol_handling = kld_special_symbol_handling;
+	kld_so_ops.current_sos = kld_current_sos;
+	kld_so_ops.open_symbol_file_object = kld_open_symbol_file_object;
+	kld_so_ops.in_dynsym_resolve_code = kld_in_dynsym_resolve_code;
+	kld_so_ops.bfd_open = solib_bfd_open;
+	kld_so_ops.find_and_open_solib = kld_find_and_open_solib;
+
+	c = add_com("add-kld", class_files, kgdb_add_kld_cmd,
+	   "Usage: add-kld FILE\n\
+Load the symbols from the kernel loadable module FILE.");
+	set_cmd_completer(c, filename_completer);
+
+	kld_pspace_data = register_program_space_data_with_cleanup (NULL,
+	    kld_pspace_data_cleanup);
+}
diff --git a/devel/gdb-good/files/kgdb/fbsd-kthr.c b/devel/gdb-good/files/kgdb/fbsd-kthr.c
new file mode 100644
index 00000000000..5be31d86353
--- /dev/null
+++ b/devel/gdb-good/files/kgdb/fbsd-kthr.c
@@ -0,0 +1,351 @@
+/*
+ * Copyright (c) 2004 Marcel Moolenaar
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: head/devel/gdb/files/kgdb/fbsd-kthr.c 428876 2016-12-18 16:08:14Z tijl $");
+
+#include <sys/param.h>
+#include <sys/proc.h>
+#include <stdbool.h>
+
+#include <defs.h>
+#include "gdbcore.h"
+#include "objfiles.h"
+#include "value.h"
+
+#include "kgdb.h"
+
+static CORE_ADDR dumppcb;
+static LONGEST dumptid;
+
+static CORE_ADDR stopped_cpus;
+static LONGEST mp_maxid;
+
+static struct kthr *first;
+struct kthr *curkthr;
+
+static int proc_off_p_pid, proc_off_p_comm, proc_off_p_list, proc_off_p_threads;
+static int thread_off_td_tid, thread_off_td_oncpu, thread_off_td_pcb;
+static int thread_off_td_name, thread_off_td_plist;
+static int thread_oncpu_size;
+
+CORE_ADDR
+kgdb_lookup(const char *sym)
+{
+	struct bound_minimal_symbol msym;
+
+	msym = lookup_minimal_symbol(sym, NULL, NULL);
+	if (msym.minsym == NULL)
+		return (0);
+	return (BMSYMBOL_VALUE_ADDRESS(msym));
+}
+
+/*
+ * Perform the equivalent of CPU_ISSET() to see if 'cpu' is set in the
+ * kernel's stopped_cpus set.  The set contains an array of longs.
+ * This function determines the specific long to read and tests the
+ * necessary bit in the long.
+ */
+static bool
+cpu_stopped(int cpu)
+{
+	struct gdbarch *gdbarch = target_gdbarch ();
+	CORE_ADDR addr;
+	ULONGEST mask;
+	int bit, long_bytes, word;
+
+	if (cpu < 0 || cpu > mp_maxid || stopped_cpus == 0)
+		return (false);
+	bit = cpu % gdbarch_long_bit (gdbarch);
+	word = cpu / gdbarch_long_bit (gdbarch);
+	long_bytes = gdbarch_long_bit (gdbarch) / 8;
+	addr = stopped_cpus + word * long_bytes;
+	mask = read_memory_unsigned_integer (addr, long_bytes,
+	    gdbarch_byte_order (gdbarch));
+	return (mask & ((ULONGEST)1 << bit)) != 0;
+}
+
+struct kthr *
+kgdb_thr_first(void)
+{
+	return (first);
+}
+
+static void
+kgdb_thr_add_procs(CORE_ADDR paddr, CORE_ADDR (*cpu_pcb_addr) (u_int))
+{
+	struct gdbarch *gdbarch = target_gdbarch ();
+	struct type *ptr_type = builtin_type (gdbarch)->builtin_data_ptr;
+	enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+	struct kthr *kt;
+	CORE_ADDR pcb, pnext, tdaddr, tdnext;
+	ULONGEST oncpu;
+	LONGEST pid, tid;
+
+	while (paddr != 0) {
+		TRY {
+			tdaddr = read_memory_typed_address (paddr +
+			    proc_off_p_threads, ptr_type);
+			pid = read_memory_integer (paddr + proc_off_p_pid, 4,
+			    byte_order);
+			pnext = read_memory_typed_address (paddr +
+			    proc_off_p_list, ptr_type);
+		} CATCH(e, RETURN_MASK_ERROR) {
+			break;
+		} END_CATCH
+		while (tdaddr != 0) {
+			TRY {
+				tid = read_memory_integer (tdaddr +
+				    thread_off_td_tid, 4, byte_order);
+				oncpu = read_memory_unsigned_integer (tdaddr +
+				    thread_off_td_oncpu, thread_oncpu_size,
+				    byte_order);
+				pcb = read_memory_typed_address (tdaddr +
+				    thread_off_td_pcb, ptr_type);
+				tdnext = read_memory_typed_address (tdaddr +
+				    thread_off_td_plist, ptr_type);
+			} CATCH(e, RETURN_MASK_ERROR) {
+				break;
+			} END_CATCH
+			kt = XNEW (struct kthr);
+			kt->next = first;
+			kt->kaddr = tdaddr;
+			if (tid == dumptid)
+				kt->pcb = dumppcb;
+			else if (cpu_stopped(oncpu))
+				kt->pcb = cpu_pcb_addr(oncpu);
+			else
+				kt->pcb = pcb;
+			kt->tid = tid;
+			kt->pid = pid;
+			kt->paddr = paddr;
+			kt->cpu = oncpu;
+			first = kt;
+			tdaddr = tdnext;
+		}
+		paddr = pnext;
+	}
+}
+
+struct kthr *
+kgdb_thr_init(CORE_ADDR (*cpu_pcb_addr) (u_int))
+{
+	struct gdbarch *gdbarch = target_gdbarch ();
+	struct type *ptr_type = builtin_type (gdbarch)->builtin_data_ptr;
+	enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+	struct kthr *kt;
+	CORE_ADDR addr, paddr;
+	
+	while (first != NULL) {
+		kt = first;
+		first = kt->next;
+		free(kt);
+	}
+
+	addr = kgdb_lookup("allproc");
+	if (addr == 0)
+		return (NULL);
+	TRY {
+		paddr = read_memory_typed_address (addr, ptr_type);
+	} CATCH(e, RETURN_MASK_ERROR) {
+		return (NULL);
+	} END_CATCH
+
+	dumppcb = kgdb_lookup("dumppcb");
+	if (dumppcb == 0)
+		return (NULL);
+
+#if 1
+	TRY {
+		dumptid = parse_and_eval_long("dumptid");
+	} CATCH(e, RETURN_MASK_ERROR) {
+		dumptid = -1;
+	} END_CATCH
+#else
+	addr = kgdb_lookup("dumptid");
+	if (addr != 0) {
+		TRY {
+			dumptid = read_memory_integer (addr, 4, byte_order);
+		} CATCH(e, RETURN_MASK_ERROR) {
+			dumptid = -1;
+		} END_CATCH
+	} else
+		dumptid = -1;
+#endif
+
+	TRY {
+		mp_maxid = parse_and_eval_long("mp_maxid");
+	} CATCH(e, RETURN_MASK_ERROR) {
+		mp_maxid = 0;
+	} END_CATCH
+	stopped_cpus = kgdb_lookup("stopped_cpus");
+
+	/*
+	 * Newer kernels export a set of global variables with the offsets
+	 * of certain members in struct proc and struct thread.  For older
+	 * kernels, try to extract these offsets using debug symbols.  If
+	 * that fails, use native values.
+	 */
+	TRY {
+		proc_off_p_pid = parse_and_eval_long("proc_off_p_pid");
+		proc_off_p_comm = parse_and_eval_long("proc_off_p_comm");
+		proc_off_p_list = parse_and_eval_long("proc_off_p_list");
+		proc_off_p_threads = parse_and_eval_long("proc_off_p_threads");
+		thread_off_td_tid = parse_and_eval_long("thread_off_td_tid");
+		thread_off_td_name = parse_and_eval_long("thread_off_td_name");
+		thread_off_td_oncpu = parse_and_eval_long("thread_off_td_oncpu");
+		thread_off_td_pcb = parse_and_eval_long("thread_off_td_pcb");
+		thread_off_td_plist = parse_and_eval_long("thread_off_td_plist");
+		thread_oncpu_size = 4;
+	} CATCH(e, RETURN_MASK_ERROR) {
+		TRY {
+			proc_off_p_pid = parse_and_eval_address(
+			    "&((struct proc *)0)->p_pid");
+			proc_off_p_comm = parse_and_eval_address(
+			    "&((struct proc *)0)->p_comm");
+			proc_off_p_list = parse_and_eval_address(
+			    "&((struct proc *)0)->p_list");
+			proc_off_p_threads = parse_and_eval_address(
+			    "&((struct proc *)0)->p_threads");
+			thread_off_td_tid = parse_and_eval_address(
+			    "&((struct thread *)0)->td_tid");
+			thread_off_td_name = parse_and_eval_address(
+			    "&((struct thread *)0)->td_name");
+			thread_off_td_oncpu = parse_and_eval_address(
+			    "&((struct thread *)0)->td_oncpu");
+			thread_off_td_pcb = parse_and_eval_address(
+			    "&((struct thread *)0)->td_pcb");
+			thread_off_td_plist = parse_and_eval_address(
+			    "&((struct thread *)0)->td_plist");
+			thread_oncpu_size = parse_and_eval_long(
+			    "sizeof(((struct thread *)0)->td_oncpu)");
+		} CATCH(e, RETURN_MASK_ERROR) {
+			proc_off_p_pid = offsetof(struct proc, p_pid);
+			proc_off_p_comm = offsetof(struct proc, p_comm);
+			proc_off_p_list = offsetof(struct proc, p_list);
+			proc_off_p_threads = offsetof(struct proc, p_threads);
+			thread_off_td_tid = offsetof(struct thread, td_tid);
+			thread_off_td_name = offsetof(struct thread, td_name);
+			thread_off_td_oncpu = offsetof(struct thread, td_oncpu);
+			thread_off_td_pcb = offsetof(struct thread, td_pcb);
+			thread_off_td_plist = offsetof(struct thread, td_plist);
+			thread_oncpu_size =
+			    sizeof(((struct thread *)0)->td_oncpu);
+		} END_CATCH
+	} END_CATCH
+
+	kgdb_thr_add_procs(paddr, cpu_pcb_addr);
+	addr = kgdb_lookup("zombproc");
+	if (addr != 0) {
+		TRY {
+			paddr = read_memory_typed_address (addr, ptr_type);
+			kgdb_thr_add_procs(paddr, cpu_pcb_addr);
+		} CATCH(e, RETURN_MASK_ERROR) {
+		} END_CATCH
+	}
+	curkthr = kgdb_thr_lookup_tid(dumptid);
+	if (curkthr == NULL)
+		curkthr = first;
+	return (first);
+}
+
+struct kthr *
+kgdb_thr_lookup_tid(int tid)
+{
+	struct kthr *kt;
+
+	kt = first;
+	while (kt != NULL && kt->tid != tid)
+		kt = kt->next;
+	return (kt);
+}
+
+struct kthr *
+kgdb_thr_lookup_taddr(uintptr_t taddr)
+{
+	struct kthr *kt;
+
+	kt = first;
+	while (kt != NULL && kt->kaddr != taddr)
+		kt = kt->next;
+	return (kt);
+}
+
+struct kthr *
+kgdb_thr_lookup_pid(int pid)
+{
+	struct kthr *kt;
+
+	kt = first;
+	while (kt != NULL && kt->pid != pid)
+		kt = kt->next;
+	return (kt);
+}
+
+struct kthr *
+kgdb_thr_lookup_paddr(uintptr_t paddr)
+{
+	struct kthr *kt;
+
+	kt = first;
+	while (kt != NULL && kt->paddr != paddr)
+		kt = kt->next;
+	return (kt);
+}
+
+struct kthr *
+kgdb_thr_next(struct kthr *kt)
+{
+	return (kt->next);
+}
+
+char *
+kgdb_thr_extra_thread_info(int tid)
+{
+	char comm[MAXCOMLEN + 1];
+	char td_name[MAXCOMLEN + 1];
+	struct kthr *kt;
+	static char buf[64];
+
+	kt = kgdb_thr_lookup_tid(tid);
+	if (kt == NULL)
+		return (NULL);	
+	snprintf(buf, sizeof(buf), "PID=%d", kt->pid);
+	TRY {
+		read_memory_string (kt->paddr + proc_off_p_comm, comm,
+		    sizeof(comm));
+		strlcat(buf, ": ", sizeof(buf));
+		strlcat(buf, comm, sizeof(buf));
+		read_memory_string (kt->kaddr + thread_off_td_name, td_name,
+		    sizeof(td_name));
+		if (strcmp(comm, td_name) != 0) {
+			strlcat(buf, "/", sizeof(buf));
+			strlcat(buf, td_name, sizeof(buf));
+		}
+	} CATCH(e, RETURN_MASK_ERROR) {
+	} END_CATCH
+	return (buf);
+}
diff --git a/devel/gdb-good/files/kgdb/fbsd-kvm.c b/devel/gdb-good/files/kgdb/fbsd-kvm.c
new file mode 100644
index 00000000000..8b4c547b157
--- /dev/null
+++ b/devel/gdb-good/files/kgdb/fbsd-kvm.c
@@ -0,0 +1,596 @@
+/*
+ * Copyright (c) 2004 Marcel Moolenaar
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: head/devel/gdb/files/kgdb/fbsd-kvm.c 428876 2016-12-18 16:08:14Z tijl $");
+
+#include <sys/param.h>
+#include <sys/proc.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <err.h>
+#include <fcntl.h>
+#include <kvm.h>
+
+#include <defs.h>
+#include <readline/readline.h>
+#include <readline/tilde.h>
+#include <command.h>
+#include "elf-bfd.h"
+#include <exec.h>
+#include "filenames.h"
+#include <frame-unwind.h>
+#include <gdb.h>
+#include <gdbcore.h>
+#include <gdbthread.h>
+#include "gdb_obstack.h"
+#include <inferior.h>
+#include <language.h>
+#include "objfiles.h"
+#include <regcache.h>
+#include <solib.h>
+#include <target.h>
+#include <ui-out.h>
+
+#include "kgdb.h"
+
+static CORE_ADDR stoppcbs;
+static LONGEST pcb_size;
+
+static void	kgdb_core_cleanup(void *);
+
+static char *vmcore;
+struct target_ops kgdb_trgt_ops;
+
+/* Per-architecture data key.  */
+static struct gdbarch_data *fbsd_vmcore_data;
+
+struct fbsd_vmcore_ops
+{
+  /* Supply registers for a pcb to a register cache.  */
+  void (*supply_pcb)(struct regcache *, CORE_ADDR);
+
+  /* Return address of pcb for thread running on a CPU. */
+  CORE_ADDR (*cpu_pcb_addr)(u_int);
+};
+
+static void *
+fbsd_vmcore_init (struct obstack *obstack)
+{
+  struct fbsd_vmcore_ops *ops;
+
+  ops = OBSTACK_ZALLOC (obstack, struct fbsd_vmcore_ops);
+  return ops;
+}
+
+/* Set the function that supplies registers from a pcb
+   for architecture GDBARCH to SUPPLY_PCB.  */
+
+void
+fbsd_vmcore_set_supply_pcb (struct gdbarch *gdbarch,
+			    void (*supply_pcb) (struct regcache *,
+						CORE_ADDR))
+{
+  struct fbsd_vmcore_ops *ops = (struct fbsd_vmcore_ops *)
+    gdbarch_data (gdbarch, fbsd_vmcore_data);
+  ops->supply_pcb = supply_pcb;
+}
+
+/* Set the function that returns the address of the pcb for a thread
+   running on a CPU for
+   architecture GDBARCH to CPU_PCB_ADDR.  */
+
+void
+fbsd_vmcore_set_cpu_pcb_addr (struct gdbarch *gdbarch,
+			      CORE_ADDR (*cpu_pcb_addr) (u_int))
+{
+  struct fbsd_vmcore_ops *ops = (struct fbsd_vmcore_ops *)
+    gdbarch_data (gdbarch, fbsd_vmcore_data);
+  ops->cpu_pcb_addr = cpu_pcb_addr;
+}
+
+static CORE_ADDR kernstart;
+static kvm_t *kvm;
+static char kvm_err[_POSIX2_LINE_MAX];
+int kgdb_quiet;
+
+static ptid_t
+fbsd_vmcore_ptid(int tid)
+{
+	if (kvm == NULL)
+		/*
+		 * The remote target stores the 'tid' in the lwp
+		 * field.
+		 */
+		return ptid_build(ptid_get_pid(inferior_ptid), tid, 0);
+
+	/*
+	 * This follows the model described in bsd-kvm.c except that
+	 * in kernel tids are used as the tid of the ptid instead of a
+	 * process ID.
+	 */
+	return ptid_build(1, 1, tid);
+}
+
+#define	MSGBUF_SEQ_TO_POS(size, seq)	((seq) % (size))
+
+static void
+kgdb_dmesg(void)
+{
+	CORE_ADDR bufp;
+	int size, rseq, wseq;
+	gdb_byte c;
+
+	/*
+	 * Display the unread portion of the message buffer. This gives the
+	 * user a some initial data to work from.
+	 */
+	if (kgdb_quiet)
+		return;
+	TRY {
+		bufp = parse_and_eval_address("msgbufp->msg_ptr");
+		size = parse_and_eval_long("msgbufp->msg_size");
+		rseq = parse_and_eval_long("msgbufp->msg_rseq");
+		wseq = parse_and_eval_long("msgbufp->msg_wseq");
+	} CATCH(e, RETURN_MASK_ERROR) {
+		return;
+	} END_CATCH
+	rseq = MSGBUF_SEQ_TO_POS(size, rseq);
+	wseq = MSGBUF_SEQ_TO_POS(size, wseq);
+	if (rseq == wseq)
+		return;
+
+	printf("\nUnread portion of the kernel message buffer:\n");
+	while (rseq < wseq) {
+		read_memory(bufp + rseq, &c, 1);
+		putchar(c);
+		rseq++;
+		if (rseq == size)
+			rseq = 0;
+	}
+	if (c != '\n')
+		putchar('\n');
+	putchar('\n');
+}
+
+#define	KERNEL_INTERP		"/red/herring"
+
+enum gdb_osabi
+fbsd_kernel_osabi_sniffer(bfd *abfd)
+{
+	asection *s;
+	bfd_byte buf[sizeof(KERNEL_INTERP)];
+	bfd_byte *bufp;
+
+	/* FreeBSD ELF kernels have a FreeBSD/ELF OS ABI. */
+	if (elf_elfheader(abfd)->e_ident[EI_OSABI] != ELFOSABI_FREEBSD)
+		return (GDB_OSABI_UNKNOWN);
+
+	/* FreeBSD ELF kernels have an interpreter path of "/red/herring". */
+	bufp = buf;
+	s = bfd_get_section_by_name(abfd, ".interp");
+	if (s != NULL && bfd_section_size(abfd, s) == sizeof(buf) &&
+	    bfd_get_full_section_contents(abfd, s, &bufp) &&
+	    memcmp(buf, KERNEL_INTERP, sizeof(buf)) == 0)
+		return (GDB_OSABI_FREEBSD_ELF_KERNEL);
+
+	return (GDB_OSABI_UNKNOWN);
+}
+
+#ifdef HAVE_KVM_OPEN2
+static int
+kgdb_resolve_symbol(const char *name, kvaddr_t *kva)
+{
+	struct bound_minimal_symbol ms;
+
+	ms = lookup_minimal_symbol (name, NULL, NULL);
+	if (ms.minsym == NULL)
+		return (1);
+	*kva = BMSYMBOL_VALUE_ADDRESS (ms);
+	return (0);
+}
+#endif
+
+static void
+kgdb_trgt_open(const char *arg, int from_tty)
+{
+	struct fbsd_vmcore_ops *ops = (struct fbsd_vmcore_ops *)
+	    gdbarch_data (target_gdbarch(), fbsd_vmcore_data);
+	struct inferior *inf;
+	struct cleanup *old_chain;
+	struct thread_info *ti;
+	struct kthr *kt;
+	kvm_t *nkvm;
+	char *temp, *kernel, *filename;
+	int ontop;
+
+	if (ops == NULL || ops->supply_pcb == NULL || ops->cpu_pcb_addr == NULL)
+		error ("ABI doesn't support a vmcore target");
+
+	target_preopen (from_tty);
+	kernel = get_exec_file (1);
+	if (kernel == NULL)
+		error ("Can't open a vmcore without a kernel");
+
+	if (arg != NULL) {
+		filename = tilde_expand (arg);
+		if (!IS_ABSOLUTE_PATH (filename)) {
+			temp = concat (current_directory, "/", filename, NULL);
+			xfree(filename);
+			filename = temp;
+		}
+	} else
+		filename = NULL;
+
+	old_chain = make_cleanup (xfree, filename);
+
+#ifdef HAVE_KVM_OPEN2
+	nkvm = kvm_open2(kernel, filename,
+	    write_files ? O_RDWR : O_RDONLY, kvm_err, kgdb_resolve_symbol);
+#else
+	nkvm = kvm_openfiles(kernel, filename, NULL,
+	    write_files ? O_RDWR : O_RDONLY, kvm_err);
+#endif
+	if (nkvm == NULL)
+		error ("Failed to open vmcore: %s", kvm_err);
+
+	/* Don't free the filename now and close any previous vmcore. */
+	discard_cleanups(old_chain);
+	unpush_target(&kgdb_trgt_ops);
+
+	/*
+	 * Determine the first address in KVA.  Newer kernels export
+	 * VM_MAXUSER_ADDRESS and the first kernel address can be
+	 * determined by adding one.  Older kernels do not provide a
+	 * symbol that is valid on all platforms, but kernbase is close
+	 * for most platforms.
+	 */
+	TRY {
+		kernstart = parse_and_eval_address("vm_maxuser_address") + 1;
+	} CATCH(e, RETURN_MASK_ERROR) {
+		kernstart = kgdb_lookup("kernbase");
+	} END_CATCH
+
+	/*
+	 * Lookup symbols needed for stoppcbs[] handling, but don't
+	 * fail if they aren't present.
+	 */
+	stoppcbs = kgdb_lookup("stoppcbs");
+	TRY {
+		pcb_size = parse_and_eval_long("pcb_size");
+	} CATCH(e, RETURN_MASK_ERROR) {
+		TRY {
+			pcb_size = parse_and_eval_long("sizeof(struct pcb)");
+		} CATCH(e, RETURN_MASK_ERROR) {
+#ifdef HAVE_KVM_OPEN2
+			if (kvm_native(nkvm))
+				pcb_size = sizeof(struct pcb);
+			else
+				pcb_size = 0;
+#else
+			pcb_size = sizeof(struct pcb);
+#endif
+		} END_CATCH
+	} END_CATCH
+
+	kvm = nkvm;
+	vmcore = filename;
+	old_chain = make_cleanup(kgdb_core_cleanup, NULL);
+
+	push_target (&kgdb_trgt_ops);
+	discard_cleanups (old_chain);
+
+	kgdb_dmesg();
+
+	inf = current_inferior();
+	if (inf->pid == 0) {
+		inferior_appeared(inf, 1);
+		inf->fake_pid_p = 1;
+	}
+	solib_create_inferior_hook(0);
+	init_thread_list();
+	kt = kgdb_thr_init(ops->cpu_pcb_addr);
+	while (kt != NULL) {
+		ti = add_thread_silent(fbsd_vmcore_ptid(kt->tid));
+		kt = kgdb_thr_next(kt);
+	}
+	if (curkthr != 0)
+		inferior_ptid = fbsd_vmcore_ptid(curkthr->tid);
+
+	target_fetch_registers (get_current_regcache (), -1);
+
+	reinit_frame_cache ();
+	print_stack_frame (get_selected_frame (NULL), 0, SRC_AND_LOC, 1);
+}
+
+static void
+kgdb_trgt_close(struct target_ops *self)
+{
+
+	if (kvm != NULL) {
+		clear_solib();
+		if (kvm_close(kvm) != 0)
+			warning("cannot close \"%s\": %s", vmcore,
+			    kvm_geterr(kvm));
+		kvm = NULL;
+		xfree(vmcore);
+		vmcore = NULL;
+	}
+
+	inferior_ptid = null_ptid;
+}
+
+static void
+kgdb_core_cleanup(void *arg)
+{
+
+	kgdb_trgt_close(0);
+}
+
+static void
+kgdb_trgt_detach(struct target_ops *ops, const char *args, int from_tty)
+{
+
+	if (args)
+		error ("Too many arguments");
+	unpush_target(&kgdb_trgt_ops);
+	reinit_frame_cache();
+	if (from_tty)
+		printf_filtered("No vmcore file now.\n");
+}
+
+static char *
+kgdb_trgt_extra_thread_info(struct target_ops *ops, struct thread_info *ti)
+{
+
+	return (kgdb_thr_extra_thread_info(ptid_get_tid(ti->ptid)));
+}
+
+static void
+kgdb_trgt_files_info(struct target_ops *target)
+{
+
+	printf_filtered ("\t`%s', ", vmcore);
+	wrap_here ("        ");
+	printf_filtered ("file type %s.\n", "FreeBSD kernel vmcore");
+}
+
+static void
+kgdb_trgt_update_thread_list(struct target_ops *ops)
+{
+	/*
+	 * XXX: We should probably rescan the thread list here and update
+	 * it if there are any changes.  One nit though is that we'd have
+	 * to detect exited threads.
+	 */
+	gdb_assert(kvm != NULL);
+#if 0
+	prune_threads();
+#endif
+#if 0
+	struct target_ops *tb;
+	
+	if (kvm != NULL)
+		return;
+
+	tb = find_target_beneath(ops);
+	if (tb->to_update_thread_list != NULL)
+		tb->to_update_thread_list(tb);
+#endif
+}
+
+static char *
+kgdb_trgt_pid_to_str(struct target_ops *ops, ptid_t ptid)
+{
+	static char buf[33];
+
+	snprintf(buf, sizeof(buf), "Thread %ld", ptid_get_tid(ptid));
+	return (buf);
+}
+
+static int
+kgdb_trgt_thread_alive(struct target_ops *ops, ptid_t ptid)
+{
+	return (kgdb_thr_lookup_tid(ptid_get_tid(ptid)) != NULL);
+}
+
+static void
+kgdb_trgt_fetch_registers(struct target_ops *tops,
+			  struct regcache *regcache, int regnum)
+{
+	struct fbsd_vmcore_ops *ops = (struct fbsd_vmcore_ops *)
+	    gdbarch_data (target_gdbarch(), fbsd_vmcore_data);
+	struct kthr *kt;
+
+	if (ops->supply_pcb == NULL)
+		return;
+	kt = kgdb_thr_lookup_tid(ptid_get_tid(inferior_ptid));
+	if (kt == NULL)
+		return;
+	ops->supply_pcb(regcache, kt->pcb);
+}
+
+static enum target_xfer_status
+kgdb_trgt_xfer_partial(struct target_ops *ops, enum target_object object,
+		       const char *annex, gdb_byte *readbuf,
+		       const gdb_byte *writebuf,
+		       ULONGEST offset, ULONGEST len, ULONGEST *xfered_len)
+{
+	ssize_t nbytes;
+
+	gdb_assert(kvm != NULL);
+	switch (object) {
+	case TARGET_OBJECT_MEMORY:
+		nbytes = len;
+		if (readbuf != NULL)
+#ifdef HAVE_KVM_OPEN2
+			nbytes = kvm_read2(kvm, offset, readbuf, len);
+#else
+			nbytes = kvm_read(kvm, offset, readbuf, len);
+#endif
+		if (writebuf != NULL && len > 0)
+			nbytes = kvm_write(kvm, offset, writebuf, len);
+		if (nbytes < 0)
+			return TARGET_XFER_E_IO;
+		if (nbytes == 0)
+			return TARGET_XFER_EOF;
+		*xfered_len = nbytes;
+		return TARGET_XFER_OK;
+	default:
+		return TARGET_XFER_E_IO;
+	}
+}
+
+static int
+kgdb_trgt_insert_breakpoint(struct target_ops *ops, struct gdbarch *gdbarch,
+    struct bp_target_info *bp_tgt)
+{
+
+	return 0;
+}
+
+static int
+kgdb_trgt_remove_breakpoint(struct target_ops *ops, struct gdbarch *gdbarch,
+    struct bp_target_info *bp_tgt, enum remove_bp_reason reason)
+{
+
+	return 0;
+}
+
+static void
+kgdb_switch_to_thread(int tid)
+{
+	char buf[16];
+	int thread_id;
+
+	thread_id = ptid_to_global_thread_id(fbsd_vmcore_ptid(tid));
+	if (thread_id == 0)
+		error ("invalid tid");
+	snprintf(buf, sizeof(buf), "%d", thread_id);
+	gdb_thread_select(current_uiout, buf, NULL);
+}
+
+static void
+kgdb_set_proc_cmd (char *arg, int from_tty)
+{
+	CORE_ADDR addr;
+	struct kthr *thr;
+
+	if (!arg)
+		error_no_arg ("proc address for the new context");
+
+	if (kvm == NULL)
+		error ("only supported for core file target");
+
+	addr = parse_and_eval_address (arg);
+
+	if (addr < kernstart) {
+		thr = kgdb_thr_lookup_pid((int)addr);
+		if (thr == NULL)
+			error ("invalid pid");
+	} else {
+		thr = kgdb_thr_lookup_paddr(addr);
+		if (thr == NULL)
+			error("invalid proc address");
+	}
+	kgdb_switch_to_thread(thr->tid);
+}
+
+static void
+kgdb_set_tid_cmd (char *arg, int from_tty)
+{
+	CORE_ADDR addr;
+	struct kthr *thr;
+
+	if (!arg)
+		error_no_arg ("TID or thread address for the new context");
+
+	addr = (CORE_ADDR) parse_and_eval_address (arg);
+
+	if (kvm != NULL && addr >= kernstart) {
+		thr = kgdb_thr_lookup_taddr(addr);
+		if (thr == NULL)
+			error("invalid thread address");
+		addr = thr->tid;
+	}
+	kgdb_switch_to_thread(addr);
+}
+
+static int
+kgdb_trgt_return_one(struct target_ops *ops)
+{
+
+	return 1;
+}
+
+void _initialize_kgdb_target(void);
+
+void
+_initialize_kgdb_target(void)
+{
+
+	kgdb_trgt_ops.to_magic = OPS_MAGIC;
+	kgdb_trgt_ops.to_shortname = "vmcore";
+	kgdb_trgt_ops.to_longname = "kernel core dump file";
+	kgdb_trgt_ops.to_doc = 
+    "Use a vmcore file as a target.  Specify the filename of the vmcore file.";
+	kgdb_trgt_ops.to_stratum = process_stratum;
+	kgdb_trgt_ops.to_has_memory = kgdb_trgt_return_one;
+	kgdb_trgt_ops.to_has_registers = kgdb_trgt_return_one;
+	kgdb_trgt_ops.to_has_stack = kgdb_trgt_return_one;
+
+	kgdb_trgt_ops.to_open = kgdb_trgt_open;
+	kgdb_trgt_ops.to_close = kgdb_trgt_close;
+	kgdb_trgt_ops.to_detach = kgdb_trgt_detach;
+	kgdb_trgt_ops.to_extra_thread_info = kgdb_trgt_extra_thread_info;
+	kgdb_trgt_ops.to_fetch_registers = kgdb_trgt_fetch_registers;
+	kgdb_trgt_ops.to_files_info = kgdb_trgt_files_info;
+	kgdb_trgt_ops.to_update_thread_list = kgdb_trgt_update_thread_list;
+	kgdb_trgt_ops.to_pid_to_str = kgdb_trgt_pid_to_str;
+	kgdb_trgt_ops.to_thread_alive = kgdb_trgt_thread_alive;
+	kgdb_trgt_ops.to_xfer_partial = kgdb_trgt_xfer_partial;
+	kgdb_trgt_ops.to_insert_breakpoint = kgdb_trgt_insert_breakpoint;
+	kgdb_trgt_ops.to_remove_breakpoint = kgdb_trgt_remove_breakpoint;
+
+	add_target(&kgdb_trgt_ops);
+
+	fbsd_vmcore_data = gdbarch_data_register_pre_init(fbsd_vmcore_init);
+
+	add_com ("proc", class_obscure, kgdb_set_proc_cmd,
+	   "Set current process context");
+	add_com ("tid", class_obscure, kgdb_set_tid_cmd,
+	   "Set current thread context");
+}
+
+CORE_ADDR
+kgdb_trgt_stop_pcb(u_int cpuid)
+{
+
+	if (stoppcbs == 0 || pcb_size == 0)
+		return 0;
+
+	return (stoppcbs + pcb_size * cpuid);
+}
diff --git a/devel/gdb-good/files/kgdb/i386fbsd-kern.c b/devel/gdb-good/files/kgdb/i386fbsd-kern.c
new file mode 100644
index 00000000000..c3323bde985
--- /dev/null
+++ b/devel/gdb-good/files/kgdb/i386fbsd-kern.c
@@ -0,0 +1,577 @@
+/*
+ * Copyright (c) 2004 Marcel Moolenaar
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: head/devel/gdb/files/kgdb/i386fbsd-kern.c 428876 2016-12-18 16:08:14Z tijl $");
+
+#include <sys/param.h>
+#include <sys/proc.h>
+#ifdef __i386__
+#include <machine/pcb.h>
+#include <machine/frame.h>
+#include <machine/segments.h>
+#include <machine/tss.h>
+#endif
+#include <string.h>
+
+#include <defs.h>
+#include <frame-unwind.h>
+#include "gdbcore.h"
+#include <inferior.h>
+#include "osabi.h"
+#include <regcache.h>
+#include "progspace.h"
+#include "solib.h"
+#include "trad-frame.h"
+#include <i386-tdep.h>
+
+#include "kgdb.h"
+
+struct i386fbsd_info {
+	int ofs_fix;
+};
+
+/* Per-program-space data key.  */
+static const struct program_space_data *i386fbsd_pspace_data;
+
+static void
+i386fbsd_pspace_data_cleanup (struct program_space *pspace, void *arg)
+{
+  struct i386fbsd_info *info = (struct i386fbsd_info *)arg;
+
+  xfree (info);
+}
+
+/* Get the current i386fbsd data.  If none is found yet, add it now.  This
+   function always returns a valid object.  */
+
+static struct i386fbsd_info *
+get_i386fbsd_info (void)
+{
+  struct i386fbsd_info *info;
+
+  info = (struct i386fbsd_info *)
+    program_space_data (current_program_space, i386fbsd_pspace_data);
+  if (info != NULL)
+    return info;
+
+  info = XCNEW (struct i386fbsd_info);
+  set_program_space_data (current_program_space, i386fbsd_pspace_data, info);
+
+  /*
+   * In revision 1.117 of i386/i386/exception.S trap handlers
+   * were changed to pass trapframes by reference rather than
+   * by value.  Detect this by seeing if the first instruction
+   * at the 'calltrap' label is a "push %esp" which has the
+   * opcode 0x54.
+   */
+  if (parse_and_eval_long("((char *)calltrap)[0]") == 0x54)
+    info->ofs_fix = 4;
+  else
+    info->ofs_fix = 0;
+  return info;
+}
+
+/*
+ * Even though the pcb contains fields for the segment selectors, only
+ * %gs is updated on each context switch.  The other selectors are
+ * saved in stoppcbs[], but we just hardcode their known values rather
+ * than handling that special case.
+ */
+static const int i386fbsd_pcb_offset[] = {
+  -1,				/* %eax */
+  -1,				/* %ecx */
+  -1,				/* %edx */
+  4 * 4,			/* %ebx */
+  3 * 4,			/* %esp */
+  2 * 4,			/* %ebp */
+  1 * 4,			/* %esi */
+  0 * 4,			/* %edi */
+  5 * 4,			/* %eip */
+  -1,				/* %eflags */
+  -1,				/* %cs */
+  -1,				/* %ss */
+  -1,				/* %ds */
+  -1,				/* %es */
+  -1,				/* %fs */
+  -1,				/* %gs */
+};
+
+#define	CODE_SEL	(4 << 3)
+#define	DATA_SEL	(5 << 3)
+#define	PRIV_SEL	(1 << 3)
+
+static void
+i386fbsd_supply_pcb(struct regcache *regcache, CORE_ADDR pcb_addr)
+{
+  gdb_byte buf[4];
+  int i;
+
+  for (i = 0; i < ARRAY_SIZE (i386fbsd_pcb_offset); i++)
+    if (i386fbsd_pcb_offset[i] != -1) {
+      if (target_read_memory(pcb_addr + i386fbsd_pcb_offset[i], buf, sizeof buf)
+	  != 0)
+	continue;
+      regcache_raw_supply(regcache, i, buf);
+    }
+  regcache_raw_supply_unsigned(regcache, I386_CS_REGNUM, CODE_SEL);
+  regcache_raw_supply_unsigned(regcache, I386_DS_REGNUM, DATA_SEL);
+  regcache_raw_supply_unsigned(regcache, I386_ES_REGNUM, DATA_SEL);
+  regcache_raw_supply_unsigned(regcache, I386_FS_REGNUM, PRIV_SEL);
+  regcache_raw_supply_unsigned(regcache, I386_GS_REGNUM, DATA_SEL);
+  regcache_raw_supply_unsigned(regcache, I386_SS_REGNUM, DATA_SEL);
+}
+
+#ifdef __i386__
+/* TODO: Make this cross-debugger friendly. */
+static const int i386fbsd_tss_offset[] = {
+  10 * 4,			/* %eax */
+  11 * 4,			/* %ecx */
+  12 * 4,			/* %edx */
+  13 * 4,			/* %ebx */
+  14 * 4,			/* %esp */
+  15 * 4,			/* %ebp */
+  16 * 4,			/* %esi */
+  17 * 4,			/* %edi */
+  8 * 4,			/* %eip */
+  9 * 4,			/* %eflags */
+  19 * 4,			/* %cs */
+  20 * 4,			/* %ss */
+  21 * 4,			/* %ds */
+  18 * 4,			/* %es */
+  22 * 4,			/* %fs */
+  23 * 4,			/* %gs */
+};
+
+/*
+ * If the current thread is executing on a CPU, fetch the common_tss
+ * for that CPU.
+ *
+ * This is painful because 'struct pcpu' is variant sized, so we can't
+ * use it.  Instead, we lookup the GDT selector for this CPU and
+ * extract the base of the TSS from there.
+ */
+static CORE_ADDR
+i386fbsd_fetch_tss(void)
+{
+	struct kthr *kt;
+	struct segment_descriptor sd;
+	CORE_ADDR addr, cpu0prvpage, tss;
+
+	kt = kgdb_thr_lookup_tid(ptid_get_tid(inferior_ptid));
+	if (kt == NULL || kt->cpu == NOCPU || kt->cpu < 0)
+		return (0);
+
+	addr = kgdb_lookup("gdt");
+	if (addr == 0)
+		return (0);
+	addr += (kt->cpu * NGDT + GPROC0_SEL) * sizeof(sd);
+	if (target_read_memory(addr, (gdb_byte *)&sd, sizeof(sd)) != 0)
+		return (0);
+	if (sd.sd_type != SDT_SYS386BSY) {
+		warning ("descriptor is not a busy TSS");
+		return (0);
+	}
+	tss = sd.sd_hibase << 24 | sd.sd_lobase;
+
+	/*
+	 * In SMP kernels, the TSS is stored as part of the per-CPU
+	 * data.  On older kernels, the CPU0's private page
+	 * is stored at an address that isn't mapped in minidumps.
+	 * However, the data is mapped at the alternate cpu0prvpage
+	 * address.  Thus, if the TSS is at the invalid address,
+	 * change it to be relative to cpu0prvpage instead.
+	 */ 
+	if (trunc_page(tss) == 0xffc00000) {
+		TRY {
+			cpu0prvpage = parse_and_eval_address("cpu0prvpage");
+		} CATCH(e, RETURN_MASK_ERROR) {
+			return (0);
+		} END_CATCH
+		tss = cpu0prvpage + (tss & PAGE_MASK);
+	}
+	return (tss);
+}
+
+static struct trad_frame_cache *
+i386fbsd_dblfault_cache (struct frame_info *this_frame, void **this_cache)
+{
+  struct gdbarch *gdbarch = get_frame_arch (this_frame);
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+  struct trad_frame_cache *cache;
+  CORE_ADDR addr, func, tss;
+  int i;
+
+  if (*this_cache != NULL)
+    return (struct trad_frame_cache *)(*this_cache);
+
+  cache = trad_frame_cache_zalloc (this_frame);
+  *this_cache = cache;
+
+  func = get_frame_func (this_frame);
+  tss = i386fbsd_fetch_tss ();
+
+  for (i = 0; i < ARRAY_SIZE (i386fbsd_tss_offset); i++)
+    if (i386fbsd_tss_offset[i] != -1)
+      trad_frame_set_reg_addr (cache, i, tss + i386fbsd_tss_offset[i]);
+
+  /* Construct the frame ID using the function start.  */
+  /* XXX: Stack address should be dbfault_stack + PAGE_SIZE. */
+  trad_frame_set_id (cache, frame_id_build (tss + sizeof(struct i386tss),
+					    func));
+
+  return cache;
+}
+
+static void
+i386fbsd_dblfault_this_id (struct frame_info *this_frame,
+			     void **this_cache, struct frame_id *this_id)
+{
+  struct trad_frame_cache *cache =
+    i386fbsd_dblfault_cache (this_frame, this_cache);
+  
+  trad_frame_get_id (cache, this_id);
+}
+
+static struct value *
+i386fbsd_dblfault_prev_register (struct frame_info *this_frame,
+				   void **this_cache, int regnum)
+{
+  struct trad_frame_cache *cache =
+    i386fbsd_dblfault_cache (this_frame, this_cache);
+
+  return trad_frame_get_register (cache, this_frame, regnum);
+}
+
+static int
+i386fbsd_dblfault_sniffer (const struct frame_unwind *self,
+			     struct frame_info *this_frame,
+			     void **this_prologue_cache)
+{
+  const char *name;
+
+  find_pc_partial_function (get_frame_func (this_frame), &name, NULL, NULL);
+  return (name && strcmp (name, "dblfault_handler") == 0);
+}
+
+static const struct frame_unwind i386fbsd_dblfault_unwind = {
+  SIGTRAMP_FRAME,
+  default_frame_unwind_stop_reason,
+  i386fbsd_dblfault_this_id,
+  i386fbsd_dblfault_prev_register,
+  NULL,
+  i386fbsd_dblfault_sniffer
+};
+#endif
+
+static const int i386fbsd_trapframe_offset[] = {
+  10 * 4,			/* %eax */
+  9 * 4,			/* %ecx */
+  8 * 4,			/* %edx */
+  7 * 4,			/* %ebx */
+  16 * 4,			/* %esp */
+  5 * 4,			/* %ebp */
+  4 * 4,			/* %esi */
+  3 * 4,			/* %edi */
+  13 * 4,			/* %eip */
+  15 * 4,			/* %eflags */
+  14 * 4,			/* %cs */
+  17 * 4,			/* %ss */
+  2 * 4,			/* %ds */
+  1 * 4,			/* %es */
+  0 * 4,			/* %fs */
+  -1				/* %gs */
+};
+
+#define	TRAPFRAME_SIZE		72
+
+static struct trad_frame_cache *
+i386fbsd_trapframe_cache (struct frame_info *this_frame, void **this_cache)
+{
+  struct gdbarch *gdbarch = get_frame_arch (this_frame);
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+  struct trad_frame_cache *cache;
+  struct i386fbsd_info *info;
+  CORE_ADDR addr, cs, func, pc, sp;
+  const char *name;
+  int i;
+
+  if (*this_cache != NULL)
+    return ((struct trad_frame_cache *)*this_cache);
+
+  info = get_i386fbsd_info();
+  cache = trad_frame_cache_zalloc (this_frame);
+  *this_cache = cache;
+
+  func = get_frame_func (this_frame);
+  sp = get_frame_register_unsigned (this_frame, I386_ESP_REGNUM);
+
+  find_pc_partial_function (func, &name, NULL, NULL);
+  if (strcmp(name, "calltrap") == 0 ||
+      strcmp(name, "Xlcall_syscall") == 0 ||
+      strcmp(name, "Xint0x80_syscall") == 0)
+    /* Traps in later kernels pass the trap frame by reference. */
+    sp += info->ofs_fix;
+  else if (strcmp(name, "Xtimerint") == 0)
+    /* Timer interrupts also pass the trap frame by reference. */
+    sp += info->ofs_fix;
+  else if (strcmp(name, "Xcpustop") == 0 ||
+	   strcmp(name, "Xrendezvous") == 0 ||
+	   strcmp(name, "Xipi_intr_bitmap_handler") == 0 ||
+	   strcmp(name, "Xlazypmap") == 0)
+    /* These handlers push a trap frame only. */
+    ;
+  else if (strcmp(name, "fork_trampoline") == 0)
+    if (get_frame_pc (this_frame) == func)
+      {
+	/* fork_exit hasn't been called (kthread has never run), so
+	   %esp in the pcb points to the word above the trapframe.  */
+	sp += 4;
+      }
+    else
+      {
+	/* fork_exit has been called, so %esp in fork_exit's
+	   frame is &tf - 12.  */
+	sp += 12;
+      }
+  else {
+    /* Interrupt frames pass the IDT vector in addition to the trap frame. */
+    sp += info->ofs_fix + 4;
+  }
+
+  addr = sp + i386fbsd_trapframe_offset[I386_CS_REGNUM];
+  cs = read_memory_unsigned_integer (addr, 4, byte_order);
+  for (i = 0; i < ARRAY_SIZE (i386fbsd_trapframe_offset); i++)
+    {
+      /* %ss/%esp are only present in the trapframe for a trap from
+          userland.  */
+      if ((cs & I386_SEL_RPL) == I386_SEL_KPL)
+	{
+	  if (i == I386_SS_REGNUM)
+	    continue;
+	  if (i == I386_ESP_REGNUM)
+	    {
+	      trad_frame_set_reg_value (cache, i, sp + TRAPFRAME_SIZE - 8);
+	      continue;
+	    }
+	}
+      if (i386fbsd_trapframe_offset[i] != -1)
+	trad_frame_set_reg_addr (cache, i, sp + i386fbsd_trapframe_offset[i]);
+    }
+
+  /* Read %eip from trap frame.  */
+  addr = sp + i386fbsd_trapframe_offset[I386_EIP_REGNUM];
+  pc = read_memory_unsigned_integer (addr, 4, byte_order);
+
+  if (pc == 0 && strcmp(name, "fork_trampoline") == 0)
+    {
+      /* Initial frame of a kthread; terminate backtrace.  */
+      trad_frame_set_id (cache, outer_frame_id);
+    }
+  else
+    {
+      /* Construct the frame ID using the function start.  */
+      sp += TRAPFRAME_SIZE;
+      if ((cs & I386_SEL_RPL) == I386_SEL_KPL)
+	sp -= 8;
+      trad_frame_set_id (cache, frame_id_build (sp, func));
+    }
+
+  return cache;
+}
+
+static void
+i386fbsd_trapframe_this_id (struct frame_info *this_frame,
+			     void **this_cache, struct frame_id *this_id)
+{
+  struct trad_frame_cache *cache =
+    i386fbsd_trapframe_cache (this_frame, this_cache);
+  
+  trad_frame_get_id (cache, this_id);
+}
+
+static struct value *
+i386fbsd_trapframe_prev_register (struct frame_info *this_frame,
+				   void **this_cache, int regnum)
+{
+  struct trad_frame_cache *cache =
+    i386fbsd_trapframe_cache (this_frame, this_cache);
+
+  return trad_frame_get_register (cache, this_frame, regnum);
+}
+
+static int
+i386fbsd_trapframe_sniffer (const struct frame_unwind *self,
+			     struct frame_info *this_frame,
+			     void **this_prologue_cache)
+{
+  const char *name;
+
+  find_pc_partial_function (get_frame_func (this_frame), &name, NULL, NULL);
+  return (name && ((strcmp (name, "calltrap") == 0)
+		   || (strcmp (name, "fork_trampoline") == 0)
+		   || (name[0] == 'X' && name[1] != '_')));
+}
+
+static const struct frame_unwind i386fbsd_trapframe_unwind = {
+  SIGTRAMP_FRAME,
+  default_frame_unwind_stop_reason,
+  i386fbsd_trapframe_this_id,
+  i386fbsd_trapframe_prev_register,
+  NULL,
+  i386fbsd_trapframe_sniffer
+};
+
+static void
+i386fbsd_kernel_init_abi(struct gdbarch_info info, struct gdbarch *gdbarch)
+{
+
+	i386_elf_init_abi(info, gdbarch);
+
+#ifdef __i386__
+	frame_unwind_prepend_unwinder(gdbarch, &i386fbsd_dblfault_unwind);
+#endif
+	frame_unwind_prepend_unwinder(gdbarch, &i386fbsd_trapframe_unwind);
+
+	set_solib_ops(gdbarch, &kld_so_ops);
+
+	fbsd_vmcore_set_supply_pcb(gdbarch, i386fbsd_supply_pcb);
+	fbsd_vmcore_set_cpu_pcb_addr(gdbarch, kgdb_trgt_stop_pcb);
+}
+
+void _initialize_i386_kgdb_tdep(void);
+
+void
+_initialize_i386_kgdb_tdep(void)
+{
+	/* This is used for both i386 and amd64, but amd64 always
+	   includes this target, so just include it here.  */
+	gdbarch_register_osabi_sniffer(bfd_arch_i386,
+				       bfd_target_elf_flavour,
+				       fbsd_kernel_osabi_sniffer);
+	gdbarch_register_osabi (bfd_arch_i386, 0,
+	    GDB_OSABI_FREEBSD_ELF_KERNEL, i386fbsd_kernel_init_abi);
+
+	i386fbsd_pspace_data = register_program_space_data_with_cleanup (NULL,
+	    i386fbsd_pspace_data_cleanup);
+
+#ifdef __i386__
+	/*
+	 * FreeBSD/i386 kernels prior to the introduction of AVX
+	 * support used a different layout for the PCB.  If gdb is
+	 * compiled on these systems, these asserts will fail.  The
+	 * package builders build packages on older systems which are
+	 * then run on newer systems.  These binaries trip over these
+	 * assertions even when debugging user programs and even
+	 * though the running kernel is new enough.  To cope, disable
+	 * the assertion checks unless gdb is built against a new
+	 * enough world.  Note that this means kgdb is not going to
+	 * parse PCBs correctly on FreeBSD/i386 kernels before AVX was
+	 * merged.
+	 */
+#if __FreeBSD_version >= 1001505
+	gdb_assert(offsetof(struct pcb, pcb_ebx)
+		   == i386fbsd_pcb_offset[I386_EBX_REGNUM]);
+	gdb_assert(offsetof(struct pcb, pcb_esp)
+		   == i386fbsd_pcb_offset[I386_ESP_REGNUM]);
+	gdb_assert(offsetof(struct pcb, pcb_ebp)
+		   == i386fbsd_pcb_offset[I386_EBP_REGNUM]);
+	gdb_assert(offsetof(struct pcb, pcb_esi)
+		   == i386fbsd_pcb_offset[I386_ESI_REGNUM]);
+	gdb_assert(offsetof(struct pcb, pcb_edi)
+		   == i386fbsd_pcb_offset[I386_EDI_REGNUM]);
+	gdb_assert(offsetof(struct pcb, pcb_eip)
+		   == i386fbsd_pcb_offset[I386_EIP_REGNUM]);
+#endif
+	gdb_assert(CODE_SEL == GSEL(GCODE_SEL, SEL_KPL));
+	gdb_assert(DATA_SEL == GSEL(GDATA_SEL, SEL_KPL));
+	gdb_assert(PRIV_SEL == GSEL(GPRIV_SEL, SEL_KPL));
+	gdb_assert(sizeof(struct trapframe) == TRAPFRAME_SIZE);
+	gdb_assert(offsetof(struct trapframe, tf_eax)
+		   == i386fbsd_trapframe_offset[I386_EAX_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_ecx)
+		   == i386fbsd_trapframe_offset[I386_ECX_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_edx)
+		   == i386fbsd_trapframe_offset[I386_EDX_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_ebx)
+		   == i386fbsd_trapframe_offset[I386_EBX_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_esp)
+		   == i386fbsd_trapframe_offset[I386_ESP_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_ebp)
+		   == i386fbsd_trapframe_offset[I386_EBP_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_esi)
+		   == i386fbsd_trapframe_offset[I386_ESI_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_edi)
+		   == i386fbsd_trapframe_offset[I386_EDI_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_eip)
+		   == i386fbsd_trapframe_offset[I386_EIP_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_eflags)
+		   == i386fbsd_trapframe_offset[I386_EFLAGS_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_cs)
+		   == i386fbsd_trapframe_offset[I386_CS_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_ss)
+		   == i386fbsd_trapframe_offset[I386_SS_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_ds)
+		   == i386fbsd_trapframe_offset[I386_DS_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_es)
+		   == i386fbsd_trapframe_offset[I386_ES_REGNUM]);
+	gdb_assert(offsetof(struct trapframe, tf_fs)
+		   == i386fbsd_trapframe_offset[I386_FS_REGNUM]);
+
+	gdb_assert(offsetof(struct i386tss, tss_eax)
+		   == i386fbsd_tss_offset[I386_EAX_REGNUM]);
+	gdb_assert(offsetof(struct i386tss, tss_ecx)
+		   == i386fbsd_tss_offset[I386_ECX_REGNUM]);
+	gdb_assert(offsetof(struct i386tss, tss_edx)
+		   == i386fbsd_tss_offset[I386_EDX_REGNUM]);
+	gdb_assert(offsetof(struct i386tss, tss_ebx)
+		   == i386fbsd_tss_offset[I386_EBX_REGNUM]);
+	gdb_assert(offsetof(struct i386tss, tss_esp)
+		   == i386fbsd_tss_offset[I386_ESP_REGNUM]);
+	gdb_assert(offsetof(struct i386tss, tss_ebp)
+		   == i386fbsd_tss_offset[I386_EBP_REGNUM]);
+	gdb_assert(offsetof(struct i386tss, tss_esi)
+		   == i386fbsd_tss_offset[I386_ESI_REGNUM]);
+	gdb_assert(offsetof(struct i386tss, tss_edi)
+		   == i386fbsd_tss_offset[I386_EDI_REGNUM]);
+	gdb_assert(offsetof(struct i386tss, tss_eip)
+		   == i386fbsd_tss_offset[I386_EIP_REGNUM]);
+	gdb_assert(offsetof(struct i386tss, tss_eflags)
+		   == i386fbsd_tss_offset[I386_EFLAGS_REGNUM]);
+	gdb_assert(offsetof(struct i386tss, tss_cs)
+		   == i386fbsd_tss_offset[I386_CS_REGNUM]);
+	gdb_assert(offsetof(struct i386tss, tss_ss)
+		   == i386fbsd_tss_offset[I386_SS_REGNUM]);
+	gdb_assert(offsetof(struct i386tss, tss_ds)
+		   == i386fbsd_tss_offset[I386_DS_REGNUM]);
+	gdb_assert(offsetof(struct i386tss, tss_es)
+		   == i386fbsd_tss_offset[I386_ES_REGNUM]);
+	gdb_assert(offsetof(struct i386tss, tss_fs)
+		   == i386fbsd_tss_offset[I386_FS_REGNUM]);
+	gdb_assert(offsetof(struct i386tss, tss_gs)
+		   == i386fbsd_tss_offset[I386_GS_REGNUM]);
+#endif
+}
diff --git a/devel/gdb-good/files/kgdb/kgdb-main.c b/devel/gdb-good/files/kgdb/kgdb-main.c
new file mode 100644
index 00000000000..ced75195cd9
--- /dev/null
+++ b/devel/gdb-good/files/kgdb/kgdb-main.c
@@ -0,0 +1,407 @@
+/*
+ * Copyright (c) 2004 Marcel Moolenaar
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: head/devel/gdb/files/kgdb/kgdb-main.c 428876 2016-12-18 16:08:14Z tijl $");
+
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/resource.h>
+#include <sys/select.h>
+#include <sys/time.h>
+#include <sys/wait.h>
+#include <errno.h>
+#include <err.h>
+#include <kvm.h>
+#include <limits.h>
+#include <paths.h>
+
+/* libgdb stuff. */
+#include <defs.h>
+#include <frame.h>
+#include <frame-unwind.h>
+#include <inferior.h>
+#include <interps.h>
+#include <cli-out.h>
+#include <main.h>
+#include <objfiles.h>
+#include "observer.h"
+#include <target.h>
+#include <top.h>
+#include <ui-file.h>
+#include <bfd.h>
+#include <gdbcore.h>
+
+#include <unistd.h>
+
+#include "kgdb.h"
+
+static int verbose;
+
+static char crashdir[PATH_MAX];
+static char *dumpnr;
+static char *kernel;
+static char *remote;
+static char *vmcore;
+
+/*
+ * TODO:
+ * - test remote kgdb (see if threads and klds work)
+ * - possibly split kthr.c out into a separate thread_stratum target that
+ *   uses new_objfile test to push itself when a FreeBSD kernel is loaded
+ *   (check for kernel osabi) (probably don't bother with this)
+ * + test alternate kgdb_lookup()
+ * + fix kgdb build on amd64 to include i386 cross-debug support
+ * - propose expanded libkvm interface that supports cross-debug and moves
+ *   MD bits of kgdb into the library (examining PCB's and exporting a
+ *   stable-ABI struct of registers, similarly for trapframe handling and
+ *   stop-pcb stuff
+ * + use tid's as lwp IDs instead of PIDs in ptid's
+ */
+
+static void
+usage(void)
+{
+
+	fprintf(stderr,
+	    "usage: %s [-afqvw] [-b rate] [-d crashdir] [-c core | -n dumpnr | -r device]\n"
+	    "\t[kernel [core]]\n", getprogname());
+	exit(1);
+}
+
+static void
+kernel_from_dumpnr(const char *nr)
+{
+	char line[PATH_MAX], path[PATH_MAX];
+	FILE *info;
+	char *dir;
+	struct stat st;
+	int l;
+
+	/*
+	 * If there's a kernel image right here in the crash directory, then
+	 * use it.  The kernel image is either called kernel.<nr> or is in a
+	 * subdirectory kernel.<nr> and called kernel.  The latter allows us
+	 * to collect the modules in the same place.
+	 */
+	snprintf(path, sizeof(path), "%s/kernel.%s", crashdir, nr);
+	if (stat(path, &st) == 0) {
+		if (S_ISREG(st.st_mode)) {
+			kernel = strdup(path);
+			return;
+		}
+		if (S_ISDIR(st.st_mode)) {
+			snprintf(path, sizeof(path), "%s/kernel.%s/kernel",
+			    crashdir, nr);
+			if (stat(path, &st) == 0 && S_ISREG(st.st_mode)) {
+				kernel = strdup(path);
+				return;
+			}
+		}
+	}
+
+	/*
+	 * No kernel image here.  Parse the dump header.  The kernel object
+	 * directory can be found there and we probably have the kernel
+	 * image still in it.  The object directory may also have a kernel
+	 * with debugging info (called either kernel.full or kernel.debug).
+	 * If we have a debug kernel, use it.
+	 */
+	snprintf(path, sizeof(path), "%s/info.%s", crashdir, nr);
+	info = fopen(path, "r");
+	if (info == NULL) {
+		warn("%s", path);
+		return;
+	}
+	while (fgets(line, sizeof(line), info) != NULL) {
+		l = strlen(line);
+		if (l > 0 && line[l - 1] == '\n')
+			line[--l] = '\0';
+		if (strncmp(line, "    ", 4) == 0) {
+			fclose(info);
+			dir = strchr(line, ':');
+			dir = (dir == NULL) ? line + 4 : dir + 1;
+
+			/*
+			 * Check for kernel.full first as if it exists
+			 * kernel.debug will also exist, but will only
+			 * contain debug symbols and not be recognized
+			 * as a valid kernel by the osabi sniffer.
+			 */
+			snprintf(path, sizeof(path), "%s/kernel.full", dir);
+			if (stat(path, &st) == 0 && S_ISREG(st.st_mode)) {
+				kernel = strdup(path);
+				return;
+			}
+			snprintf(path, sizeof(path), "%s/kernel.debug", dir);
+			if (stat(path, &st) == 0 && S_ISREG(st.st_mode)) {
+				kernel = strdup(path);
+				return;
+			}
+			snprintf(path, sizeof(path), "%s/kernel", dir);
+			if (stat(path, &st) == 0 && S_ISREG(st.st_mode)) {
+				kernel = strdup(path);
+				return;
+			}
+			return;
+		}
+	}
+	fclose(info);
+}
+
+/*
+ * Remote targets can support any number of syntaxes and we want to
+ * support them all with one addition: we support specifying a device
+ * node for a serial device without the "/dev/" prefix.
+ *
+ * What we do is to stat(2) the existing remote target first.  If that
+ * fails, we try it with "/dev/" prepended.  If that succeeds we use
+ * the resulting path, otherwise we use the original target.  If
+ * either stat(2) succeeds make sure the file is either a character
+ * device or a FIFO.
+ */
+static void
+verify_remote(void)
+{
+	char path[PATH_MAX];
+	struct stat st;
+
+	if (stat(remote, &st) != 0) {
+		snprintf(path, sizeof(path), "/dev/%s", remote);
+		if (stat(path, &st) != 0)
+			return;
+		free(remote);
+		remote = strdup(path);
+	}
+	if (!S_ISCHR(st.st_mode) && !S_ISFIFO(st.st_mode))
+		errx(1, "%s: not a special file, FIFO or socket", remote);
+}
+
+static void
+add_arg(struct captured_main_args *args, char *arg)
+{
+
+	args->argc++;
+	args->argv = (char **)reallocf(args->argv, (args->argc + 1) *
+	    sizeof(char *));
+	if (args->argv == NULL)
+		err(1, "Out of memory building argument list");
+	args->argv[args->argc] = arg;
+}
+
+int
+main(int argc, char *argv[])
+{
+	char path[PATH_MAX];
+	struct stat st;
+	struct captured_main_args args;
+	char *s;
+	int a, ch;
+
+	dumpnr = NULL;
+
+	strlcpy(crashdir, "/var/crash", sizeof(crashdir));
+	s = getenv("KGDB_CRASH_DIR");
+	if (s != NULL)
+		strlcpy(crashdir, s, sizeof(crashdir));
+
+	/* Convert long options into short options. */
+	for (a = 1; a < argc; a++) {
+		s = argv[a];
+		if (s[0] == '-') {
+			s++;
+			/* Long options take either 1 or 2 dashes. */
+			if (s[0] == '-')
+				s++;
+			if (strcmp(s, "quiet") == 0)
+				argv[a] = "-q";
+			else if (strcmp(s, "fullname") == 0)
+				argv[a] = "-f";
+		}
+	}
+
+	kgdb_quiet = 0;
+	memset (&args, 0, sizeof args);
+	args.interpreter_p = INTERP_CONSOLE;
+	args.argv = (char **)xmalloc(sizeof(char *));
+	args.argv[0] = argv[0];
+
+	while ((ch = getopt(argc, argv, "ab:c:d:fn:qr:vw")) != -1) {
+		switch (ch) {
+		case 'a':
+			annotation_level++;
+			break;
+		case 'b': {
+			int i;
+			char *p;
+
+			i = strtol(optarg, &p, 0);
+			if (*p != '\0' || p == optarg)
+				warnx("warning: could not set baud rate to `%s'.\n",
+				    optarg);
+			else
+				baud_rate = i;
+			break;
+		}
+		case 'c':	/* use given core file. */
+			if (vmcore != NULL) {
+				warnx("option %c: can only be specified once",
+				    optopt);
+				usage();
+				/* NOTREACHED */
+			}
+			vmcore = strdup(optarg);
+			break;
+		case 'd':	/* lookup dumps in given directory. */
+			strlcpy(crashdir, optarg, sizeof(crashdir));
+			break;
+		case 'f':
+			annotation_level = 1;
+			break;
+		case 'n':	/* use dump with given number. */
+			dumpnr = optarg;
+			break;
+		case 'q':
+			kgdb_quiet = 1;
+			add_arg(&args, "-q");
+			break;
+		case 'r':	/* use given device for remote session. */
+			if (remote != NULL) {
+				warnx("option %c: can only be specified once",
+				    optopt);
+				usage();
+				/* NOTREACHED */
+			}
+			remote = strdup(optarg);
+			break;
+		case 'v':	/* increase verbosity. */
+			verbose++;
+			break;
+		case 'w':	/* core file is writeable. */
+			add_arg(&args, "--write");
+			break;
+		case '?':
+		default:
+			usage();
+		}
+	}
+
+	if (((vmcore != NULL) ? 1 : 0) + ((dumpnr != NULL) ? 1 : 0) +
+	    ((remote != NULL) ? 1 : 0) > 1) {
+		warnx("options -c, -n and -r are mutually exclusive");
+		usage();
+		/* NOTREACHED */
+	}
+
+	if (verbose > 1)
+		warnx("using %s as the crash directory", crashdir);
+
+	if (argc > optind)
+		kernel = strdup(argv[optind++]);
+
+	if (argc > optind && (dumpnr != NULL || remote != NULL)) {
+		warnx("options -n and -r do not take a core file. Ignored");
+		optind = argc;
+	}
+
+	if (dumpnr != NULL) {
+		snprintf(path, sizeof(path), "%s/vmcore.%s", crashdir, dumpnr);
+		if (stat(path, &st) == -1)
+			err(1, "%s", path);
+		if (!S_ISREG(st.st_mode))
+			errx(1, "%s: not a regular file", path);
+		vmcore = strdup(path);
+	} else if (remote != NULL) {
+		verify_remote();
+	} else if (argc > optind) {
+		if (vmcore == NULL)
+			vmcore = strdup(argv[optind++]);
+		if (argc > optind)
+			warnx("multiple core files specified. Ignored");
+	} else if (vmcore == NULL && kernel == NULL) {
+		vmcore = strdup(_PATH_MEM);
+		kernel = strdup(getbootfile());
+	}
+
+	if (verbose) {
+		if (vmcore != NULL)
+			warnx("core file: %s", vmcore);
+		if (remote != NULL)
+			warnx("device file: %s", remote);
+		if (kernel != NULL)
+			warnx("kernel image: %s", kernel);
+	}
+
+	/* A remote target requires an explicit kernel argument. */
+	if (remote != NULL && kernel == NULL) {
+		warnx("remote debugging requires a kernel");
+		usage();
+		/* NOTREACHED */
+	}
+
+	/* If we don't have a kernel image yet, try to find one. */
+	if (kernel == NULL) {
+		if (dumpnr != NULL)
+			kernel_from_dumpnr(dumpnr);
+
+		if (kernel == NULL)
+			errx(1, "couldn't find a suitable kernel image");
+		if (verbose)
+			warnx("kernel image: %s", kernel);
+	}
+
+	/* Set an alternate prompt. */
+	add_arg(&args, "-iex");
+	add_arg(&args, "set prompt (kgdb) ");
+
+	/* Open the vmcore if requested. */
+	if (vmcore != NULL) {
+		add_arg(&args, "-ex");
+		if (asprintf(&s, "target vmcore %s", vmcore) < 0)
+			err(1, "couldn't build command line");
+		add_arg(&args, s);
+	}
+
+	/* Open the remote target if requested. */
+	if (remote != NULL) {
+		add_arg(&args, "-ex");
+		if (asprintf(&s, "target remote %s", remote) < 0)
+			err(1, "couldn't build command line");
+		add_arg(&args, s);
+	}
+
+	add_arg(&args, kernel);
+
+	/* The libgdb code uses optind too. Reset it... */
+	optind = 0;
+
+	/* Terminate argv list. */
+	add_arg(&args, NULL);
+
+	return (gdb_main(&args));
+}
diff --git a/devel/gdb-good/files/kgdb/kgdb.1 b/devel/gdb-good/files/kgdb/kgdb.1
new file mode 100644
index 00000000000..09209bf6cd4
--- /dev/null
+++ b/devel/gdb-good/files/kgdb/kgdb.1
@@ -0,0 +1,140 @@
+.\" Copyright (c) 2004 Marcel Moolenaar
+.\" All rights reserved.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+.\" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+.\" IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+.\" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+.\" BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+.\" LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+.\" AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+.\" OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.\" $FreeBSD: head/devel/gdb/files/kgdb/kgdb.1 440447 2017-05-08 19:02:25Z jhb $
+.\"
+.Dd October 11, 2006
+.Dt KGDB 1
+.Os
+.Sh NAME
+.Nm kgdb
+.Nd "kernel debugger"
+.Sh SYNOPSIS
+.Nm
+.Op Fl a | Fl f | Fl fullname
+.Op Fl b Ar rate
+.Op Fl q | Fl quiet
+.Op Fl v
+.Op Fl w
+.Op Fl d Ar crashdir
+.Op Fl c Ar core | Fl n Ar dumpnr | Fl r Ar device
+.Op Ar kernel Op Ar core
+.Sh DESCRIPTION
+The
+.Nm
+utility is a debugger based on
+.Xr gdb 1
+that allows debugging of kernel core files.
+.Pp
+The options are as follows:
+.Bl -tag -width ".Fl d Ar crashdir"
+.It Fl a
+Increase the annotation level.
+An annotation level of 1 features the historical
+.Fl fullname
+option of
+.Xr gdb 1 .
+This is useful when running
+.Nm
+in Emacs.
+The
+.Fl f
+or
+.Fl fullname
+options are supported for backward compatibility as well.
+.It Fl b Ar rate
+Set the baudrate to
+.Ar rate .
+.It Fl q
+Suppress printing of the banner when the debugger starts.
+The
+.Fl quiet
+form is supported for compatibility as well.
+.It Fl v
+Increase verbosity.
+.It Fl w
+Opens kmem-based targets in read-write mode.
+(This is identical to what
+.Fl -wcore
+used to do in previous
+gdb versions for
+.Fx . )
+.It Fl d Ar crashdir
+Use
+.Ar crashdir
+instead of the default,
+.Pa /var/crash
+to locate kernel core dump files in.
+The name
+.Pa vmcore.
+plus the dump number will be appended to determine
+the actual dump file name.
+.It Fl c Ar core
+Explicitly use
+.Ar core
+as the core dump file.
+.It Fl n Ar dumpnr
+Use the kernel core dump file numbered
+.Ar dumpnr
+for debugging.
+.It Fl r Ar device
+Use
+.Ar device
+to connect
+.Nm
+to for a remote debugging session.
+.El
+.Pp
+The
+.Fl c , n ,
+and
+.Fl r
+options are mutually exclusive.
+.Pp
+Optionally, the name of the kernel symbol file and
+the name of the core dump file can be supplied on the
+command-line as positional arguments.
+If no kernel symbol file name has been given, the
+symbol file of the currently running kernel will be
+used.
+If no core dump file has been specified through either
+of the options or the last command-line argument,
+.Pa /dev/mem
+will be opened to allow debugging the currently running
+kernel.
+.Sh FILES
+.Bl -tag -width ".Pa /var/crash"
+.It Pa /dev/mem
+Default memory image to open if no core dump file
+has been specified.
+.It Pa /var/crash
+Default directory to locate kernel core dump files.
+.El
+.Sh SEE ALSO
+.Xr gdb 1
+.Sh HISTORY
+The
+.Nm
+utility first appeared in its current form in
+.Fx 5.3 .
diff --git a/devel/gdb-good/files/kgdb/kgdb.h b/devel/gdb-good/files/kgdb/kgdb.h
new file mode 100644
index 00000000000..895e04052d0
--- /dev/null
+++ b/devel/gdb-good/files/kgdb/kgdb.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2004 Marcel Moolenaar
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD: head/devel/gdb/files/kgdb/kgdb.h 398712 2015-10-06 18:52:58Z jhb $
+ */
+
+#ifndef _KGDB_H_
+#define	_KGDB_H_
+
+struct kthr {
+	struct kthr	*next;
+	CORE_ADDR	paddr;
+	CORE_ADDR	kaddr;
+	CORE_ADDR	pcb;
+	int		tid;
+	int		pid;
+	int		cpu;
+};
+
+extern struct kthr *curkthr;
+extern struct target_so_ops kld_so_ops;
+extern struct target_ops kgdb_trgt_ops;
+extern int kgdb_quiet;
+
+CORE_ADDR kgdb_trgt_stop_pcb(u_int);
+
+struct kthr *kgdb_thr_first(void);
+struct kthr *kgdb_thr_init(CORE_ADDR (*cpu_pcb_addr) (u_int));
+struct kthr *kgdb_thr_lookup_tid(int);
+struct kthr *kgdb_thr_lookup_pid(int);
+struct kthr *kgdb_thr_lookup_paddr(uintptr_t);
+struct kthr *kgdb_thr_lookup_taddr(uintptr_t);
+struct kthr *kgdb_thr_next(struct kthr *);
+char        *kgdb_thr_extra_thread_info(int);
+
+enum gdb_osabi fbsd_kernel_osabi_sniffer(bfd *abfd);
+void fbsd_vmcore_set_supply_pcb (struct gdbarch *gdbarch,
+				 void (*supply_pcb) (struct regcache *,
+						     CORE_ADDR));
+void fbsd_vmcore_set_cpu_pcb_addr (struct gdbarch *gdbarch,
+				   CORE_ADDR (*cpu_pcb_addr) (u_int));
+
+CORE_ADDR kgdb_lookup(const char *sym);
+
+#endif /* _KGDB_H_ */
diff --git a/devel/gdb-good/files/kgdb/mipsfbsd-kern.c b/devel/gdb-good/files/kgdb/mipsfbsd-kern.c
new file mode 100644
index 00000000000..dafa93227d8
--- /dev/null
+++ b/devel/gdb-good/files/kgdb/mipsfbsd-kern.c
@@ -0,0 +1,305 @@
+/*
+ * Copyright (c) 2007 Juniper Networks, Inc.
+ * Copyright (c) 2004 Marcel Moolenaar
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * from: src/gnu/usr.bin/gdb/kgdb/trgt_alpha.c,v 1.2.2.1 2005/09/15 05:32:10 marcel
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/types.h>
+#ifdef __mips__
+#include <machine/asm.h>
+#include <machine/pcb.h>
+#include <machine/frame.h>
+#endif
+#include <string.h>
+
+#include <defs.h>
+#include <frame-unwind.h>
+//#include <target.h>
+//#include <gdbthread.h>
+//#include <inferior.h>
+#include "osabi.h"
+#include <regcache.h>
+#include "solib.h"
+#include "trad-frame.h"
+#include <mips-tdep.h>
+
+#include "kgdb.h"
+
+/* Size of struct trapframe in registers. */
+#define	TRAPFRAME_WORDS	74
+
+/* From sys/mips/include/pcb.h.  Offsets in the pcb_context[] array. */
+#define	FBSD_PCB_REG_S0	0
+#define	FBSD_PCB_REG_S1	1
+#define	FBSD_PCB_REG_S2	2
+#define	FBSD_PCB_REG_S3	3
+#define	FBSD_PCB_REG_S4	4
+#define	FBSD_PCB_REG_S5	5
+#define	FBSD_PCB_REG_S6	6
+#define	FBSD_PCB_REG_S7	7
+#define	FBSD_PCB_REG_SP	8
+#define	FBSD_PCB_REG_S8	9
+#define	FBSD_PCB_REG_RA	10
+#define	FBSD_PCB_REG_SR	11
+#define	FBSD_PCB_REG_GP	12
+#define	FBSD_PCB_REG_PC	13
+
+#ifdef __mips__
+_Static_assert(TRAPFRAME_WORDS * sizeof(register_t) ==
+	       sizeof(struct trapframe), "TRAPFRAME_WORDS mismatch");
+_Static_assert(FBSD_PCB_REG_S0 == PCB_REG_S0, "PCB_REG_S0 mismatch");
+_Static_assert(FBSD_PCB_REG_S1 == PCB_REG_S1, "PCB_REG_S1 mismatch");
+_Static_assert(FBSD_PCB_REG_S2 == PCB_REG_S2, "PCB_REG_S2 mismatch");
+_Static_assert(FBSD_PCB_REG_S3 == PCB_REG_S3, "PCB_REG_S3 mismatch");
+_Static_assert(FBSD_PCB_REG_S4 == PCB_REG_S4, "PCB_REG_S4 mismatch");
+_Static_assert(FBSD_PCB_REG_S5 == PCB_REG_S5, "PCB_REG_S5 mismatch");
+_Static_assert(FBSD_PCB_REG_S6 == PCB_REG_S6, "PCB_REG_S6 mismatch");
+_Static_assert(FBSD_PCB_REG_S7 == PCB_REG_S7, "PCB_REG_S7 mismatch");
+_Static_assert(FBSD_PCB_REG_SP == PCB_REG_SP, "PCB_REG_SP mismatch");
+_Static_assert(FBSD_PCB_REG_S8 == PCB_REG_S8, "PCB_REG_S8 mismatch");
+_Static_assert(FBSD_PCB_REG_RA == PCB_REG_RA, "PCB_REG_RA mismatch");
+_Static_assert(FBSD_PCB_REG_SR == PCB_REG_SR, "PCB_REG_SR mismatch");
+_Static_assert(FBSD_PCB_REG_GP == PCB_REG_GP, "PCB_REG_GP mismatch");
+_Static_assert(FBSD_PCB_REG_PC == PCB_REG_PC, "PCB_REG_PC mismatch");
+#endif
+
+static void
+mipsfbsd_supply_pcb(struct regcache *regcache, CORE_ADDR pcb_addr)
+{
+  struct gdbarch *gdbarch = get_regcache_arch (regcache);
+  size_t regsize = mips_isa_regsize (gdbarch);
+  gdb_byte buf[regsize * (FBSD_PCB_REG_PC + 1)];
+
+  /* Read the entire pcb_context[] array in one go.  The pcb_context[]
+     array is after the pcb_regs member which is a trapframe.  */
+  if (target_read_memory (pcb_addr + TRAPFRAME_WORDS * regsize, buf,
+			  sizeof(buf)) != 0)
+    return;
+
+  regcache_raw_supply_unsigned (regcache, MIPS_ZERO_REGNUM, 0);
+  regcache_raw_supply (regcache, MIPS_S2_REGNUM - 2,
+		       buf + (regsize * FBSD_PCB_REG_S0));
+  regcache_raw_supply (regcache, MIPS_S2_REGNUM - 1,
+		       buf + (regsize * FBSD_PCB_REG_S1));
+  regcache_raw_supply (regcache, MIPS_S2_REGNUM,
+		       buf + (regsize * FBSD_PCB_REG_S2));
+  regcache_raw_supply (regcache, MIPS_S2_REGNUM + 1,
+		       buf + (regsize * FBSD_PCB_REG_S3));
+  regcache_raw_supply (regcache, MIPS_S2_REGNUM + 2,
+		       buf + (regsize * FBSD_PCB_REG_S4));
+  regcache_raw_supply (regcache, MIPS_S2_REGNUM + 3,
+		       buf + (regsize * FBSD_PCB_REG_S5));
+  regcache_raw_supply (regcache, MIPS_S2_REGNUM + 4,
+		       buf + (regsize * FBSD_PCB_REG_S6));
+  regcache_raw_supply (regcache, MIPS_S2_REGNUM + 5,
+		       buf + (regsize * FBSD_PCB_REG_S7));
+  regcache_raw_supply (regcache, MIPS_SP_REGNUM,
+		       buf + (regsize * FBSD_PCB_REG_SP));
+  regcache_raw_supply (regcache, MIPS_S2_REGNUM + 6,
+		       buf + (regsize * FBSD_PCB_REG_S8));
+  regcache_raw_supply (regcache, MIPS_RA_REGNUM,
+		       buf + (regsize * FBSD_PCB_REG_RA));
+  regcache_raw_supply (regcache, MIPS_PS_REGNUM,
+		       buf + (regsize * FBSD_PCB_REG_SR));
+  regcache_raw_supply (regcache, MIPS_GP_REGNUM,
+		       buf + (regsize * FBSD_PCB_REG_GP));
+  regcache_raw_supply (regcache, MIPS_EMBED_PC_REGNUM,
+		       buf + (regsize * FBSD_PCB_REG_PC));
+}
+
+static struct trad_frame_cache *
+mipsfbsd_trapframe_cache (struct frame_info *this_frame, void **this_cache)
+{
+  struct gdbarch *gdbarch = get_frame_arch (this_frame);
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+  size_t regsize = mips_isa_regsize (gdbarch);
+  struct trad_frame_cache *cache;
+  CORE_ADDR addr, func, pc, sp;
+  int regnum;
+
+  if (*this_cache != NULL)
+    return ((struct trad_frame_cache *)*this_cache);
+
+  cache = trad_frame_cache_zalloc (this_frame);
+  *this_cache = cache;
+
+  func = get_frame_func (this_frame);
+  sp = get_frame_register_signed (this_frame,
+				  MIPS_SP_REGNUM + gdbarch_num_regs (gdbarch));
+
+  /* Skip over CALLFRAME_SIZ.  */
+  addr = sp;
+  if (regsize == 8)
+    addr += regsize * 4;
+  else
+    addr += regsize * (4 + 2);
+
+  /* GPRs.  Skip zero.  */
+  addr += regsize;
+  for (regnum = MIPS_AT_REGNUM; regnum <= MIPS_RA_REGNUM; regnum++)
+    {
+      trad_frame_set_reg_addr (cache,
+			       regnum + gdbarch_num_regs (gdbarch),
+			       addr);
+      addr += regsize;
+    }
+
+  regnum = MIPS_PS_REGNUM;
+  trad_frame_set_reg_addr (cache,
+			   regnum + gdbarch_num_regs (gdbarch),
+			   addr);
+  addr += regsize;
+
+  /* HI and LO.  */
+  regnum = mips_regnum (gdbarch)->lo;
+  trad_frame_set_reg_addr (cache,
+			   regnum + gdbarch_num_regs (gdbarch),
+			   addr);
+  addr += regsize;
+  regnum = mips_regnum (gdbarch)->hi;
+  trad_frame_set_reg_addr (cache,
+			   regnum + gdbarch_num_regs (gdbarch),
+			   addr);
+  addr += regsize;
+
+  /* BADVADDR.  */
+  regnum = mips_regnum (gdbarch)->badvaddr;
+  trad_frame_set_reg_addr (cache,
+			   regnum + gdbarch_num_regs (gdbarch),
+			   addr);
+  addr += regsize;
+
+  /* CAUSE.  */
+  regnum = mips_regnum (gdbarch)->cause;
+  trad_frame_set_reg_addr (cache,
+			   regnum + gdbarch_num_regs (gdbarch),
+			   addr);
+  addr += regsize;
+
+  /* PC.  */
+  regnum = mips_regnum (gdbarch)->pc;
+  trad_frame_set_reg_addr (cache,
+			   regnum + gdbarch_num_regs (gdbarch),
+			   addr);
+  
+  trad_frame_set_id (cache, frame_id_build (sp + TRAPFRAME_WORDS * regsize,
+					    func));
+  return cache;
+}
+
+static void
+mipsfbsd_trapframe_this_id (struct frame_info *this_frame,
+			    void **this_cache, struct frame_id *this_id)
+{
+  struct trad_frame_cache *cache =
+    mipsfbsd_trapframe_cache (this_frame, this_cache);
+  
+  trad_frame_get_id (cache, this_id);
+}
+
+static struct value *
+mipsfbsd_trapframe_prev_register (struct frame_info *this_frame,
+				  void **this_cache, int regnum)
+{
+  struct trad_frame_cache *cache =
+    mipsfbsd_trapframe_cache (this_frame, this_cache);
+
+  return trad_frame_get_register (cache, this_frame, regnum);
+}
+
+static int
+mipsfbsd_trapframe_sniffer (const struct frame_unwind *self,
+			    struct frame_info *this_frame,
+			    void **this_prologue_cache)
+{
+  const char *name;
+
+  find_pc_partial_function (get_frame_func (this_frame), &name, NULL, NULL);
+  return (name && ((strcmp(name, "MipsKernIntr") == 0) ||
+		   (strcmp(name, "MipsKernGenException") == 0) ||
+		   (strcmp(name, "MipsTLBInvalidException") == 0)));
+}
+
+static const struct frame_unwind mipsfbsd_trapframe_unwind = {
+  SIGTRAMP_FRAME,
+  default_frame_unwind_stop_reason,
+  mipsfbsd_trapframe_this_id,
+  mipsfbsd_trapframe_prev_register,
+  NULL,
+  mipsfbsd_trapframe_sniffer
+};
+
+static void
+mipsfbsd_kernel_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
+{
+  enum mips_abi abi = mips_abi (gdbarch);
+
+  set_gdbarch_software_single_step (gdbarch, mips_software_single_step);
+
+  switch (abi)
+    {
+      case MIPS_ABI_O32:
+	break;
+      case MIPS_ABI_N32:
+	set_gdbarch_long_double_bit (gdbarch, 128);
+	/* These floatformats should probably be renamed.  MIPS uses
+	   the same 128-bit IEEE floating point format that IA-64 uses,
+	   except that the quiet/signalling NaN bit is reversed (GDB
+	   does not distinguish between quiet and signalling NaNs).  */
+	set_gdbarch_long_double_format (gdbarch, floatformats_ia64_quad);
+	break;
+      case MIPS_ABI_N64:
+	set_gdbarch_long_double_bit (gdbarch, 128);
+	/* These floatformats should probably be renamed.  MIPS uses
+	   the same 128-bit IEEE floating point format that IA-64 uses,
+	   except that the quiet/signalling NaN bit is reversed (GDB
+	   does not distinguish between quiet and signalling NaNs).  */
+	set_gdbarch_long_double_format (gdbarch, floatformats_ia64_quad);
+	break;
+    }
+
+  frame_unwind_prepend_unwinder (gdbarch, &mipsfbsd_trapframe_unwind);
+
+  set_solib_ops (gdbarch, &kld_so_ops);
+
+  fbsd_vmcore_set_supply_pcb (gdbarch, mipsfbsd_supply_pcb);
+  fbsd_vmcore_set_cpu_pcb_addr (gdbarch, kgdb_trgt_stop_pcb);
+}
+
+void _initialize_mips_kgdb_tdep (void);
+
+void
+_initialize_mips_kgdb_tdep (void)
+{
+  gdbarch_register_osabi_sniffer(bfd_arch_mips,
+				 bfd_target_elf_flavour,
+				 fbsd_kernel_osabi_sniffer);
+  gdbarch_register_osabi (bfd_arch_mips, 0, GDB_OSABI_FREEBSD_ELF_KERNEL,
+			  mipsfbsd_kernel_init_abi);
+}
diff --git a/devel/gdb-good/files/kgdb/ppcfbsd-kern.c b/devel/gdb-good/files/kgdb/ppcfbsd-kern.c
new file mode 100644
index 00000000000..0d88f3ae2da
--- /dev/null
+++ b/devel/gdb-good/files/kgdb/ppcfbsd-kern.c
@@ -0,0 +1,254 @@
+/*-
+ * Copyright (c) 2006 Marcel Moolenaar
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: head/devel/gdb/files/kgdb/ppcfbsd-kern.c 431323 2017-01-12 21:40:06Z olivier $");
+
+#include <sys/types.h>
+#ifdef __powerpc__
+#include <machine/pcb.h>
+#include <machine/frame.h>
+#endif
+#include <string.h>
+
+#include <defs.h>
+#include <frame-unwind.h>
+#include "gdbcore.h"
+#include "osabi.h"
+#include "regcache.h"
+#include "solib.h"
+#include "symtab.h"
+#include "trad-frame.h"
+
+#include <ppc-tdep.h>
+#include "ppc64-tdep.h"
+
+#include "kgdb.h"
+
+#ifdef __powerpc__
+static void
+ppcfbsd_supply_pcb(struct regcache *regcache, CORE_ADDR pcb_addr)
+{
+	struct pcb pcb;
+	struct gdbarch_tdep *tdep;
+	int i;
+
+	tdep = gdbarch_tdep (target_gdbarch());
+
+	if (target_read_memory(pcb_addr, (gdb_byte *)&pcb, sizeof(pcb)) != 0)
+		memset(&pcb, 0, sizeof(pcb));
+
+	/*
+	 * r14-r31 are saved in the pcb
+	 */
+	for (i = 14; i <= 31; i++) {
+		regcache_raw_supply(regcache, tdep->ppc_gp0_regnum + i,
+		    (char *)&pcb.pcb_context[i]);
+	}
+
+	/* r1 is saved in the sp field */
+	regcache_raw_supply(regcache, tdep->ppc_gp0_regnum + 1,
+			    (char *)&pcb.pcb_sp);
+	if (tdep->wordsize == 8)
+	  /* r2 is saved in the toc field */
+	  regcache_raw_supply(regcache, tdep->ppc_gp0_regnum + 2,
+			      (char *)&pcb.pcb_toc);
+
+	regcache_raw_supply(regcache, tdep->ppc_lr_regnum, (char *)&pcb.pcb_lr);
+	regcache_raw_supply(regcache, tdep->ppc_cr_regnum, (char *)&pcb.pcb_cr);
+}
+#endif
+
+#define	OFF_FIXREG	0
+#define	OFF_LR		32
+#define	OFF_CR		33
+#define	OFF_XER		34
+#define	OFF_CTR		35
+#define	OFF_SRR0	36
+#define	TRAPFRAME_SIZE	42
+
+#ifdef __powerpc__
+_Static_assert(sizeof(struct trapframe) == TRAPFRAME_SIZE * sizeof(register_t),
+	       "trapframe size");
+_Static_assert(offsetof(struct trapframe, fixreg)
+	       == OFF_FIXREG * sizeof(register_t), "fixreg offset");
+_Static_assert(offsetof(struct trapframe, lr) == OFF_LR * sizeof(register_t),
+	       "lr offset");
+_Static_assert(offsetof(struct trapframe, cr) == OFF_CR * sizeof(register_t),
+	       "cr offset");
+_Static_assert(offsetof(struct trapframe, xer) == OFF_XER * sizeof(register_t),
+	       "xer offset");
+_Static_assert(offsetof(struct trapframe, ctr) == OFF_CTR * sizeof(register_t),
+	       "ctr offset");
+_Static_assert(offsetof(struct trapframe, srr0)
+	       == OFF_SRR0 * sizeof(register_t), "srr0 offset");
+#endif
+
+static struct trad_frame_cache *
+ppcfbsd_trapframe_cache (struct frame_info *this_frame, void **this_cache)
+{
+  struct gdbarch *gdbarch = get_frame_arch (this_frame);
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+  struct trad_frame_cache *cache;
+  CORE_ADDR base;
+  int i, regnum;
+
+  if (*this_cache)
+    return (struct trad_frame_cache *)*this_cache;
+
+  cache = trad_frame_cache_zalloc (this_frame);
+  *this_cache = cache;
+
+  base = get_frame_register_unsigned (this_frame, gdbarch_sp_regnum (gdbarch));
+  if (tdep->wordsize == 8)
+    base += 48;
+  else
+    base += 8;
+
+  for (i = 0; i < ppc_num_gprs; i++)
+    trad_frame_set_reg_addr (cache, tdep->ppc_gp0_regnum + i, base
+			     + (OFF_FIXREG + i) * tdep->wordsize);
+  trad_frame_set_reg_addr (cache, tdep->ppc_lr_regnum, base
+			   + OFF_LR * tdep->wordsize);
+  trad_frame_set_reg_addr (cache, tdep->ppc_cr_regnum, base
+			   + OFF_CR * tdep->wordsize);
+  trad_frame_set_reg_addr (cache, tdep->ppc_xer_regnum, base
+			   + OFF_XER * tdep->wordsize);
+  trad_frame_set_reg_addr (cache, tdep->ppc_ctr_regnum, base
+			   + OFF_CTR * tdep->wordsize);
+  /* SRR0?  */
+  trad_frame_set_reg_addr (cache, gdbarch_pc_regnum (gdbarch), base
+			   + OFF_SRR0 * tdep->wordsize);
+
+  /* Construct the frame ID using the function start.  */
+  trad_frame_set_id (cache, frame_id_build (base, get_frame_func (this_frame)));
+  
+  return cache;
+}
+
+static void
+ppcfbsd_trapframe_this_id (struct frame_info *this_frame,
+			       void **this_cache, struct frame_id *this_id)
+{
+  struct trad_frame_cache *cache =
+    ppcfbsd_trapframe_cache (this_frame, this_cache);
+
+  trad_frame_get_id (cache, this_id);
+}
+
+static struct value *
+ppcfbsd_trapframe_prev_register (struct frame_info *this_frame,
+				     void **this_cache, int regnum)
+{
+  struct trad_frame_cache *cache =
+    ppcfbsd_trapframe_cache (this_frame, this_cache);
+
+  return trad_frame_get_register (cache, this_frame, regnum);
+}
+
+static int
+ppcfbsd_trapframe_sniffer (const struct frame_unwind *self,
+			       struct frame_info *this_frame,
+			       void **this_cache)
+{
+  CORE_ADDR pc;
+  const char *name;
+
+  pc = get_frame_func (this_frame);
+  find_pc_partial_function (pc, &name, NULL, NULL);
+  if (name && (strcmp(name, "asttrapexit") == 0
+	       || strcmp(name, "trapexit") == 0))
+    return 1;
+
+  return 0;
+}
+
+static const struct frame_unwind ppcfbsd_trapframe_unwind =
+{
+  SIGTRAMP_FRAME,
+  default_frame_unwind_stop_reason,
+  ppcfbsd_trapframe_this_id,
+  ppcfbsd_trapframe_prev_register,
+  NULL,
+  ppcfbsd_trapframe_sniffer
+};
+
+static void
+ppcfbsd_kernel_init_abi(struct gdbarch_info info, struct gdbarch *gdbarch)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  frame_unwind_prepend_unwinder(gdbarch, &ppcfbsd_trapframe_unwind);
+
+  set_solib_ops(gdbarch, &kld_so_ops);
+
+#ifdef __powerpc__
+  if (tdep->wordsize == sizeof(register_t))
+    {
+      fbsd_vmcore_set_supply_pcb(gdbarch, ppcfbsd_supply_pcb);
+      fbsd_vmcore_set_cpu_pcb_addr(gdbarch, kgdb_trgt_stop_pcb);
+    }
+#endif
+
+  /* FreeBSD doesn't support the 128-bit `long double' from the psABI.  */
+  set_gdbarch_long_double_bit (gdbarch, 64);
+  set_gdbarch_long_double_format (gdbarch, floatformats_ieee_double);
+
+  if (tdep->wordsize == 4)
+    {
+      set_gdbarch_return_value (gdbarch, ppc_sysv_abi_broken_return_value);
+    }
+
+  if (tdep->wordsize == 8)
+    {
+      set_gdbarch_convert_from_func_ptr_addr
+	(gdbarch, ppc64_convert_from_func_ptr_addr);
+      set_gdbarch_elf_make_msymbol_special (gdbarch,
+					    ppc64_elf_make_msymbol_special);
+    }
+}
+
+void _initialize_ppc_kgdb_tdep(void);
+
+void
+_initialize_ppc_kgdb_tdep(void)
+{
+	gdbarch_register_osabi_sniffer(bfd_arch_powerpc,
+				       bfd_target_elf_flavour,
+				       fbsd_kernel_osabi_sniffer);
+	gdbarch_register_osabi (bfd_arch_powerpc, bfd_mach_ppc,
+	    GDB_OSABI_FREEBSD_ELF_KERNEL, ppcfbsd_kernel_init_abi);
+	gdbarch_register_osabi (bfd_arch_powerpc, bfd_mach_ppc64,
+	    GDB_OSABI_FREEBSD_ELF_KERNEL, ppcfbsd_kernel_init_abi);
+
+	/* Not sure about this one. */
+	gdbarch_register_osabi_sniffer(bfd_arch_rs6000,
+				       bfd_target_elf_flavour,
+				       fbsd_kernel_osabi_sniffer);
+	gdbarch_register_osabi (bfd_arch_rs6000, 0,
+	    GDB_OSABI_FREEBSD_ELF_KERNEL, ppcfbsd_kernel_init_abi);
+}
diff --git a/devel/gdb-good/files/kgdb/sparc64fbsd-kern.c b/devel/gdb-good/files/kgdb/sparc64fbsd-kern.c
new file mode 100644
index 00000000000..303dbc62d9e
--- /dev/null
+++ b/devel/gdb-good/files/kgdb/sparc64fbsd-kern.c
@@ -0,0 +1,319 @@
+/*
+ * Copyright (c) 2004 Marcel Moolenaar
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD: head/devel/gdb/files/kgdb/sparc64fbsd-kern.c 431323 2017-01-12 21:40:06Z olivier $");
+
+#include <sys/types.h>
+#ifdef __sparc64__
+#include <machine/asm.h>
+#include <machine/pcb.h>
+#include <machine/frame.h>
+#endif
+#include <string.h>
+
+#include <defs.h>
+#include "gdbcore.h"
+#include "osabi.h"
+#include "regcache.h"
+#include <target.h>
+#include <frame-unwind.h>
+#include "solib.h"
+#include "trad-frame.h"
+
+#include <sparc-tdep.h>
+#include <sparc64-tdep.h>
+
+#include "kgdb.h"
+
+#ifdef __sparc64__
+static void
+sparc64fbsd_supply_pcb(struct regcache *regcache, CORE_ADDR pcb_addr)
+{
+	struct pcb pcb;
+
+	if (target_read_memory(pcb_addr, (gdb_byte *)&pcb, sizeof(pcb)) != 0)
+		memset(&pcb, 0, sizeof(pcb));
+
+	regcache_raw_supply(regcache, SPARC_SP_REGNUM, (char *)&pcb.pcb_sp);
+	sparc_supply_rwindow(regcache, pcb.pcb_sp, -1);
+	regcache_raw_supply(regcache, SPARC64_PC_REGNUM, (char *)&pcb.pcb_pc);
+	pcb.pcb_pc += 4;
+	regcache_raw_supply(regcache, SPARC64_NPC_REGNUM, (char *)&pcb.pcb_pc);
+}
+#endif
+
+#define	OFF_TF_SP	(14 * 8)
+#define	OFF_TF_TPC	(25 * 8)
+#define	OFF_TF_TNPC	(24 * 8)
+#define	OFF_TF_OUT	(8 * 8)
+#define	TRAPFRAME_SIZE	(32 * 8)
+
+#ifdef __sparc64__
+_Static_assert(sizeof(struct trapframe) == TRAPFRAME_SIZE, "trapframe size");
+_Static_assert(offsetof(struct trapframe, tf_sp) == OFF_TF_SP, "tf_sp offset");
+_Static_assert(offsetof(struct trapframe, tf_tpc) == OFF_TF_TPC,
+	       "tf_tpc offset");
+_Static_assert(offsetof(struct trapframe, tf_tnpc) == OFF_TF_TNPC,
+	       "tf_tnpc offset");
+_Static_assert(offsetof(struct trapframe, tf_out) == OFF_TF_OUT,
+	       "tf_out offset");
+#endif
+
+static struct sparc_frame_cache *
+sparc64fbsd_trapframe_cache (struct frame_info *this_frame, void **this_cache)
+{
+  struct sparc_frame_cache *cache;
+  CORE_ADDR fp, sp, trapframe_addr;
+  int regnum;
+
+  if (*this_cache)
+    return (struct sparc_frame_cache *)*this_cache;
+
+  cache = sparc_frame_cache (this_frame, this_cache);
+  gdb_assert (cache == *this_cache);
+
+  fp = get_frame_register_unsigned (this_frame, SPARC_FP_REGNUM);
+  trapframe_addr = fp + BIAS - TRAPFRAME_SIZE;
+  sp = get_frame_register_unsigned (this_frame, SPARC_SP_REGNUM);
+
+  cache->saved_regs = trad_frame_alloc_saved_regs (this_frame);
+
+  cache->saved_regs[SPARC_SP_REGNUM].addr = trapframe_addr + OFF_TF_SP;
+#ifdef notyet
+  cache->saved_regs[SPARC64_STATE_REGNUM].addr = trapframe_addr + OFF_TF_TSTATE;
+#endif
+  cache->saved_regs[SPARC64_PC_REGNUM].addr = trapframe_addr + OFF_TF_TPC;
+  cache->saved_regs[SPARC64_NPC_REGNUM].addr = trapframe_addr + OFF_TF_TNPC;
+  for (regnum = SPARC_O0_REGNUM; regnum <= SPARC_O7_REGNUM; regnum++)
+    cache->saved_regs[regnum].addr =
+      trapframe_addr + OFF_TF_OUT + (regnum - SPARC_O0_REGNUM) * 8;
+  for (regnum = SPARC_L0_REGNUM; regnum <= SPARC_I7_REGNUM; regnum++)
+    cache->saved_regs[regnum].addr =
+      sp + BIAS + (regnum - SPARC_L0_REGNUM) * 8;
+
+  return cache;
+}
+
+static void
+sparc64fbsd_trapframe_this_id (struct frame_info *this_frame,
+			       void **this_cache, struct frame_id *this_id)
+{
+  struct sparc_frame_cache *cache =
+    sparc64fbsd_trapframe_cache (this_frame, this_cache);
+
+  (*this_id) = frame_id_build (cache->base, cache->pc);
+}
+
+static struct value *
+sparc64fbsd_trapframe_prev_register (struct frame_info *this_frame,
+				     void **this_cache, int regnum)
+{
+  struct sparc_frame_cache *cache =
+    sparc64fbsd_trapframe_cache (this_frame, this_cache);
+
+  return trad_frame_get_prev_register (this_frame, cache->saved_regs, regnum);
+}
+
+static int
+sparc64fbsd_trapframe_sniffer (const struct frame_unwind *self,
+			       struct frame_info *this_frame,
+			       void **this_cache)
+{
+  CORE_ADDR pc;
+  const char *name;
+
+  pc = get_frame_address_in_block (this_frame);
+  find_pc_partial_function (pc, &name, NULL, NULL);
+  if (name && (strcmp(name, "tl0_intr") == 0
+	       || strcmp(name, "tl0_trap") == 0
+	       || strcmp(name, "tl1_intr") == 0
+	       || strcmp(name, "tl1_trap") == 0))
+    return 1;
+
+  return 0;
+}
+
+static const struct frame_unwind sparc64fbsd_trapframe_unwind =
+{
+  SIGTRAMP_FRAME,
+  default_frame_unwind_stop_reason,
+  sparc64fbsd_trapframe_this_id,
+  sparc64fbsd_trapframe_prev_register,
+  NULL,
+  sparc64fbsd_trapframe_sniffer
+};
+
+#if 0
+struct kgdb_frame_cache {
+	CORE_ADDR	pc;
+	CORE_ADDR	sp;
+	CORE_ADDR	fp;
+};
+
+static struct kgdb_frame_cache *
+kgdb_trgt_frame_cache(struct frame_info *next_frame, void **this_cache)
+{
+	char buf[MAX_REGISTER_SIZE];
+	struct kgdb_frame_cache *cache;
+
+	cache = *this_cache;
+	if (cache == NULL) {
+		cache = FRAME_OBSTACK_ZALLOC(struct kgdb_frame_cache);
+		*this_cache = cache;
+		cache->pc = frame_func_unwind(next_frame);
+		frame_unwind_register(next_frame, SPARC_SP_REGNUM, buf);
+		cache->sp = extract_unsigned_integer(buf,
+		    register_size(current_gdbarch, SPARC_SP_REGNUM));
+		frame_unwind_register(next_frame, SPARC_FP_REGNUM, buf);
+		cache->fp = extract_unsigned_integer(buf,
+		    register_size(current_gdbarch, SPARC_FP_REGNUM));
+		cache->fp += BIAS - sizeof(struct trapframe);
+	}
+	return (cache);
+}
+
+static void
+kgdb_trgt_trapframe_this_id(struct frame_info *next_frame, void **this_cache,
+    struct frame_id *this_id)
+{
+	struct kgdb_frame_cache *cache;
+
+	cache = kgdb_trgt_frame_cache(next_frame, this_cache);
+	*this_id = frame_id_build(cache->sp, cache->pc);
+}
+
+static void
+kgdb_trgt_trapframe_prev_register(struct frame_info *next_frame,
+    void **this_cache, int regnum, int *optimizedp, enum lval_type *lvalp,
+    CORE_ADDR *addrp, int *realnump, void *valuep)
+{
+	char dummy_valuep[MAX_REGISTER_SIZE];
+	struct kgdb_frame_cache *cache;
+	int ofs, regsz;
+
+	regsz = register_size(current_gdbarch, regnum);
+
+	if (valuep == NULL)
+		valuep = dummy_valuep;
+	memset(valuep, 0, regsz);
+	*optimizedp = 0;
+	*addrp = 0;
+	*lvalp = not_lval;
+	*realnump = -1;
+
+	cache = kgdb_trgt_frame_cache(next_frame, this_cache);
+
+	switch (regnum) {
+	case SPARC_SP_REGNUM:
+		ofs = offsetof(struct trapframe, tf_sp);
+		break;
+	case SPARC64_PC_REGNUM:
+		ofs = offsetof(struct trapframe, tf_tpc);
+		break;
+	case SPARC64_NPC_REGNUM:
+		ofs = offsetof(struct trapframe, tf_tnpc);
+		break;
+	case SPARC_O0_REGNUM:
+	case SPARC_O1_REGNUM:
+	case SPARC_O2_REGNUM:
+	case SPARC_O3_REGNUM:
+	case SPARC_O4_REGNUM:
+	case SPARC_O5_REGNUM:
+	case SPARC_O7_REGNUM:
+		ofs = offsetof(struct trapframe, tf_out) +
+		    (regnum - SPARC_O0_REGNUM) * 8;
+		break;
+	default:
+		if (regnum >= SPARC_L0_REGNUM && regnum <= SPARC_I7_REGNUM) {
+			ofs = (regnum - SPARC_L0_REGNUM) * 8;
+			*addrp = cache->sp + BIAS + ofs;
+			*lvalp = lval_memory;
+			target_read_memory(*addrp, (gdb_byte *)valuep, regsz);
+		}
+		return;
+	}
+
+	*addrp = cache->fp + ofs;
+	*lvalp = lval_memory;
+	target_read_memory(*addrp, (gdb_byte *)valuep, regsz);
+}
+
+static const struct frame_unwind kgdb_trgt_trapframe_unwind = {
+        UNKNOWN_FRAME,
+        &kgdb_trgt_trapframe_this_id,
+        &kgdb_trgt_trapframe_prev_register
+};
+
+const struct frame_unwind *
+kgdb_trgt_trapframe_sniffer(struct frame_info *next_frame)
+{
+	char *pname;
+	CORE_ADDR pc;
+
+	pc = frame_func_unwind(next_frame);
+	pname = NULL;
+	find_pc_partial_function(pc, &pname, NULL, NULL);
+	if (pname == NULL)
+		return (NULL);
+	if (strcmp(pname, "tl0_intr") == 0 ||
+	    strcmp(pname, "tl0_trap") == 0 ||
+	    strcmp(pname, "tl1_intr") == 0 ||
+	    strcmp(pname, "tl1_trap") == 0)
+		return (&kgdb_trgt_trapframe_unwind);
+	/* printf("%s: %lx =%s\n", __func__, pc, pname); */
+	return (NULL);
+}
+#endif
+
+static void
+sparc64fbsd_kernel_init_abi(struct gdbarch_info info, struct gdbarch *gdbarch)
+{
+
+	sparc64_init_abi(info, gdbarch);
+
+	frame_unwind_prepend_unwinder(gdbarch, &sparc64fbsd_trapframe_unwind);
+
+	set_solib_ops(gdbarch, &kld_so_ops);
+
+#ifdef __sparc64__
+	fbsd_vmcore_set_supply_pcb(gdbarch, sparc64fbsd_supply_pcb);
+	fbsd_vmcore_set_cpu_pcb_addr(gdbarch, kgdb_trgt_stop_pcb);
+#endif
+}
+
+void _initialize_sparc64_kgdb_tdep(void);
+
+void
+_initialize_sparc64_kgdb_tdep(void)
+{
+	gdbarch_register_osabi_sniffer(bfd_arch_sparc,
+				       bfd_target_elf_flavour,
+				       fbsd_kernel_osabi_sniffer);
+	gdbarch_register_osabi (bfd_arch_sparc, bfd_mach_sparc_v9,
+	    GDB_OSABI_FREEBSD_ELF_KERNEL, sparc64fbsd_kernel_init_abi);
+}
+
diff --git a/devel/gdb-good/files/patch-armfbsd b/devel/gdb-good/files/patch-armfbsd
new file mode 100644
index 00000000000..4223d2da085
--- /dev/null
+++ b/devel/gdb-good/files/patch-armfbsd
@@ -0,0 +1,367 @@
+diff --git gdb/armfbsd-nat.c gdb/armfbsd-nat.c
+new file mode 100644
+index 0000000..b883411
+--- /dev/null
++++ gdb/armfbsd-nat.c
+@@ -0,0 +1,215 @@
++/* Native-dependent code for BSD Unix running on ARM's, for GDB.
++
++   Copyright (C) 1988-2015 Free Software Foundation, Inc.
++
++   This file is part of GDB.
++
++   This program is free software; you can redistribute it and/or modify
++   it under the terms of the GNU General Public License as published by
++   the Free Software Foundation; either version 3 of the License, or
++   (at your option) any later version.
++
++   This program is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++   GNU General Public License for more details.
++
++   You should have received a copy of the GNU General Public License
++   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
++
++#include "defs.h"
++#include "gdbcore.h"
++#include "inferior.h"
++#include "regcache.h"
++#include "target.h"
++#include "gregset.h"
++#include <sys/types.h>
++#include <sys/ptrace.h>
++#include <machine/reg.h>
++#include <machine/frame.h>
++
++#include "fbsd-nat.h"
++#include "arm-tdep.h"
++#include "inf-ptrace.h"
++
++extern int arm_apcs_32;
++
++static pid_t
++ptrace_pid (ptid_t ptid)
++{
++  pid_t pid;
++
++#ifdef __FreeBSD__
++  pid = ptid_get_lwp (ptid);
++  if (pid == 0)
++#endif
++    pid = ptid_get_pid (ptid);
++  return pid;
++}
++
++static void
++arm_supply_gregset (struct regcache *regcache, const gregset_t *gregset, int regnum)
++{
++  int r;
++  CORE_ADDR r_pc;
++
++  /* Integer registers.  */
++  for (r = ARM_A1_REGNUM; r < ARM_SP_REGNUM; r++)
++    if ((r == regnum) || (regnum == -1))
++      regcache_raw_supply (regcache, r, (char *) &gregset->r[r]);
++
++  if ((regnum == ARM_SP_REGNUM) || (regnum == -1))
++    regcache_raw_supply (regcache, ARM_SP_REGNUM,
++		       (char *) &gregset->r_sp);
++  if ((regnum == ARM_LR_REGNUM) || (regnum == -1))
++    regcache_raw_supply (regcache, ARM_LR_REGNUM,
++		       (char *) &gregset->r_lr);
++  /* This is ok: we're running native...  */
++  if ((regnum == ARM_PC_REGNUM) || (regnum == -1))
++    {
++      r_pc = gdbarch_addr_bits_remove (get_regcache_arch (regcache), gregset->r_pc);
++      regcache_raw_supply (regcache, ARM_PC_REGNUM, (char *) &r_pc);
++    }
++
++  if ((regnum == ARM_PS_REGNUM) || (regnum == -1))
++    {
++      if (arm_apcs_32)
++        regcache_raw_supply (regcache, ARM_PS_REGNUM,
++			 (char *) &gregset->r_cpsr);
++      else
++        regcache_raw_supply (regcache, ARM_PS_REGNUM,
++			 (char *) &gregset->r_pc);
++    }
++}
++
++static void
++armbsd_collect_gregset (const struct regcache *regcache, gregset_t *gregset, int regnum)
++{
++  int ret;
++  int r;
++
++  for (r = ARM_A1_REGNUM; r < ARM_SP_REGNUM; r++)
++    if ((regnum == r) || (regnum == -1))
++      regcache_raw_collect (regcache, r,
++			  (char *) &gregset->r[r]);
++
++  if ((regnum == ARM_SP_REGNUM) || (regnum == -1))
++    regcache_raw_collect (regcache, ARM_SP_REGNUM,
++			(char *) &gregset->r_sp);
++  if ((regnum == ARM_LR_REGNUM) || (regnum == -1))
++    regcache_raw_collect (regcache, ARM_LR_REGNUM,
++			(char *) &gregset->r_lr);
++
++
++  if ((regnum == ARM_PC_REGNUM) || (regnum == -1))
++    regcache_raw_collect (regcache, ARM_PC_REGNUM,
++			(char *) &gregset->r_pc);
++  if ((regnum == ARM_PS_REGNUM) || (regnum == -1))
++    {
++      if (arm_apcs_32)
++        {
++          regcache_raw_collect (regcache, ARM_PS_REGNUM,
++			    (char *) &gregset->r_cpsr);
++        }
++      else
++        {
++          unsigned psr_val;
++
++          regcache_raw_collect (regcache, ARM_PS_REGNUM,
++			   (char *) &psr_val);
++
++          psr_val ^= gdbarch_addr_bits_remove (get_regcache_arch (regcache), psr_val);
++          gregset->r_pc = gdbarch_addr_bits_remove
++    			   (get_regcache_arch (regcache), gregset->r_pc);
++          gregset->r_pc |= psr_val;
++        }
++    }
++}
++
++/* Fill GDB's register array with the general-purpose register values
++   in *GREGSETP.  */
++
++void
++supply_gregset (struct regcache *regcache, const gregset_t *gregsetp)
++{
++  arm_supply_gregset (regcache, gregsetp, -1);
++}
++
++/* Fill register REGNUM (if it is a general-purpose register) in
++   *GREGSETPS with the value in GDB's register array.  If REGNUM is -1,
++   do this for all registers.  */
++
++void
++fill_gregset (const struct regcache *regcache, gdb_gregset_t *gregsetp, int regnum)
++{
++  armbsd_collect_gregset (regcache, gregsetp, regnum);
++}
++
++/* Fill GDB's register array with the floating-point register values
++   in *FPREGSETP.  */
++
++void
++supply_fpregset (struct regcache *regcache, const fpregset_t *fpregsetp)
++{
++}
++
++/* Fill register REGNUM (if it is a floating-point register) in
++   *FPREGSETP with the value in GDB's register array.  If REGNUM is -1,
++   do this for all registers.  */
++
++void
++fill_fpregset (const struct regcache *regcache, gdb_fpregset_t *fpregsetp, int regnum)
++{
++}
++
++/* Fetch register REGNO from the child process. If REGNO is -1, do it
++   for all registers.  */
++
++static void
++armfbsd_fetch_inferior_registers (struct target_ops *ops,
++				  struct regcache *regcache, int regno)
++{
++  gdb_gregset_t regs;
++
++  if (ptrace (PT_GETREGS, ptrace_pid (inferior_ptid),
++	      (PTRACE_TYPE_ARG3) &regs, 0) == -1)
++    perror_with_name (_("Couldn't get registers"));
++
++  arm_supply_gregset (regcache, &regs, regno);
++  /* TODO: fpregs */
++}
++
++/* Store register REGNO back into the child process. If REGNO is -1,
++   do this for all registers.  */
++
++static void
++armfbsd_store_inferior_registers (struct target_ops *ops,
++				  struct regcache *regcache, int regno)
++{
++  gdb_gregset_t regs;
++
++  if (ptrace (PT_GETREGS, ptrace_pid (inferior_ptid),
++	      (PTRACE_TYPE_ARG3) &regs, 0) == -1)
++    perror_with_name (_("Couldn't get registers"));
++
++  fill_gregset (regcache, &regs, regno);
++
++  if (ptrace (PT_SETREGS, ptrace_pid (inferior_ptid),
++	      (PTRACE_TYPE_ARG3) &regs, 0) == -1)
++    perror_with_name (_("Couldn't write registers"));
++  /* TODO: FP regs */
++}
++
++void _initialize_armfbsd_nat (void);
++
++void
++_initialize_armfbsd_nat (void)
++{
++  struct target_ops *t;
++
++  /* Add in local overrides.  */
++  t = inf_ptrace_target ();
++  t->to_fetch_registers = armfbsd_fetch_inferior_registers;
++  t->to_store_registers = armfbsd_store_inferior_registers;
++  fbsd_nat_add_target (t);
++}
+diff --git gdb/armfbsd-tdep.c gdb/armfbsd-tdep.c
+new file mode 100644
+index 0000000..f58c323
+--- /dev/null
++++ gdb/armfbsd-tdep.c
+@@ -0,0 +1,109 @@
++/* Target-dependent code for PowerPC systems running FreeBSD.
++
++   Copyright (C) 2013-2015 Free Software Foundation, Inc.
++
++   This file is part of GDB.
++
++   This program is free software; you can redistribute it and/or modify
++   it under the terms of the GNU General Public License as published by
++   the Free Software Foundation; either version 3 of the License, or
++   (at your option) any later version.
++
++   This program is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++   GNU General Public License for more details.
++
++   You should have received a copy of the GNU General Public License
++   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
++
++#include "defs.h"
++#include "arch-utils.h"
++#include "frame.h"
++#include "gdbcore.h"
++#include "frame-unwind.h"
++#include "gdbtypes.h"
++#include "osabi.h"
++#include "regcache.h"
++#include "regset.h"
++#include "symtab.h"
++#include "target.h"
++#include "trad-frame.h"
++
++#include "arm-tdep.h"
++#include "solib-svr4.h"
++
++/* Description of the longjmp buffer.  */
++#define ARM_FBSD_JB_PC 24
++#define ARM_FBSD_JB_ELEMENT_SIZE INT_REGISTER_SIZE
++
++/* For compatibility with previous implemenations of GDB on arm/FreeBSD,
++   override the default little-endian breakpoint.  */
++static const gdb_byte arm_fbsd_arm_le_breakpoint[] = {0x11, 0x00, 0x00, 0xe6};
++static const gdb_byte arm_fbsd_arm_be_breakpoint[] = {0xe6, 0x00, 0x00, 0x11};
++static const gdb_byte arm_fbsd_thumb_le_breakpoint[] = {0xfe, 0xde};
++static const gdb_byte arm_fbsd_thumb_be_breakpoint[] = {0xde, 0xfe};
++
++static void
++arm_freebsd_init_abi_common (struct gdbarch_info info,
++			    struct gdbarch *gdbarch)
++{
++  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
++
++  tdep->lowest_pc = 0x8000;
++  switch (info.byte_order)
++    {
++    case BFD_ENDIAN_LITTLE:
++      tdep->arm_breakpoint = arm_fbsd_arm_le_breakpoint;
++      tdep->thumb_breakpoint = arm_fbsd_thumb_le_breakpoint;
++      tdep->arm_breakpoint_size = sizeof (arm_fbsd_arm_le_breakpoint);
++      tdep->thumb_breakpoint_size = sizeof (arm_fbsd_thumb_le_breakpoint);
++      break;
++
++    case BFD_ENDIAN_BIG:
++      tdep->arm_breakpoint = arm_fbsd_arm_be_breakpoint;
++      tdep->thumb_breakpoint = arm_fbsd_thumb_be_breakpoint;
++      tdep->arm_breakpoint_size = sizeof (arm_fbsd_arm_be_breakpoint);
++      tdep->thumb_breakpoint_size = sizeof (arm_fbsd_thumb_be_breakpoint);
++      break;
++
++    default:
++      internal_error (__FILE__, __LINE__,
++		      _("arm_gdbarch_init: bad byte order for float format"));
++    }
++
++  tdep->jb_pc = ARM_FBSD_JB_PC;
++  tdep->jb_elt_size = ARM_FBSD_JB_ELEMENT_SIZE;
++
++  /* Single stepping.  */
++  set_gdbarch_software_single_step (gdbarch, arm_software_single_step);
++}
++
++static void
++arm_freebsd_elf_init_abi (struct gdbarch_info info,
++			 struct gdbarch *gdbarch)
++{
++  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
++
++  arm_freebsd_init_abi_common (info, gdbarch);
++  if (tdep->fp_model == ARM_FLOAT_AUTO)
++    tdep->fp_model = ARM_FLOAT_SOFT_VFP;
++
++  /* NetBSD ELF uses SVR4-style shared libraries.  */
++  set_solib_svr4_fetch_link_map_offsets
++    (gdbarch, svr4_ilp32_fetch_link_map_offsets);
++}
++
++
++
++/* Provide a prototype to silence -Wmissing-prototypes.  */
++
++void _initialize_armfbsd_tdep (void);
++
++void
++_initialize_armfbsd_tdep (void)
++{
++
++  gdbarch_register_osabi (bfd_arch_arm, 0, GDB_OSABI_FREEBSD_ELF,
++                          arm_freebsd_elf_init_abi);
++}
+diff --git gdb/config/arm/fbsd.mh gdb/config/arm/fbsd.mh
+new file mode 100644
+index 0000000..0a2d8b1
+--- /dev/null
++++ gdb/config/arm/fbsd.mh
+@@ -0,0 +1,3 @@
++# Host: FreeBSD/arm
++NATDEPFILES= armfbsd-nat.o fbsd-nat.o fork-child.o inf-ptrace.o
++HAVE_NATIVE_GCORE_HOST = 1
+diff --git gdb/Makefile.in gdb/Makefile.in
+index dfaa8a3..ddad28d 100644
+--- gdb/Makefile.in
++++ gdb/Makefile.in
+@@ -659,7 +659,7 @@
+ ALL_TARGET_OBS = \
+ 	armbsd-tdep.o arm.o arm-linux.o arm-linux-tdep.o \
+ 	arm-get-next-pcs.o arm-symbian-tdep.o \
+-	armnbsd-tdep.o armobsd-tdep.o \
++	armnbsd-tdep.o armobsd-tdep.o armfbsd-tdep.o \
+ 	arm-tdep.o arm-wince-tdep.o \
+ 	avr-tdep.o \
+ 	bfin-linux-tdep.o bfin-tdep.o \
+@@ -1666,7 +1666,7 @@
+ 	arm.c arm-get-next-pcs.c \
+ 	arm-linux.c arm-linux-nat.c arm-linux-tdep.c \
+ 	arm-symbian-tdep.c arm-tdep.c \
+-	armnbsd-nat.c armbsd-tdep.c armnbsd-tdep.c armobsd-tdep.c \
++	armnbsd-nat.c armbsd-tdep.c armnbsd-tdep.c armobsd-tdep.c armfbsd-tdep.c \
+ 	avr-tdep.c \
+ 	bfin-linux-tdep.c bfin-tdep.c \
+ 	bsd-uthread.c bsd-kvm.c \
diff --git a/devel/gdb-good/files/patch-fixes b/devel/gdb-good/files/patch-fixes
new file mode 100644
index 00000000000..06805c24c2f
--- /dev/null
+++ b/devel/gdb-good/files/patch-fixes
@@ -0,0 +1,11 @@
+--- gdb/compile/compile-loc2c.c.orig	2016-07-05 12:30:44.811467295 +0200
++++ gdb/compile/compile-loc2c.c	2016-07-05 12:38:46.432434206 +0200
+@@ -670,7 +670,7 @@
+       enum dwarf_location_atom op = (enum dwarf_location_atom) *op_ptr;
+       uint64_t uoffset, reg;
+       int64_t offset;
+-
++      uoffset = 0;
+       print_spaces (indent - 2, stream);
+       if (info[op_ptr - base].label)
+ 	{
diff --git a/devel/gdb-good/files/patch-gdb-amd64bsd-nat.c b/devel/gdb-good/files/patch-gdb-amd64bsd-nat.c
new file mode 100644
index 00000000000..7787a495e69
--- /dev/null
+++ b/devel/gdb-good/files/patch-gdb-amd64bsd-nat.c
@@ -0,0 +1,37 @@
+--- gdb/amd64bsd-nat.c.orig	2016-02-10 04:19:39.000000000 +0100
++++ gdb/amd64bsd-nat.c	2016-03-04 11:17:58.581638025 +0100
+@@ -28,6 +28,7 @@
+ #include <sys/types.h>
+ #include <sys/ptrace.h>
+ #include <machine/reg.h>
++#include <machine/psl.h>
+ 
+ #include "amd64-tdep.h"
+ #include "amd64-nat.h"
+@@ -98,14 +99,25 @@
+ 
+   if (regnum == -1 || amd64_native_gregset_supplies_p (gdbarch, regnum))
+     {
+-      struct reg regs;
++      struct reg regs, oldregs;
+ 
++      memset( &regs, 0, sizeof(struct reg));
++      memset( &oldregs, 0, sizeof(struct reg));
+       if (ptrace (PT_GETREGS, get_ptrace_pid (inferior_ptid),
+                   (PTRACE_TYPE_ARG3) &regs, 0) == -1)
+         perror_with_name (_("Couldn't get registers"));
+ 
++      ptrace (PT_GETREGS, get_ptrace_pid (inferior_ptid),
++		  (PTRACE_TYPE_ARG3) &oldregs, 0);
+       amd64_collect_native_gregset (regcache, &regs, regnum);
+ 
++      if( (regs.r_rflags ^ oldregs.r_rflags ) & ~PSL_USERCHANGE)
++        {
++          //printf("regs.r_rflags = 0x%8.8lX\n", regs.r_rflags );
++          //printf("oldregs.r_rflags = 0x%8.8lX\n", oldregs.r_rflags );
++          regs.r_rflags ^= (regs.r_rflags ^ oldregs.r_rflags ) & ~PSL_USERCHANGE;
++          //printf("    allowed regs.r_rflags = 0x%8.8X\n", regs.r_rflags );
++        }
+       if (ptrace (PT_SETREGS, get_ptrace_pid (inferior_ptid),
+ 	          (PTRACE_TYPE_ARG3) &regs, 0) == -1)
+         perror_with_name (_("Couldn't write registers"));
diff --git a/devel/gdb-good/files/patch-gdb-configure b/devel/gdb-good/files/patch-gdb-configure
new file mode 100644
index 00000000000..959ce76e272
--- /dev/null
+++ b/devel/gdb-good/files/patch-gdb-configure
@@ -0,0 +1,24 @@
+--- gdb/configure.orig	2016-10-07 19:09:21.000000000 +0200
++++ gdb/configure	2016-10-18 11:11:30.452542000 +0200
+@@ -14256,9 +14256,8 @@
+ 
+ # These options work in either C or C++ modes.
+ build_warnings="-Wall -Wpointer-arith \
+--Wno-unused -Wunused-value -Wunused-function \
+--Wno-switch -Wno-char-subscripts \
+--Wempty-body -Wunused-but-set-parameter -Wunused-but-set-variable"
++-Wno-unused -Wno-switch -Wno-char-subscripts \
++-Wempty-body"
+ 
+ # Now add in C and C++ specific options, depending on mode.
+ if test "$enable_build_with_cxx" = "yes"; then
+@@ -14266,8 +14265,7 @@
+ -Wno-narrowing"
+ else
+    build_warnings="$build_warnings -Wpointer-sign -Wmissing-prototypes \
+--Wdeclaration-after-statement -Wmissing-parameter-type \
+--Wold-style-declaration -Wold-style-definition"
++-Wdeclaration-after-statement -Wold-style-definition"
+ fi
+ 
+ # Enable -Wno-format by default when using gcc on mingw since many
diff --git a/devel/gdb-good/files/patch-gdb-configure.host b/devel/gdb-good/files/patch-gdb-configure.host
new file mode 100644
index 00000000000..98f4a60b3f3
--- /dev/null
+++ b/devel/gdb-good/files/patch-gdb-configure.host
@@ -0,0 +1,12 @@
+diff --git gdb/configure.host gdb/configure.host
+index 48714f4..53989d3 100644
+--- gdb/configure.host
++++ gdb/configure.host
+@@ -90,6 +90,7 @@ alpha*-*-netbsd* | alpha*-*-knetbsd*-gnu)
+ 			gdb_host=nbsd ;;
+ alpha*-*-openbsd*)	gdb_host=nbsd ;;
+ 
++arm*-*-freebsd*)	gdb_host=fbsd ;;
+ arm*-*-linux*)		gdb_host=linux ;;
+ arm*-*-netbsdelf* | arm*-*-knetbsd*-gnu)
+ 			gdb_host=nbsdelf ;;
diff --git a/devel/gdb-good/files/patch-gdb-corelow.c b/devel/gdb-good/files/patch-gdb-corelow.c
new file mode 100644
index 00000000000..18ef23cc843
--- /dev/null
+++ b/devel/gdb-good/files/patch-gdb-corelow.c
@@ -0,0 +1,12 @@
+--- gdb/corelow.c.orig	2017-01-16 10:40:23.118428000 +0100
++++ gdb/corelow.c	2017-01-17 22:39:10.524216000 +0100
+@@ -541,7 +541,8 @@
+       warning (_("Section `%s' in core file too small."), section_name);
+       return;
+     }
+-  if (size != min_size && !(regset->flags & REGSET_VARIABLE_SIZE))
++  if (size != min_size && regset != NULL &&
++	!(regset->flags & REGSET_VARIABLE_SIZE))
+     {
+       warning (_("Unexpected size of section `%s' in core file."),
+ 	       section_name);
diff --git a/devel/gdb-good/files/patch-gdb-fbsd-nat.c b/devel/gdb-good/files/patch-gdb-fbsd-nat.c
new file mode 100644
index 00000000000..4b0915a7a11
--- /dev/null
+++ b/devel/gdb-good/files/patch-gdb-fbsd-nat.c
@@ -0,0 +1,27 @@
+--- gdb/fbsd-nat.c.orig	2016-08-01 17:50:20.000000000 +0200
++++ gdb/fbsd-nat.c	2016-12-14 23:23:39.467449000 +0100
+@@ -680,6 +680,9 @@
+   if (!ptid_match (tp->ptid, *filter))
+     return 0;
+ 
++  if (tp->state == THREAD_EXITED) {
++    return 0;
++  }
+   if (ptrace (PT_RESUME, ptid_get_lwp (tp->ptid), NULL, 0) == -1)
+     perror_with_name (("ptrace"));
+   return 0;
+@@ -710,6 +713,14 @@
+ 			ptid_get_tid (ptid));
+   if (ptid_lwp_p (ptid))
+     {
++#ifndef PT_LWP_EVENTS
++      /* When LWP events are not supported, a new thread might already be
++	 running that has not yet reported an event when GDB wishes to
++         only run a single thread.  Force an update of the thread list
++	 to ensure that any such threads are suspended before the process
++	 is resumed.  */
++      fbsd_add_threads (ptid_get_pid (ptid));
++#endif
+       /* If ptid is a specific LWP, suspend all other LWPs in the process.  */
+       iterate_over_threads (resume_one_thread_cb, &ptid);
+     }
diff --git a/devel/gdb-good/files/patch-gdb-gdb_wchar.h b/devel/gdb-good/files/patch-gdb-gdb_wchar.h
new file mode 100644
index 00000000000..0123294af91
--- /dev/null
+++ b/devel/gdb-good/files/patch-gdb-gdb_wchar.h
@@ -0,0 +1,22 @@
+diff --git gdb/gdb_wchar.h gdb/gdb_wchar.h
+index 868fe04..1311080 100644
+--- gdb/gdb_wchar.h
++++ gdb/gdb_wchar.h
+@@ -59,7 +59,7 @@
+    iconvlist.  */
+ #if defined (HAVE_ICONV) && defined (HAVE_BTOWC) \
+   && (defined (__STDC_ISO_10646__) \
+-      || (defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108))
++      || (!defined (LIBICONV_PLUG) && defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108))
+ 
+ typedef wchar_t gdb_wchar_t;
+ typedef wint_t gdb_wint_t;
+@@ -82,7 +82,7 @@ typedef wint_t gdb_wint_t;
+ #define INTERMEDIATE_ENCODING intermediate_encoding ()
+ const char *intermediate_encoding (void);
+ 
+-#elif defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108
++#elif !defined (LIBICONV_PLUG) && defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108
+ #define INTERMEDIATE_ENCODING "wchar_t"
+ #else
+ /* This shouldn't happen, because the earlier #if should have filtered
diff --git a/devel/gdb-good/files/patch-gdb-gnulib-import-stddef.in.h b/devel/gdb-good/files/patch-gdb-gnulib-import-stddef.in.h
new file mode 100644
index 00000000000..8b9ad7d9d7e
--- /dev/null
+++ b/devel/gdb-good/files/patch-gdb-gnulib-import-stddef.in.h
@@ -0,0 +1,11 @@
+--- gdb/gnulib/import/stddef.in.h.orig	2016-10-07 23:33:10.529558000 -0700
++++ gdb/gnulib/import/stddef.in.h	2016-10-07 23:33:23.824676000 -0700
+@@ -82,7 +82,7 @@
+ #endif
+ 
+ /* Some platforms lack max_align_t.  */
+-#if !@HAVE_MAX_ALIGN_T@
++#if 0
+ /* On the x86, the maximum storage alignment of double, long, etc. is 4,
+    but GCC's C11 ABI for x86 says that max_align_t has an alignment of 8,
+    and the C11 standard allows this.  Work around this problem by
diff --git a/devel/gdb-good/files/patch-gdb-i386fbsd-nat.c b/devel/gdb-good/files/patch-gdb-i386fbsd-nat.c
new file mode 100644
index 00000000000..13ee2c191e3
--- /dev/null
+++ b/devel/gdb-good/files/patch-gdb-i386fbsd-nat.c
@@ -0,0 +1,11 @@
+diff --git gdb/i386fbsd-nat.c gdb/i386fbsd-nat.c
+index 6c43f2c..a205a26 100644
+--- gdb/i386fbsd-nat.c
++++ gdb/i386fbsd-nat.c
+@@ -175,7 +175,6 @@ _initialize_i386fbsd_nat (void)
+   t->to_read_description = i386fbsd_read_description;
+ #endif
+ 
+-  t->to_resume = i386fbsd_resume;
+   fbsd_nat_add_target (t);
+   /* Support debugging kernel virtual memory images.  */
diff --git a/devel/gdb-good/files/patch-gdb-python-python-config.py b/devel/gdb-good/files/patch-gdb-python-python-config.py
new file mode 100644
index 00000000000..815b31dedaf
--- /dev/null
+++ b/devel/gdb-good/files/patch-gdb-python-python-config.py
@@ -0,0 +1,13 @@
+diff --git gdb/python/python-config.py gdb/python/python-config.py
+index c2b2969..39af8d9 100644
+--- gdb/python/python-config.py
++++ gdb/python/python-config.py
+@@ -59,6 +59,8 @@ for opt in opt_flags:
+ 
+     elif opt in ('--libs', '--ldflags'):
+         libs = []
++        if getvar('LDFLAGS') is not None:
++            libs.extend(getvar('LDFLAGS').split())
+         if getvar('LIBS') is not None:
+             libs.extend(getvar('LIBS').split())
+         if getvar('SYSLIBS') is not None:
diff --git a/devel/gdb-good/files/patch-gdb-x86bsd-nat.c b/devel/gdb-good/files/patch-gdb-x86bsd-nat.c
new file mode 100644
index 00000000000..07cbea6df87
--- /dev/null
+++ b/devel/gdb-good/files/patch-gdb-x86bsd-nat.c
@@ -0,0 +1,14 @@
+--- gdb/x86bsd-nat.c.orig	2016-10-18 13:27:55.820837000 +0200
++++ gdb/x86bsd-nat.c	2016-10-18 13:29:02.518927000 +0200
+@@ -82,7 +82,11 @@
+   /* For some mysterious reason, some of the reserved bits in the
+      debug control register get set.  Mask these off, otherwise the
+      ptrace call below will fail.  */
++#ifdef __i386__
++  DBREG_DRX ((&dbregs), 7) &= ~(0x0000fc00);
++#else
+   DBREG_DRX ((&dbregs), 7) &= ~(0xffffffff0000fc00);
++#endif 
+ 
+   DBREG_DRX ((&dbregs), regnum) = value;
+ 
diff --git a/devel/gdb-good/files/patch-libiberty-basename b/devel/gdb-good/files/patch-libiberty-basename
new file mode 100644
index 00000000000..8d37ee89850
--- /dev/null
+++ b/devel/gdb-good/files/patch-libiberty-basename
@@ -0,0 +1,11 @@
+--- include/libiberty.h
++++ include/libiberty.h
+@@ -109,7 +109,7 @@
+  || defined (__FreeBSD__) || defined (__OpenBSD__) || defined (__NetBSD__) \
+  || defined (__CYGWIN__) || defined (__CYGWIN32__) || defined (__MINGW32__) \
+  || defined (__DragonFly__) || defined (HAVE_DECL_BASENAME) 
+-extern char *basename (const char *) ATTRIBUTE_RETURNS_NONNULL ATTRIBUTE_NONNULL(1);
++#include <libgen.h>
+ #else
+ /* Do not allow basename to be used if there is no prototype seen.  We
+    either need to use the above prototype or have one from
diff --git a/devel/gdb-good/files/patch-nowarning b/devel/gdb-good/files/patch-nowarning
new file mode 100644
index 00000000000..69570bbac43
--- /dev/null
+++ b/devel/gdb-good/files/patch-nowarning
@@ -0,0 +1,65 @@
+--- gdb/arm-tdep.c.orig	2016-07-08 15:42:17.131392993 +0200
++++ gdb/arm-tdep.c	2016-07-08 15:44:10.506386463 +0200
+@@ -9880,7 +9880,7 @@
+       && !INSN_RECORDED(arm_insn_r))
+     {
+       /* Handle MLA(S) and MUL(S).  */
+-      if (0 <= insn_op1 && 3 >= insn_op1)
++      if (3 >= insn_op1)
+       {
+         record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);
+         record_buf[1] = ARM_PS_REGNUM;
+--- gdb/cris-tdep.c.orig	2016-07-08 15:45:26.575379589 +0200
++++ gdb/cris-tdep.c	2016-07-08 15:47:07.849372792 +0200
+@@ -1441,7 +1441,7 @@
+       /* Indeterminate/obsolete.  */
+       return 0;
+     case cris_ver_v0_3:
+-      return (version >= 0 && version <= 3);
++      return (version <= 3);
+     case cris_ver_v3p:
+       return (version >= 3);
+     case cris_ver_v8:
+@@ -1449,7 +1449,7 @@
+     case cris_ver_v8p:
+       return (version >= 8);
+     case cris_ver_v0_10:
+-      return (version >= 0 && version <= 10);
++      return (version <= 10);
+     case cris_ver_v3_10:
+       return (version >= 3 && version <= 10);
+     case cris_ver_v8_10:
+--- gdb/main.c.orig	2016-08-03 17:55:42.243017327 +0200
++++ gdb/main.c	2016-08-03 17:56:04.478015630 +0200
+@@ -226,7 +226,7 @@
+ 	    {
+ 	      /* Append the part of SYSTEM_GDBINIT that follows GDB_DATADIR
+ 		 to gdb_datadir.  */
+-	      char *tmp_sys_gdbinit = xstrdup (SYSTEM_GDBINIT + datadir_len);
++	      char *tmp_sys_gdbinit = xstrdup (&(SYSTEM_GDBINIT[datadir_len]));
+ 	      char *p;
+ 
+ 	      for (p = tmp_sys_gdbinit; IS_DIR_SEPARATOR (*p); ++p)
+--- gdb/dtrace-probe.c.orig	2016-08-03 17:57:18.454010903 +0200
++++ gdb/dtrace-probe.c	2016-08-03 17:58:01.001007519 +0200
+@@ -421,7 +421,8 @@
+ 	  arg.type_str = xstrdup (p);
+ 
+ 	  /* Use strtab_size as a sentinel.  */
+-	  while (*p++ != '\0' && p - strtab < strtab_size);
++	  while (*p++ != '\0' && p - strtab < strtab_size)
++		;
+ 
+ 	  /* Try to parse a type expression from the type string.  If
+ 	     this does not work then we set the type to `long
+--- libiberty/stack-limit.c.orig	2016-08-05 14:12:21.942893014 +0200
++++ libiberty/stack-limit.c	2016-08-05 14:12:58.794890125 +0200
+@@ -51,7 +51,7 @@
+   struct rlimit rlim;
+   if (getrlimit (RLIMIT_STACK, &rlim) == 0
+       && rlim.rlim_cur != RLIM_INFINITY
+-      && rlim.rlim_cur < pref
++      && rlim.rlim_cur < (rlim_t)pref
+       && (rlim.rlim_max == RLIM_INFINITY || rlim.rlim_cur < rlim.rlim_max))
+     {
+       rlim.rlim_cur = pref;
diff --git a/devel/gdb-good/files/patch-unified b/devel/gdb-good/files/patch-unified
new file mode 100644
index 00000000000..771636669ff
--- /dev/null
+++ b/devel/gdb-good/files/patch-unified
@@ -0,0 +1,18 @@
+diff --git gdb/gdb.c gdb/gdb.c
+index e554015..dcb9925 100644
+--- gdb/gdb.c
++++ gdb/gdb.c
+@@ -28,6 +28,12 @@ main (int argc, char **argv)
+   memset (&args, 0, sizeof args);
+   args.argc = argc;
+   args.argv = argv;
+-  args.interpreter_p = INTERP_CONSOLE;
++  if (strncmp(basename(argv[0]), "insight", 7) == 0) {
++    args.interpreter_p = "insight";
++  } else if (strncmp(basename(argv[0]), "gdbtui", 6) == 0) {
++    args.interpreter_p = INTERP_TUI;
++  } else {
++    args.interpreter_p = INTERP_CONSOLE;
++  }
+   return gdb_main (&args);
+ }
diff --git a/devel/gdb-good/pkg-descr b/devel/gdb-good/pkg-descr
new file mode 100644
index 00000000000..3a1015f8909
--- /dev/null
+++ b/devel/gdb-good/pkg-descr
@@ -0,0 +1,6 @@
+GDB is a source-level debugger for Ada, C, C++, Objective-C, Pascal and
+many other languages.  GDB can target (i.e., debug programs running on)
+more than a dozen different processor architectures, and GDB itself can
+run on most popular GNU/Linux, Unix and Microsoft Windows variants.
+
+WWW: http://www.gnu.org/software/gdb/
diff --git a/devel/gdb-good/pkg-plist b/devel/gdb-good/pkg-plist
new file mode 100644
index 00000000000..7e5e43588bb
--- /dev/null
+++ b/devel/gdb-good/pkg-plist
@@ -0,0 +1,22 @@
+%%GDB_LINK%%bin/gdb
+%%GDB_LINK%%%%KGDB%%bin/kgdb
+bin/gdb%%VER%%
+%%TUI%%bin/gdbtui%%VER%%
+%%KGDB%%bin/kgdb%%VER%%
+man/man1/gdb%%VER%%.1.gz
+%%KGDB%%man/man1/kgdb%%VER%%.1.gz
+%%EXPAT%%%%DATADIR%%%%VER%%/syscalls/aarch64-linux.xml
+%%EXPAT%%%%DATADIR%%%%VER%%/syscalls/amd64-linux.xml
+%%EXPAT%%%%DATADIR%%%%VER%%/syscalls/arm-linux.xml
+%%EXPAT%%%%DATADIR%%%%VER%%/syscalls/freebsd.xml
+%%EXPAT%%%%DATADIR%%%%VER%%/syscalls/gdb-syscalls.dtd
+%%EXPAT%%%%DATADIR%%%%VER%%/syscalls/i386-linux.xml
+%%EXPAT%%%%DATADIR%%%%VER%%/syscalls/mips-n32-linux.xml
+%%EXPAT%%%%DATADIR%%%%VER%%/syscalls/mips-n64-linux.xml
+%%EXPAT%%%%DATADIR%%%%VER%%/syscalls/mips-o32-linux.xml
+%%EXPAT%%%%DATADIR%%%%VER%%/syscalls/ppc-linux.xml
+%%EXPAT%%%%DATADIR%%%%VER%%/syscalls/ppc64-linux.xml
+%%EXPAT%%%%DATADIR%%%%VER%%/syscalls/s390-linux.xml
+%%EXPAT%%%%DATADIR%%%%VER%%/syscalls/s390x-linux.xml
+%%EXPAT%%%%DATADIR%%%%VER%%/syscalls/sparc-linux.xml
+%%EXPAT%%%%DATADIR%%%%VER%%/syscalls/sparc64-linux.xml
