From 4955ff38a219e8b5f7e67cd4191331699e249537 Mon Sep 17 00:00:00 2001
From: zrj <rimvydas.jasinskas@gmail.com>
Date: Tue, 27 Aug 2019 22:38:29 +0300
Subject: [PATCH 62/66] world: Reimplement pthread types using non polluting
 types.

 Use __ implementation specific namespace. However to avoid huge
 "s/struct TYPE/struct __TYPE/g" in threading libraries sources add the
 _DFLY_LIB_NAMESPACE to indicate that <sys/_pthreadtypes.h> are for
 internal libc/pthreads libraries codes.  Even if this would get set
 by anything else in userland including DPorts, it would mean that
 opaque structs would be named differently.  This however have slight
 impact in libstc++.so symbol manglings (should be fine on nonthreaded).
 * The pthread_addr_t type is specific only to libc_r, define it in
   libc_r/uthread/pthread_private.h internally.
 * The pthread_startroutine_t typedef was never used since initial fork.
 * The mutext member in struct pthread_once is for libc_r only.
 * Mangle struct names using __type_s scheme to avoid collisions with
   user defined types in 3rd-party software packages.
 * Adjust partly publicly visibile struct pthread_once members too.

 While there, adjust visibility for spinlock/rwlock pthread functions.
---
 include/pthread.h                    |   4 +
 lib/libc/gen/_once_stub.c            |   4 +-
 lib/libc/gen/_pthread_stubs.c        |   4 +-
 lib/libc/include/namespace.h         |   5 +
 lib/libc_r/uthread/pthread_private.h |   1 +
 lib/libc_r/uthread/uthread_once.c    |  10 +-
 lib/libthread_xu/thread/thr_once.c   |  12 +--
 sys/sys/_pthreadtypes.h              | 131 ++++++++++++++-------------
 8 files changed, 93 insertions(+), 78 deletions(-)

diff --git a/include/pthread.h b/include/pthread.h
index 8504c29192..9ddea758d3 100644
--- a/include/pthread.h
+++ b/include/pthread.h
@@ -220,6 +220,7 @@ int	pthread_mutex_unlock(pthread_mutex_t *);
 
 int	pthread_once(pthread_once_t *, void (*) (void)) __nonnull(1);
 
+#if __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE
 int	pthread_rwlock_destroy(pthread_rwlock_t *);
 int	pthread_rwlock_init(pthread_rwlock_t * __restrict,
 	    const pthread_rwlockattr_t * __restrict) __nonnull(1);
@@ -238,15 +239,18 @@ int	pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * __restrict,
 	    int * __restrict) __nonnull(1, 2);
 int	pthread_rwlockattr_init(pthread_rwlockattr_t *);
 int	pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int) __nonnull(1);
+#endif
 
 pthread_t	pthread_self(void);
 int	pthread_setspecific(pthread_key_t, const void *);
 
+#if __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE >= 600
 int	pthread_spin_destroy(pthread_spinlock_t *);
 int	pthread_spin_init(pthread_spinlock_t *, int);
 int	pthread_spin_lock(pthread_spinlock_t *);
 int	pthread_spin_trylock(pthread_spinlock_t *);
 int	pthread_spin_unlock(pthread_spinlock_t *);
+#endif
 
 int	pthread_cancel(pthread_t);
 int	pthread_setcancelstate(int, int *);
diff --git a/lib/libc/gen/_once_stub.c b/lib/libc/gen/_once_stub.c
index 4efbafd2d2..9a8a41789a 100644
--- a/lib/libc/gen/_once_stub.c
+++ b/lib/libc/gen/_once_stub.c
@@ -38,10 +38,10 @@ static int
 _libc_once(pthread_once_t *once_control, void (*init_routine)(void))
 {
 
-	if (once_control->state == PTHREAD_DONE_INIT)
+	if (once_control->__state == PTHREAD_DONE_INIT)
 		return (0);
 	init_routine();
-	once_control->state = PTHREAD_DONE_INIT;
+	once_control->__state = PTHREAD_DONE_INIT;
 	return (0);
 }
 
diff --git a/lib/libc/gen/_pthread_stubs.c b/lib/libc/gen/_pthread_stubs.c
index 04aa58123e..e17d9a6da7 100644
--- a/lib/libc/gen/_pthread_stubs.c
+++ b/lib/libc/gen/_pthread_stubs.c
@@ -191,9 +191,9 @@ stub_zero(void)
 static int __used
 stub_once(pthread_once_t *o, void (*r)(void))
 {
-	if (o->state != PTHREAD_DONE_INIT) {
+	if (o->__state != PTHREAD_DONE_INIT) {
 		(*r)();
-		o->state = PTHREAD_DONE_INIT;
+		o->__state = PTHREAD_DONE_INIT;
 	}
 
 	return (0);
diff --git a/lib/libc/include/namespace.h b/lib/libc/include/namespace.h
index 28d41ad172..2975dfd10d 100644
--- a/lib/libc/include/namespace.h
+++ b/lib/libc/include/namespace.h
@@ -44,6 +44,11 @@
 #define		warn				_warn
 #define		nsdispatch			_nsdispatch
 
+/*
+ * Hint that internal names and types are used.  Do not undef.
+ */
+#define _DFLY_LIB_NAMESPACE
+
 /*
  * Prototypes for syscalls/functions that need to be overridden
  * in libc_r/libpthread.
diff --git a/lib/libc_r/uthread/pthread_private.h b/lib/libc_r/uthread/pthread_private.h
index 1e9048080d..ae5cf47f25 100644
--- a/lib/libc_r/uthread/pthread_private.h
+++ b/lib/libc_r/uthread/pthread_private.h
@@ -458,6 +458,7 @@ struct pthread_attr {
 		tv.tv_usec = _sched_tod.tv_usec;	\
 	} while (tv.tv_sec != _sched_tod.tv_sec)
 
+typedef void	*pthread_addr_t;
 
 struct pthread_key {
 	spinlock_t	lock;
diff --git a/lib/libc_r/uthread/uthread_once.c b/lib/libc_r/uthread/uthread_once.c
index 3e85da3f52..645d62a914 100644
--- a/lib/libc_r/uthread/uthread_once.c
+++ b/lib/libc_r/uthread/uthread_once.c
@@ -40,15 +40,15 @@
 int
 _pthread_once(pthread_once_t * once_control, void (*init_routine) (void))
 {
-	if (once_control->state == PTHREAD_NEEDS_INIT) {
+	if (once_control->__state == PTHREAD_NEEDS_INIT) {
 		if (_thread_initial == NULL)
 			_thread_init();
-		_pthread_mutex_lock(&(once_control->mutex));
-		if (once_control->state == PTHREAD_NEEDS_INIT) {
+		_pthread_mutex_lock(&(once_control->__mutex));
+		if (once_control->__state == PTHREAD_NEEDS_INIT) {
 			init_routine();
-			once_control->state = PTHREAD_DONE_INIT;
+			once_control->__state = PTHREAD_DONE_INIT;
 		}
-		_pthread_mutex_unlock(&(once_control->mutex));
+		_pthread_mutex_unlock(&(once_control->__mutex));
 	}
 	return (0);
 }
diff --git a/lib/libthread_xu/thread/thr_once.c b/lib/libthread_xu/thread/thr_once.c
index ef172f3f0a..df90d5f38f 100644
--- a/lib/libthread_xu/thread/thr_once.c
+++ b/lib/libthread_xu/thread/thr_once.c
@@ -51,7 +51,7 @@ once_cancel_handler(void *arg)
 	pthread_once_t *once_control = arg;
 
 	_pthread_mutex_lock(&once_lock);
-	once_control->state = ONCE_NEVER_DONE;
+	once_control->__state = ONCE_NEVER_DONE;
 	_pthread_mutex_unlock(&once_lock);
 	_pthread_cond_broadcast(&once_cv);
 }
@@ -61,23 +61,23 @@ _pthread_once(pthread_once_t *once_control, void (*init_routine) (void))
 {
 	int wakeup = 0;
 
-	if (once_control->state == ONCE_DONE)
+	if (once_control->__state == ONCE_DONE)
 		return (0);
 	_pthread_mutex_lock(&once_lock);
-	while (*(volatile int *)&(once_control->state) == ONCE_IN_PROGRESS)
+	while (*(volatile int *)&(once_control->__state) == ONCE_IN_PROGRESS)
 		_pthread_cond_wait(&once_cv, &once_lock);
 	/*
 	 * If previous thread was canceled, then the state still
 	 * could be ONCE_NEVER_DONE, we need to check it again.
 	 */
-	if (*(volatile int *)&(once_control->state) == ONCE_NEVER_DONE) {
-		once_control->state = ONCE_IN_PROGRESS;
+	if (*(volatile int *)&(once_control->__state) == ONCE_NEVER_DONE) {
+		once_control->__state = ONCE_IN_PROGRESS;
 		_pthread_mutex_unlock(&once_lock);
 		_pthread_cleanup_push(once_cancel_handler, once_control);
 		init_routine();
 		_pthread_cleanup_pop(0);
 		_pthread_mutex_lock(&once_lock);
-		once_control->state = ONCE_DONE;
+		once_control->__state = ONCE_DONE;
 		wakeup = 1;
 	}
 	_pthread_mutex_unlock(&once_lock);
diff --git a/sys/sys/_pthreadtypes.h b/sys/sys/_pthreadtypes.h
index 9e8cf3841e..8d11ed1b38 100644
--- a/sys/sys/_pthreadtypes.h
+++ b/sys/sys/_pthreadtypes.h
@@ -1,7 +1,5 @@
 /*
- * Copyright (c) 1993, 1994 by Chris Provenzano, proven@mit.edu
- * Copyright (c) 1995-1998 by John Birrell <jb@cimlogic.com.au>
- * All rights reserved.
+ * Copyright (c) 2019 The DragonFly Project.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -11,83 +9,90 @@
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    This product includes software developed by Chris Provenzano.
- * 4. The name of Chris Provenzano may not be used to endorse or promote
- *    products derived from this software without specific prior written
- *    permission.
  *
- * THIS SOFTWARE IS PROVIDED BY CHRIS PROVENZANO ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL CHRIS PROVENZANO BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  */
 
 #ifndef _SYS__PTHREADTYPES_H_
 #define _SYS__PTHREADTYPES_H_
 
+#include <sys/cdefs.h>
+
 /*
- * Forward structure definitions.
- *
- * These are mostly opaque to the user.
+ * Namespace for internal pthread library implementations.  Variations
+ * for pthread_cond_attr and pthread_mutex_attr are historical.
+ * Mangling for struct __pthread_once_s is done on purpose.
  */
-struct pthread;
-struct pthread_attr;
-struct pthread_cond;
-struct pthread_cond_attr;
-struct pthread_mutex;
-struct pthread_mutex_attr;
-struct pthread_once;
-struct pthread_rwlock;
-struct pthread_rwlockattr;
-struct pthread_barrier;
-struct pthread_barrier_attr;
-struct pthread_spinlock;
+#if defined(_NAMESPACE_H_) && defined(_DFLY_LIB_NAMESPACE)
+#define __pthread_s		pthread
+#define __pthread_attr_s	pthread_attr
+#define __pthread_barrier_s	pthread_barrier
+#define __pthread_barrierattr_s	pthread_barrierattr
+#define __pthread_cond_s	pthread_cond
+#define __pthread_condattr_s	pthread_cond_attr
+#define __pthread_mutex_s	pthread_mutex
+#define __pthread_mutexattr_s	pthread_mutex_attr
+#define __pthread_rwlock_s	pthread_rwlock
+#define __pthread_rwlockattr_s	pthread_rwlockattr
+#define __pthread_spinlock_s	pthread_spinlock
+#endif
 
 /*
- * Primitive system data type definitions required by P1003.1c.
- *
- * Note that P1003.1c specifies that there are no defined comparison
- * or assignment operators for the types pthread_attr_t, pthread_cond_t,
- * pthread_condattr_t, pthread_mutex_t, pthread_mutexattr_t.
+ * Forward opaque structure definitions that do not pollute namespaces.
+ * To be used in headers where visibility is an issue.
  */
-typedef struct	pthread			*pthread_t;
-typedef struct	pthread_attr		*pthread_attr_t;
-typedef struct	pthread_mutex		*pthread_mutex_t;
-typedef struct	pthread_mutex_attr	*pthread_mutexattr_t;
-typedef struct	pthread_cond		*pthread_cond_t;
-typedef struct	pthread_cond_attr	*pthread_condattr_t;
-typedef int				pthread_key_t;
-typedef struct	pthread_once		pthread_once_t;
-typedef struct	pthread_rwlock		*pthread_rwlock_t;
-typedef struct	pthread_rwlockattr	*pthread_rwlockattr_t;
-typedef struct	pthread_barrier		*pthread_barrier_t;
-typedef struct	pthread_barrierattr	*pthread_barrierattr_t;
-typedef struct	pthread_spinlock	*pthread_spinlock_t;
+struct __pthread_s;
+struct __pthread_attr_s;
+struct __pthread_barrier_s;
+struct __pthread_barrierattr_s;
+struct __pthread_cond_s;
+struct __pthread_condattr_s;
+struct __pthread_mutex_s;
+struct __pthread_mutexattr_s;
+struct __pthread_once_s;
+struct __pthread_rwlock_s;
+struct __pthread_rwlockattr_s;
+struct __pthread_spinlock_s;
 
 /*
- * Additional type definitions:
- *
- * Note that P1003.1c reserves the prefixes pthread_ and PTHREAD_ for
- * use in header symbols.
+ * Basic types to be used in function prototypes.
  */
-typedef void    *pthread_addr_t;
-typedef void    *(*pthread_startroutine_t) (void *);
+typedef struct	__pthread_s		*pthread_t;
+typedef struct	__pthread_attr_s	*pthread_attr_t;
+typedef struct	__pthread_barrier_s	*pthread_barrier_t;
+typedef struct	__pthread_barrierattr_s	*pthread_barrierattr_t;
+typedef struct	__pthread_cond_s	*pthread_cond_t;
+typedef struct	__pthread_condattr_s	*pthread_condattr_t;
+typedef struct	__pthread_mutex_s	*pthread_mutex_t;
+typedef struct	__pthread_mutexattr_s	*pthread_mutexattr_t;
+typedef int				pthread_key_t;
+typedef struct	__pthread_once_s	pthread_once_t;
+
+#if __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE
+typedef struct	__pthread_rwlock_s	*pthread_rwlock_t;
+typedef struct	__pthread_rwlockattr_s	*pthread_rwlockattr_t;
+#endif
+#if __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE >= 600
+typedef struct	__pthread_spinlock_s	*pthread_spinlock_t;
+#endif
 
 /*
- * Once definitions.
+ * Once-only structure (partly public).
  */
-struct pthread_once {
-	int		state;
-	pthread_mutex_t	mutex;
+struct __pthread_once_s {
+	int		__state;
+	pthread_mutex_t	__mutex;
 };
 
-#endif /* ! _SYS__PTHREADTYPES_H_ */
+#endif	/* ! _SYS__PTHREADTYPES_H_ */
-- 
2.22.0

