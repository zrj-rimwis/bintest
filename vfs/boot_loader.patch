diff --git a/lib/libstand/Makefile b/lib/libstand/Makefile
index 8aef675588..903676f9a6 100644
--- a/lib/libstand/Makefile
+++ b/lib/libstand/Makefile
@@ -70,6 +70,10 @@ qdivrem.o:	qdivrem.c
 	${CC} ${CFLAGS:N-flto} -c -o ${.TARGET} ${.IMPSRC}
 .endif
 
+# uuid functions from libc
+.PATH: ${LIBSTAND_SRC}/../libc/uuid
+SRCS+= uuid_equal.c uuid_is_nil.c
+
 # _setjmp/_longjmp
 .PATH:	${LIBSTAND_SRC}/${LIBSTAND_ARCH}
 .if ${LIBSTAND_ARCH} == "x86_64" || ${LIBSTAND_ARCH} == "i386"
diff --git a/sys/boot/pc32/libi386/Makefile b/sys/boot/pc32/libi386/Makefile
index 64a4124351..c5ed73474c 100644
--- a/sys/boot/pc32/libi386/Makefile
+++ b/sys/boot/pc32/libi386/Makefile
@@ -24,6 +24,10 @@ CFLAGS+=	-DCOMSPEED=${BOOT_COMCONSOLE_SPEED}
 CFLAGS+= -DDISK_DEBUG
 .endif
 
+.if !defined(LOADER_NO_GPT_SUPPORT)
+CFLAGS+=	-DLOADER_GPT_SUPPORT
+.endif
+
 # Include simple terminal emulation (cons25-compatible)
 CFLAGS+= -DTERM_EMU
 
diff --git a/sys/boot/pc32/libi386/biosdisk.c b/sys/boot/pc32/libi386/biosdisk.c
index d84db8cf77..ba9d5ac0b9 100644
--- a/sys/boot/pc32/libi386/biosdisk.c
+++ b/sys/boot/pc32/libi386/biosdisk.c
@@ -28,7 +28,7 @@
 
 /*
  * BIOS disk device handling.
- * 
+ *
  * Ideas and algorithms from:
  *
  * - NetBSD libi386/biosdisk.c
@@ -37,15 +37,18 @@
  */
 
 #include <stand.h>
+#include <stddef.h>
 
 #include <sys/disklabel32.h>
 #include <sys/disklabel64.h>
 #include <sys/diskmbr.h>
+#include <sys/gpt.h>
 #include <sys/dtype.h>
 #include <machine/bootinfo.h>
 #include <machine/psl.h>
 
 #include <stdarg.h>
+#include <uuid.h>
 
 #include <bootstrap.h>
 #include <btxv86.h>
@@ -68,13 +71,22 @@
 # define DEBUG(fmt, args...)
 #endif
 
+#ifdef LOADER_GPT_SUPPORT
+struct gpt_part {
+    int		gp_index;
+    uuid_t	gp_type;
+    uint64_t	gp_start;
+    uint64_t	gp_end;
+};
+#endif
+
 struct open_disk {
     int			od_dkunit;		/* disk unit number */
     int			od_unit;		/* BIOS unit number */
     int			od_cyl;			/* BIOS geometry */
     int			od_hds;
     int			od_sec;
-    int			od_boff;		/* block offset from beginning of BIOS disk */
+    daddr_t		od_boff;		/* block offset from beginning of BIOS disk */
     int			od_flags;
 #define BD_MODEINT13		0x0000
 #define BD_MODEEDD1		0x0001
@@ -83,14 +95,34 @@ struct open_disk {
 #define BD_FLOPPY		0x0004
 #define BD_LABELOK		0x0008
 #define BD_PARTTABOK		0x0010
+#ifdef LOADER_GPT_SUPPORT
+#define	BD_GPTOK		0x0020
+#endif
     union {
-	struct disklabel32		od_disklabel;
-	struct disklabel64		od_disklabel64;
-    };
-    int				od_nslices;	/* slice count */
-    struct dos_partition	od_slicetab[NEXTDOSPART];
+	struct {
+	    struct disklabel32		mbr_disklabel;
+	    struct disklabel64		mbr_disklabel64;
+	    int				mbr_nslices;	/* slice count */
+	    struct dos_partition	mbr_slicetab[NEXTDOSPART];
+	} _mbr;
+#ifdef LOADER_GPT_SUPPORT
+	struct {
+	    int				gpt_nparts;
+	    struct gpt_part		*gpt_partitions;
+	} _gpt;
+#endif
+    } _data;
 };
 
+#define	od_disklabel		_data._mbr.mbr_disklabel
+#define	od_disklabel64		_data._mbr.mbr_disklabel64
+#define	od_nslices		_data._mbr.mbr_nslices
+#define	od_slicetab		_data._mbr.mbr_slicetab
+#ifdef LOADER_GPT_SUPPORT
+#define	od_nparts		_data._gpt.gpt_nparts
+#define	od_partitions		_data._gpt.gpt_partitions
+#endif
+
 /*
  * List of BIOS devices, translation from disk unit number to
  * BIOS unit number.
@@ -111,6 +143,11 @@ static int	bd_write(struct open_disk *od, daddr_t dblk, int blks,
 
 static int	bd_int13probe(struct bdinfo *bd);
 
+#ifdef LOADER_GPT_SUPPORT
+static void	bd_printgptpart(struct open_disk *od, struct gpt_part *gp,
+		    char *prefix, int verbose);
+#endif
+
 static void	bd_printslice(struct open_disk *od, struct dos_partition *dp,
 		    char *prefix, int verbose);
 static void	bd_printbsdslice(struct open_disk *od, daddr_t offset,
@@ -139,9 +176,13 @@ struct devsw biosdisk = {
 
 static int	bd_opendisk(struct open_disk **odp, struct i386_devdesc *dev);
 static void	bd_closedisk(struct open_disk *od);
+static int	bd_open_mbr(struct open_disk *od, struct i386_devdesc *dev);
 static int	bd_bestslice(struct open_disk *od);
-static void	bd_chainextended(struct open_disk *od, u_int32_t base,
-					u_int32_t offset);
+static void	bd_checkextended(struct open_disk *od, int slicenum);
+#ifdef LOADER_GPT_SUPPORT
+static int	bd_open_gpt(struct open_disk *od, struct i386_devdesc *dev);
+static struct gpt_part *bd_best_gptpart(struct open_disk *od);
+#endif
 
 char	bounce_base[BOUNCEBUF_SIZE];	/* also used by CD code */
 
@@ -182,10 +223,12 @@ bd_init(void)
     /* sequence 0, 0x80 */
     for (base = 0; base <= 0x80; base += 0x80) {
 	for (unit = base; (nbdinfo < MAXBDDEV); unit++) {
+#ifndef VIRTUALBOX
 	    /* check the BIOS equipment list for number of fixed disks */
 	    if((base == 0x80) &&
 	       (nfd >= *(unsigned char *)PTOV(BIOS_NUMDRIVES)))
 	        break;
+#endif
 
 	    bdinfo[nbdinfo].bd_unit = unit;
 	    bdinfo[nbdinfo].bd_flags = (unit < 0x80) ? BD_FLOPPY : 0;
@@ -224,7 +267,7 @@ bd_int13probe(struct bdinfo *bd)
 	 */
 	if ((v86.ecx & 0x3f) == 0) {
 		DEBUG("Invalid geometry for unit %d", bd->bd_unit);
-		return(0);
+		return(0);				/* skip device */
 	}
 	bd->bd_flags |= BD_MODEINT13;
 	bd->bd_type = v86.ebx & 0xff;
@@ -272,6 +315,17 @@ bd_print(int verbose)
 	
 	if (!bd_opendisk(&od, &dev)) {
 
+#ifdef LOADER_GPT_SUPPORT
+	    /* Do we have a GPT table? */
+	    if (od->od_flags & BD_GPTOK) {
+		for (j = 0; j < od->od_nparts; j++) {
+		    sprintf(line, "      disk%dp%d", i,
+			od->od_partitions[j].gp_index);
+		    bd_printgptpart(od, &od->od_partitions[j], line, verbose);
+		}
+	    } else
+#endif
+
 	    /* Do we have a partition table? */
 	    if (od->od_flags & BD_PARTTABOK) {
 		dptr = &od->od_slicetab[0];
@@ -296,6 +350,76 @@ bd_print(int verbose)
     }
 }
 
+/* Given a size in 512 byte sectors, convert it to a human-readable number. */
+static char *
+display_size(uint64_t size)
+{
+    static char buf[80];
+    char unit;
+
+    size /= 2;
+    unit = 'K';
+    if (size >= 10485760000LL) {
+	size /= 1073741824;
+	unit = 'T';
+    } else if (size >= 10240000) {
+	size /= 1048576;
+	unit = 'G';
+    } else if (size >= 10000) {
+	size /= 1024;
+	unit = 'M';
+    }
+    sprintf(buf, "%.6ld%cB", (long)size, unit);
+    return (buf);
+}
+
+#ifdef LOADER_GPT_SUPPORT
+static uuid_t efi = GPT_ENT_TYPE_EFI;
+/* static uuid_t freebsd_boot = GPT_ENT_TYPE_FREEBSD_BOOT; */
+static uuid_t freebsd_ufs = GPT_ENT_TYPE_FREEBSD_UFS;
+static uuid_t freebsd_swap = GPT_ENT_TYPE_FREEBSD_SWAP;
+/* static uuid_t freebsd_zfs = GPT_ENT_TYPE_FREEBSD_ZFS; */
+static uuid_t ms_basic_data = GPT_ENT_TYPE_MS_BASIC_DATA;
+
+static void
+bd_printgptpart(struct open_disk *od, struct gpt_part *gp, char *prefix,
+    int verbose)
+{
+    char stats[80];
+    char line[96];
+
+    if (verbose)
+	sprintf(stats, " %s", display_size(gp->gp_end + 1 - gp->gp_start));
+    else
+	stats[0] = '\0';
+
+    if (uuid_equal(&gp->gp_type, &efi, NULL))
+	sprintf(line, "%s: EFI         %s\n", prefix, stats);
+    else if (uuid_equal(&gp->gp_type, &ms_basic_data, NULL))
+	sprintf(line, "%s: FAT/NTFS    %s\n", prefix, stats);
+/*     else if (uuid_equal(&gp->gp_type, &freebsd_boot, NULL))
+ *	sprintf(line, "%s: FreeBSD boot%s\n", prefix, stats);
+ */
+    else if (uuid_equal(&gp->gp_type, &freebsd_ufs, NULL))
+	sprintf(line, "%s: FreeBSD UFS %s\n", prefix, stats);
+/*    else if (uuid_equal(&gp->gp_type, &freebsd_zfs, NULL))
+ * 	sprintf(line, "%s: FreeBSD ZFS %s\n", prefix, stats);
+ */
+    else if (uuid_equal(&gp->gp_type, &freebsd_swap, NULL))
+	sprintf(line, "%s: FreeBSD swap%s\n", prefix, stats);
+    else
+	sprintf(line, "%s: %08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x%s\n",
+	    prefix,
+	    gp->gp_type.time_low, gp->gp_type.time_mid,
+	    gp->gp_type.time_hi_and_version,
+	    gp->gp_type.clock_seq_hi_and_reserved, gp->gp_type.clock_seq_low,
+	    gp->gp_type.node[0], gp->gp_type.node[1], gp->gp_type.node[2],
+	    gp->gp_type.node[3], gp->gp_type.node[4], gp->gp_type.node[5],
+	    stats);
+    pager_output(line);
+}
+#endif
+
 /*
  * Print information about slices on a disk.  For the size calculations we
  * assume a 512 byte sector.
@@ -304,8 +428,15 @@ static void
 bd_printslice(struct open_disk *od, struct dos_partition *dp, char *prefix,
 	int verbose)
 {
+	char stats[80];
 	char line[80];
 
+	if (verbose)
+		sprintf(stats, " %s (%d - %d)", display_size(dp->dp_size),
+		    dp->dp_start, dp->dp_start + dp->dp_size);
+	else
+		stats[0] = '\0';
+
 	switch (dp->dp_typ) {
 	case DOSPTYP_DFLYBSD:
 	case DOSPTYP_386BSD:
@@ -314,63 +445,36 @@ bd_printslice(struct open_disk *od, struct dos_partition *dp, char *prefix,
 		bd_printbsdslice(od, (daddr_t)dp->dp_start, prefix, verbose);
 		return;
 	case DOSPTYP_LINSWP:
-		if (verbose)
-			sprintf(line, "%s: Linux swap %.6dMB (%d - %d)\n",
-			    prefix, dp->dp_size / 2048,
-			    dp->dp_start, dp->dp_start + dp->dp_size);
-		else
-			sprintf(line, "%s: Linux swap\n", prefix);
+		sprintf(line, "%s: Linux swap%s\n", prefix, stats);
 		break;
 	case DOSPTYP_LINUX:
 		/*
 		 * XXX
 		 * read the superblock to confirm this is an ext2fs partition?
 		 */
-		if (verbose)
-			sprintf(line, "%s: ext2fs  %.6dMB (%d - %d)\n", prefix,
-			    dp->dp_size / 2048, dp->dp_start,
-			    dp->dp_start + dp->dp_size);
-		else
-			sprintf(line, "%s: ext2fs\n", prefix);
+		sprintf(line, "%s: ext2fs%s\n", prefix, stats);
 		break;
 	case 0x00:				/* unused partition */
 	case DOSPTYP_EXT:
 		return;
 	case 0x01:
-		if (verbose)
-			sprintf(line, "%s: FAT-12  %.6dMB (%d - %d)\n", prefix,
-			    dp->dp_size / 2048, dp->dp_start,
-			    dp->dp_start + dp->dp_size);
-		else
-			sprintf(line, "%s: FAT-12\n", prefix);
+		sprintf(line, "%s: FAT-12%s\n", prefix, stats);
 		break;
 	case 0x04:
 	case 0x06:
 	case 0x0e:
-		if (verbose)
-			sprintf(line, "%s: FAT-16  %.6dMB (%d - %d)\n", prefix,
-			    dp->dp_size / 2048, dp->dp_start,
-			    dp->dp_start + dp->dp_size);
-		else
-			sprintf(line, "%s: FAT-16\n", prefix);
+		sprintf(line, "%s: FAT-16%s\n", prefix, stats);
+		break;
+	case 0x07:
+		sprintf(line, "%s: NTFS/HPFS%s\n", prefix, stats);
 		break;
 	case 0x0b:
 	case 0x0c:
-		if (verbose)
-			sprintf(line, "%s: FAT-32  %.6dMB (%d - %d)\n", prefix,
-			    dp->dp_size / 2048, dp->dp_start,
-			    dp->dp_start + dp->dp_size);
-		else
-			sprintf(line, "%s: FAT-32\n", prefix);
+		sprintf(line, "%s: FAT-32%s\n", prefix, stats);
 		break;
 	default:
-		if (verbose)
-			sprintf(line, "%s: Unknown fs: 0x%x  %.6dMB (%d - %d)\n",
-			    prefix, dp->dp_typ, dp->dp_size / 2048,
-			    dp->dp_start, dp->dp_start + dp->dp_size);
-		else
-			sprintf(line, "%s: Unknown fs: 0x%x\n", prefix,
-			    dp->dp_typ);
+		sprintf(line, "%s: Unknown fs: 0x%x %s\n", prefix, dp->dp_typ,
+		    stats);
 	}
 	pager_output(line);
 }
@@ -524,13 +628,8 @@ bd_open(struct open_file *f, ...)
 static int
 bd_opendisk(struct open_disk **odp, struct i386_devdesc *dev)
 {
-    struct dos_partition	*dptr;
-    struct disklabel32		*lp;
-    struct disklabel64		*lp64;
     struct open_disk		*od;
-    int				sector, slice, i;
     int				error;
-    static char			buf[BUFSIZE];
 
     if (dev->d_kind.biosdisk.unit >= nbdinfo) {
 	DEBUG("attempt to open nonexistent disk");
@@ -543,7 +642,7 @@ bd_opendisk(struct open_disk **odp, struct i386_devdesc *dev)
 	return (ENOMEM);
     }
 
-    /* Look up BIOS unit number, intialise open_disk structure */
+    /* Look up BIOS unit number, initialise open_disk structure */
     od->od_dkunit = dev->d_kind.biosdisk.unit;
     od->od_unit = bdinfo[od->od_dkunit].bd_unit;
     od->od_flags = bdinfo[od->od_dkunit].bd_flags;
@@ -561,15 +660,44 @@ bd_opendisk(struct open_disk **odp, struct i386_devdesc *dev)
 	goto out;
     }
 
+    /* Determine disk layout. */
+#ifdef LOADER_GPT_SUPPORT
+    error = bd_open_gpt(od, dev);
+    if (error)
+#endif
+	error = bd_open_mbr(od, dev);
+
+ out:
+    if (error) {
+	free(od);
+    } else {
+	*odp = od;	/* return the open disk */
+    }
+    return(error);
+}
+
+static int
+bd_open_mbr(struct open_disk *od, struct i386_devdesc *dev)
+{
+    struct dos_partition	*dptr;
+    struct disklabel32		*lp;
+    struct disklabel64		*lp64;
+    int				sector, slice, i;
+    int				error;
+    char			buf[BUFSIZE];
+
     /*
      * Following calculations attempt to determine the correct value
      * for d->od_boff by looking for the slice and partition specified,
      * or searching for reasonable defaults.
      */
 
+    error = 0;
+
     /*
      * Find the slice in the DOS slice table.
      */
+    od->od_nslices = 0;
     if (bd_read(od, 0, 1, buf)) {
 	DEBUG("error reading MBR");
 	error = EIO;
@@ -591,34 +719,17 @@ bd_opendisk(struct open_disk **odp, struct i386_devdesc *dev)
     }
 
     /*
-     * copy the partition table, then pick up any extended partitions.  The
-     * base partition table always has four entries, even if some of them
-     * represented extended partitions.  However, any additional sub-extended
-     * partitions will be silently recursed and not included in the slice
-     * table.
+     * copy the partition table, then pick up any extended partitions.
      */
     bcopy(buf + DOSPARTOFF, &od->od_slicetab,
       sizeof(struct dos_partition) * NDOSPART);
-    od->od_nslices = NDOSPART;
-
-    dptr = &od->od_slicetab[0];
-    for (i = 0; i < NDOSPART; i++, dptr++) {
-	if ((dptr->dp_typ == DOSPTYP_EXT) || (dptr->dp_typ == DOSPTYP_EXTLBA))
-	    bd_chainextended(od, dptr->dp_start, 0); /* 1st offset is zero */
-    }
+    od->od_nslices = 4;			/* extended slices start here */
+    for (i = 0; i < NDOSPART; i++)
+        bd_checkextended(od, i);
     od->od_flags |= BD_PARTTABOK;
     dptr = &od->od_slicetab[0];
 
-    /*
-     * Overflow entries are not loaded into memory but we still keep
-     * track of the count.  Fix it up now.
-     */
-    if (od->od_nslices > NEXTDOSPART)
-	od->od_nslices = NEXTDOSPART;
-
-    /* 
-     * Is this a request for the whole disk? 
-     */
+    /* Is this a request for the whole disk? */
     if (dev->d_kind.biosdisk.slice == -1) {
 	sector = 0;
 	goto unsliced;
@@ -759,95 +870,51 @@ bd_opendisk(struct open_disk **odp, struct i386_devdesc *dev)
     }
 
  out:
-    if (error) {
-	free(od);
-    } else {
-	*odp = od;	/* return the open disk */
-    }
     return(error);
 }
 
 
 static void
-bd_chainextended(struct open_disk *od, u_int32_t base, u_int32_t offset)
+bd_checkextended(struct open_disk *od, int slicenum)
 {
-        char   buf[BIOSDISK_SECSIZE];
-        struct dos_partition *dp1, *dp2;
-	int i;
-
-	if (bd_read(od, (daddr_t)(base + offset), 1, buf)) {
-                printf("\nerror reading extended partition table");
-		return;
+	char	buf[BIOSDISK_SECSIZE];
+	struct dos_partition *dp;
+	u_int base;
+	int i, start, end;
+
+	dp = &od->od_slicetab[slicenum];
+	start = od->od_nslices;
+
+	if (dp->dp_size == 0)
+		goto done;
+	if (dp->dp_typ != DOSPTYP_EXT)
+		goto done;
+	if (bd_read(od, (daddr_t)dp->dp_start, 1, buf))
+		goto done;
+	if (((u_char)buf[0x1fe] != 0x55) || ((u_char)buf[0x1ff] != 0xaa)) {
+		DEBUG("no magic in extended table");
+		goto done;
 	}
-
-	/*
-	 * dp1 points to the first record in the on-disk XPT,
-	 * dp2 points to the next entry in the in-memory parition table.
-	 *
-	 * NOTE: dp2 may be out of bounds if od_nslices >= NEXTDOSPART.
-	 *
-	 * NOTE: unlike the extended partitions in our primary dos partition
-	 * table, we do not record recursed extended partitions themselves 
-	 * in our in-memory partition table.
-	 *
-	 * NOTE: recording within our in-memory table must be breadth first
-	 * ot match what the kernel does.  Thus, two passes are required.
-	 *
-	 * NOTE: partitioning programs which support extended partitions seem
-	 * to always use the first entry for the user partition and the
-	 * second entry to chain, and also appear to disallow more then one
-	 * extended partition at each level.  Nevertheless we make our code
-	 * somewhat more generic (and the same as the kernel's own slice
-	 * scan).
-	 */
-	dp1 = (struct dos_partition *)(&buf[DOSPARTOFF]);
-	dp2 = &od->od_slicetab[od->od_nslices];
-
-	for (i = 0; i < NDOSPART; ++i, ++dp1) {
-		if (dp1->dp_scyl == 0 && dp1->dp_shd == 0 &&
-		    dp1->dp_ssect == 0 && dp1->dp_start == 0 && 
-		    dp1->dp_size == 0) {
+	base = dp->dp_start;
+	dp = (struct dos_partition *)(&buf[DOSPARTOFF]);
+	for (i = 0; i < NDOSPART; i++, dp++) {
+		if (dp->dp_size == 0)
 			continue;
-		}
-		if ((dp1->dp_typ == DOSPTYP_EXT) || 
-		    (dp1->dp_typ == DOSPTYP_EXTLBA)) {
-			/*
-			 * breadth first traversal, must skip in the 
-			 * first pass
-			 */
-			continue;
-		}
-
-		/*
-		 * Only load up the in-memory data if we haven't overflowed
-		 * our in-memory array.
-		 */
-		if (od->od_nslices < NEXTDOSPART) {
-			dp2->dp_typ = dp1->dp_typ;
-			dp2->dp_start = base + offset + dp1->dp_start;
-			dp2->dp_size = dp1->dp_size;
-		}
-		++od->od_nslices;
-		++dp2;
+		if (od->od_nslices == NEXTDOSPART)
+			goto done;
+		dp->dp_start += base;
+		bcopy(dp, &od->od_slicetab[od->od_nslices], sizeof(*dp));
+		od->od_nslices++;
 	}
+	end = od->od_nslices;
 
 	/*
-	 * Pass 2 - handle extended partitions.  Note that the extended
-	 * slice itself is not stored in the slice array when we recurse,
-	 * but any 'original' top-level extended slices are.  This is to
-	 * match what the kernel does.
+	 * now, recursively check the slices we just added
 	 */
-	dp1 -= NDOSPART;
-	for (i = 0; i < NDOSPART; ++i, ++dp1) {
-		if (dp1->dp_scyl == 0 && dp1->dp_shd == 0 &&
-		    dp1->dp_ssect == 0 && dp1->dp_start == 0 && 
-		    dp1->dp_size == 0) {
-			continue;
-		}
-		if ((dp1->dp_typ == DOSPTYP_EXT) || 
-		    (dp1->dp_typ == DOSPTYP_EXTLBA))
-			bd_chainextended(od, base, dp1->dp_start);
-	}
+	for (i = start; i < end; i++)
+		bd_checkextended(od, i);
+done:
+	return;
 }
 
 /*
@@ -913,6 +980,187 @@ bd_bestslice(struct open_disk *od)
 	}
 	return (prefslice);
 }
+
+#ifdef LOADER_GPT_SUPPORT
+static int
+bd_open_gpt(struct open_disk *od, struct i386_devdesc *dev)
+{
+    struct dos_partition *dp;
+    struct gpt_hdr *hdr;
+    struct gpt_ent *ent;
+    struct gpt_part *gp;
+    int	entries_per_sec, error, i, part;
+    daddr_t lba, elba;
+    char gpt[BIOSDISK_SECSIZE], tbl[BIOSDISK_SECSIZE];
+
+    /*
+     * Following calculations attempt to determine the correct value
+     * for d->od_boff by looking for the slice and partition specified,
+     * or searching for reasonable defaults.
+     */
+    error = 0;
+
+    /* First, read the MBR and see if we have a PMBR. */
+    if (bd_read(od, 0, 1, tbl)) {
+	DEBUG("error reading MBR");
+	return (EIO);
+    }
+
+    /* Check the slice table magic. */
+    if (((u_char)tbl[0x1fe] != 0x55) || ((u_char)tbl[0x1ff] != 0xaa))
+	return (ENXIO);
+
+    /* Check for GPT slice. */
+    part = 0;
+    dp = (struct dos_partition *)(tbl + DOSPARTOFF);
+    for (i = 0; i < NDOSPART; i++) {
+	if (dp[i].dp_typ == 0xee)
+	    part++;
+	else if ((part != 1) && (dp[i].dp_typ != 0x00))
+	    return (EINVAL);
+    }
+    if (part != 1)
+	return (EINVAL);
+
+    /* Read primary GPT table header. */
+    if (bd_read(od, 1, 1, gpt)) {
+	DEBUG("error reading GPT header");
+	return (EIO);
+    }
+    hdr = (struct gpt_hdr *)gpt;
+    if (bcmp(hdr->hdr_sig, GPT_HDR_SIG, sizeof(hdr->hdr_sig)) != 0 ||
+	hdr->hdr_lba_self != 1 || hdr->hdr_revision < 0x00010000 ||
+	hdr->hdr_entsz < sizeof(*ent) ||
+	BIOSDISK_SECSIZE % hdr->hdr_entsz != 0) {
+	DEBUG("Invalid GPT header\n");
+	return (EINVAL);
+    }
+
+    /* Now walk the partition table to count the number of valid partitions. */
+    part = 0;
+    entries_per_sec = BIOSDISK_SECSIZE / hdr->hdr_entsz;
+    elba = hdr->hdr_lba_table + hdr->hdr_entries / entries_per_sec;
+    for (lba = hdr->hdr_lba_table; lba < elba; lba++) {
+	if (bd_read(od, lba, 1, tbl)) {
+	    DEBUG("error reading GPT table");
+	    return (EIO);
+	}
+	for (i = 0; i < entries_per_sec; i++) {
+	    ent = (struct gpt_ent *)(tbl + i * hdr->hdr_entsz);
+	    if (uuid_is_nil(&ent->ent_type, NULL) || ent->ent_lba_start == 0 ||
+		ent->ent_lba_end < ent->ent_lba_start)
+		continue;
+	    part++;
+	}
+    }
+
+    /* Save the important information about all the valid partitions. */
+    od->od_nparts = part;
+    if (part != 0) {
+	od->od_partitions = malloc(part * sizeof(struct gpt_part));
+	part = 0;
+	for (lba = hdr->hdr_lba_table; lba < elba; lba++) {
+	    if (bd_read(od, lba, 1, tbl)) {
+		DEBUG("error reading GPT table");
+		error = EIO;
+		goto out;
+	    }
+	    for (i = 0; i < entries_per_sec; i++) {
+		ent = (struct gpt_ent *)(tbl + i * hdr->hdr_entsz);
+		if (uuid_is_nil(&ent->ent_type, NULL) ||
+		    ent->ent_lba_start == 0 ||
+		    ent->ent_lba_end < ent->ent_lba_start)
+		    continue;
+		od->od_partitions[part].gp_index = (lba - hdr->hdr_lba_table) *
+		    entries_per_sec + i + 1;
+		od->od_partitions[part].gp_type = ent->ent_type;
+		od->od_partitions[part].gp_start = ent->ent_lba_start;
+		od->od_partitions[part].gp_end = ent->ent_lba_end;
+		part++;
+	    }
+	}
+    }
+    od->od_flags |= BD_GPTOK;
+
+    /* Is this a request for the whole disk? */
+    if (dev->d_kind.biosdisk.slice < 0) {
+	od->od_boff = 0;
+	return (0);
+    }
+
+    /*
+     * If a partition number was supplied, then the user is trying to use
+     * an MBR address rather than a GPT address, so fail.
+     */
+    if (dev->d_kind.biosdisk.partition != 0xff) {
+	error = ENOENT;
+	goto out;
+    }
+
+    /* If a slice number was supplied but not found, this is an error. */
+    gp = NULL;
+    if (dev->d_kind.biosdisk.slice > 0) {
+	for (i = 0; i < od->od_nparts; i++) {
+	    if (od->od_partitions[i].gp_index == dev->d_kind.biosdisk.slice) {
+		gp = &od->od_partitions[i];
+		break;
+	    }
+	}
+	if (gp == NULL) {
+            DEBUG("partition %d not found", dev->d_kind.biosdisk.slice);
+	    error = ENOENT;
+	    goto out;
+        }
+    }
+
+    /* Try to auto-detect the best partition. */
+    if (dev->d_kind.biosdisk.slice == 0) {
+	gp = bd_best_gptpart(od);
+	if (gp == NULL) {
+	    error = ENOENT;
+	    goto out;
+	}
+	dev->d_kind.biosdisk.slice = gp->gp_index;
+    }
+    od->od_boff = gp->gp_start;
+
+out:
+    if (error) {
+	if (od->od_nparts > 0)
+	    free(od->od_partitions);
+	od->od_flags &= ~BD_GPTOK;
+    }
+    return (error);
+}
+
+static struct gpt_part *
+bd_best_gptpart(struct open_disk *od)
+{
+    struct gpt_part *gp, *prefpart;
+    int i, pref, preflevel;
+
+    prefpart = NULL;
+    preflevel = PREF_NONE;
+
+    gp = od->od_partitions;
+    for (i = 0; i < od->od_nparts; i++, gp++) {
+	/* Windows. XXX: Also Linux. */
+	if (uuid_equal(&gp->gp_type, &ms_basic_data, NULL))
+	    pref = PREF_DOS;
+	/* FreeBSD */
+	else if (uuid_equal(&gp->gp_type, &freebsd_ufs, NULL)
+	    /* || uuid_equal(&gp->gp_type, &freebsd_zfs, NULL) */ )
+	    pref = PREF_FBSD;
+	else
+	    pref = PREF_NONE;
+	if (pref < preflevel) {
+	    preflevel = pref;
+	    prefpart = gp;
+	}
+    }
+    return (prefpart);
+}
+#endif
  
 static int 
 bd_close(struct open_file *f)
@@ -931,6 +1179,10 @@ bd_closedisk(struct open_disk *od)
     /* XXX is this required? (especially if disk already open...) */
     if (od->od_flags & BD_FLOPPY)
 	delay(3000000);
+#endif
+#ifdef LOADER_GPT_SUPPORT
+    if (od->od_flags & BD_GPTOK && od->od_nparts > 0)
+	free(od->od_partitions);
 #endif
     free(od);
 }
@@ -962,14 +1214,14 @@ bd_realstrategy(void *devdata, int rw, daddr_t dblk, size_t size, char *buf, siz
 #endif
 
     DEBUG("open_disk %p", od);
+    blks = size / BIOSDISK_SECSIZE;
+    if (rsize)
+	*rsize = 0;
 
     switch(rw){
     case F_READ:
-	blks = size / BIOSDISK_SECSIZE;
-	DEBUG("read %d from %d to %p", blks, dblk, buf);
+	DEBUG("read %d from %lld to %p", blks, dblk, buf);
 
-	if (rsize)
-	    *rsize = 0;
 	if (blks && bd_read(od, dblk, blks, buf)) {
 	    DEBUG("read error");
 	    return (EIO);
@@ -983,15 +1235,10 @@ bd_realstrategy(void *devdata, int rw, daddr_t dblk, size_t size, char *buf, siz
 	}
 	bcopy(fragbuf, buf + (blks * BIOSDISK_SECSIZE), fragsize);
 #endif
-	if (rsize)
-	    *rsize = size;
-	return (0);
+	break;
     case F_WRITE :
-	blks = size / BIOSDISK_SECSIZE;
 	DEBUG("write %d from %d to %p", blks, dblk, buf);
 
-	if (rsize)
-	    *rsize = 0;
 	if (blks && bd_write(od, dblk, blks, buf)) {
 	    DEBUG("write error");
 	    return (EIO);
@@ -1002,13 +1249,15 @@ bd_realstrategy(void *devdata, int rw, daddr_t dblk, size_t size, char *buf, siz
 	    return (EIO);
 	}
 #endif
-	if (rsize)
-	    *rsize = size;
-	return (0);
+	break;
     default:
-	break; /* DO NOTHING */
+	/* DO NOTHING */
+	return (EROFS);
     }
-    return EROFS;
+
+    if (rsize)
+	*rsize = size;
+    return (0);
 }
 
 static int
diff --git a/sys/boot/pc32/libi386/devicename.c b/sys/boot/pc32/libi386/devicename.c
index ba7eb60ef3..dd82f6d1d7 100644
--- a/sys/boot/pc32/libi386/devicename.c
+++ b/sys/boot/pc32/libi386/devicename.c
@@ -120,6 +120,21 @@ i386_parsedev(struct i386_devdesc **dev, const char *devspec, const char **path)
 		err = EUNIT;
 		goto fail;
 	    }
+#ifdef LOADER_GPT_SUPPORT
+	    if (*cp == 'p') {		/* got a GPT partition */
+		np = cp + 1;
+		slice = strtol(np, &cp, 10);
+		if (cp == np) {
+		    err = ESLICE;
+		    goto fail;
+		}
+		if (*cp && (*cp != ':')) {
+		    err = EINVAL;
+		    goto fail;
+		}
+		partition = 0xff;
+	    } else {
+#endif
 	    if (*cp == 's') {		/* got a slice number */
 		np = cp + 1;
 		slice = strtol(np, &cp, 10);
@@ -136,6 +151,9 @@ i386_parsedev(struct i386_devdesc **dev, const char *devspec, const char **path)
 		}
 		cp++;
 	    }
+#ifdef LOADER_GPT_SUPPORT
+	    }
+#endif
 	}
 	if (*cp && (*cp != ':')) {
 	    err = EINVAL;
@@ -211,10 +229,18 @@ i386_fmtdev(void *vdev)
     case DEVT_DISK:
 	cp = buf;
 	cp += sprintf(cp, "%s%d", dev->d_dev->dv_name, dev->d_kind.biosdisk.unit);
+#ifdef LOADER_GPT_SUPPORT
+	if (dev->d_kind.biosdisk.partition == 0xff) {
+	    cp += sprintf(cp, "p%d", dev->d_kind.biosdisk.slice);
+	} else {
+#endif
 	if (dev->d_kind.biosdisk.slice > 0)
 	    cp += sprintf(cp, "s%d", dev->d_kind.biosdisk.slice);
 	if (dev->d_kind.biosdisk.partition >= 0)
 	    cp += sprintf(cp, "%c", dev->d_kind.biosdisk.partition + 'a');
+#ifdef LOADER_GPT_SUPPORT
+	}
+#endif
 	strcat(cp, ":");
 	break;
 
diff --git a/sys/boot/pc32/loader/Makefile b/sys/boot/pc32/loader/Makefile
index 2db65b3bbc..c79ff53e76 100644
--- a/sys/boot/pc32/loader/Makefile
+++ b/sys/boot/pc32/loader/Makefile
@@ -39,6 +39,9 @@ CFLAGS+=	-DLOADER_BZIP2_SUPPORT
 .if !defined(LOADER_NO_GZIP_SUPPORT)
 CFLAGS+=	-DLOADER_GZIP_SUPPORT
 .endif
+.if !defined(LOADER_NO_GPT_SUPPORT)
+CFLAGS+=	-DLOADER_GPT_SUPPORT
+.endif
 
 # Always add MI sources 
 .PATH:		${.CURDIR}/../../common
